<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2017 Johannes Hölzl. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Johannes Hölzl, Mario Carneiro</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  Bases of topologies. Countability axioms.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  import topology.constructions data.set.countable</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  open set filter lattice classical</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  open_locale topological_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  namespace filter</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  universes u v</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  variables {α : Type u} {β : Type v}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  A filter has a countable basis iff it is generated by a countable collection</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  of subsets of α. (A filter is a generated by a collection of sets iff it is</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  the infimum of the principal filters.)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  Note: we do not require the collection to be closed under finite intersections.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  def has_countable_basis (f : filter α) : Prop :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  ∃ s : set (set α), countable s ∧ f = ⨅ t ∈ s, principal t</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.countable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α ι : Type u} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α ι : Type u} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title=' Countable sets

A set is countable if there exists an encoding of the set into the natural numbers.
An encoding is an injection with a partial inverse, which can be viewed as a
constructive analogue of countability. (For the most part, theorems about
`countable` will be classical and `encodable` will be constructive.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  lemma has_countable_basis_of_seq (f : filter α) (x : ℕ → set α) (h : f = ⨅ i, principal (x i)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {ι : Type} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {ι : Type} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                         </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29    f.has_countable_basis :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.has_countable_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, filter.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A filter has a countable basis iff it is generated by a countable collection
of subsets of α. (A filter is a generated by a collection of sets iff it is
the infimum of the principal filters.)

Note: we do not require the collection to be closed under finite intersections.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  ⟨range x, countable_range _, by rwa infi_range⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.countable_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='lattice.infi_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 106, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 542, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {ι : Type}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} {β : Type u} [_inst_1 : encodable.{0} α] (f : α → β), @set.countable.{u} β (@set.range.{u 1} β α f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} {ι : Type} [_inst_1 : lattice.complete_lattice.{u} α] {g : β → α} {f : ι → β}, @eq.{u+1} α (@lattice.infi.{u u+1} α β (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (λ (b : β), @lattice.infi.{u 0} α (@has_mem.mem.{u u} β (set.{u} β) (@set.has_mem.{u} β) b (@set.range.{u 1} β ι f)) (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (λ (H : @has_mem.mem.{u u} β (set.{u} β) (@set.has_mem.{u} β) b (@set.range.{u 1} β ι f)), g b))) (@lattice.infi.{u 1} α ι (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (λ (i : ι), g (f i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
x : nat → set.{u} α,
h :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x i)))
⊢ @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (t : set.{u} α),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
               (@set.range.{u 1} (set.{u} α) nat x))
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
                 (@set.range.{u 1} (set.{u} α) nat x)), @filter.principal.{u} α t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  lemma seq_of_has_countable_basis (f : filter α) (cblb : f.has_countable_basis) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.has_countable_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, filter.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='orange'><a title='A filter has a countable basis iff it is generated by a countable collection
of subsets of α. (A filter is a generated by a collection of sets iff it is
the infimum of the principal filters.)

Note: we do not require the collection to be closed under finite intersections.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33      ∃ x : ℕ → set α, f = ⨅ i, principal (x i) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {ι : Type} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {ι : Type} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       @eq.{u+1} (filter.{u} α) f
         (@lattice.infi.{u 1} (filter.{u} α) nat
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    rcases cblb with ⟨B, Bcbl, gen⟩, subst gen,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='cblb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='gen'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@filter.has_countable_basis.{u} α f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (filter.{u} α) f (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α) (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (t : set.{u} α), @lattice.infi.{u 0} (filter.{u} α) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B) (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B), @filter.principal.{u} α t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       @eq.{u+1} (filter.{u} α) f
         (@lattice.infi.{u 1} (filter.{u} α) nat
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
B : set.{u} (set.{u} α),
Bcbl : @set.countable.{u} (set.{u} α) B,
gen :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (t : set.{u} α),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B),
               @filter.principal.{u} α t)))
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       @eq.{u+1} (filter.{u} α) f
         (@lattice.infi.{u 1} (filter.{u} α) nat
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bcbl : @set.countable.{u} (set.{u} α) B
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       @eq.{u+1} (filter.{u} α)
         (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (t : set.{u} α),
               @lattice.infi.{u 0} (filter.{u} α)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B),
                    @filter.principal.{u} α t)))
         (@lattice.infi.{u 1} (filter.{u} α) nat
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36    cases B.eq_empty_or_nonempty with hB Bnonempty, { use λ n, set.univ, simp [principal_univ, *] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='filter.principal_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 215, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 714, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, set.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1}, @eq.{?l_1+1} (filter.{?l_1} α) (@filter.principal.{?l_1} α (@set.univ.{?l_1} α)) (@lattice.has_top.top.{?l_1} (filter.{?l_1} α) (@filter.lattice.has_top.{?l_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bcbl : @set.countable.{u} (set.{u} α) B
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       @eq.{u+1} (filter.{u} α)
         (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (t : set.{u} α),
               @lattice.infi.{u 0} (filter.{u} α)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B),
                    @filter.principal.{u} α t)))
         (@lattice.infi.{u 1} (filter.{u} α) nat
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u,
B : set.{u} (set.{u} α),
Bcbl : @set.countable.{u} (set.{u} α) B,
hB :
  @eq.{(max (u+1) 1)} (set.{u} (set.{u} α)) B
    (@has_emptyc.emptyc.{u} (set.{u} (set.{u} α)) (@set.has_emptyc.{u} (set.{u} α)))
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       @eq.{u+1} (filter.{u} α)
         (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (t : set.{u} α),
               @lattice.infi.{u 0} (filter.{u} α)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B),
                    @filter.principal.{u} α t)))
         (@lattice.infi.{u 1} (filter.{u} α) nat
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (i : nat), @filter.principal.{u} α (x i))))

case or.inr
α : Type u,
B : set.{u} (set.{u} α),
Bcbl : @set.countable.{u} (set.{u} α) B,
Bnonempty : @set.nonempty.{u} (set.{u} α) B
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       @eq.{u+1} (filter.{u} α)
         (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (t : set.{u} α),
               @lattice.infi.{u 0} (filter.{u} α)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B),
                    @filter.principal.{u} α t)))
         (@lattice.infi.{u 1} (filter.{u} α) nat
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
B : set.{u} (set.{u} α),
Bcbl : @set.countable.{u} (set.{u} α) B,
hB :
  @eq.{(max (u+1) 1)} (set.{u} (set.{u} α)) B
    (@has_emptyc.emptyc.{u} (set.{u} (set.{u} α)) (@set.has_emptyc.{u} (set.{u} α)))
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       @eq.{u+1} (filter.{u} α)
         (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (t : set.{u} α),
               @lattice.infi.{u 0} (filter.{u} α)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B),
                    @filter.principal.{u} α t)))
         (@lattice.infi.{u 1} (filter.{u} α) nat
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bcbl : @set.countable.{u} (set.{u} α) B,
hB :
  @eq.{(max (u+1) 1)} (set.{u} (set.{u} α)) B
    (@has_emptyc.emptyc.{u} (set.{u} (set.{u} α)) (@set.has_emptyc.{u} (set.{u} α)))
⊢ @eq.{u+1} (filter.{u} α)
    (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (t : set.{u} α),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B),
               @filter.principal.{u} α t)))
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (@set.univ.{u} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
B : set.{u} (set.{u} α),
Bcbl : @set.countable.{u} (set.{u} α) B,
Bnonempty : @set.nonempty.{u} (set.{u} α) B
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       @eq.{u+1} (filter.{u} α)
         (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (t : set.{u} α),
               @lattice.infi.{u 0} (filter.{u} α)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B),
                    @filter.principal.{u} α t)))
         (@lattice.infi.{u 1} (filter.{u} α) nat
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37    rw countable_iff_exists_surjective_to_subtype Bnonempty at Bcbl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.countable_iff_exists_surjective_to_subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Bnonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 59, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, @set.nonempty.{u} α s → iff (@set.countable.{u} α s) (@Exists.{(max 1 (u+1))} (nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s) (λ (f : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s), @function.surjective.{1 (max 1 (u+1))} nat (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@set.nonempty.{u} (set.{u} α) B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A non-empty set is countable iff there exists a surjection from the
natural numbers onto the subtype induced by the set.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
B : set.{u} (set.{u} α),
Bcbl : @set.countable.{u} (set.{u} α) B,
Bnonempty : @set.nonempty.{u} (set.{u} α) B
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       @eq.{u+1} (filter.{u} α)
         (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (t : set.{u} α),
               @lattice.infi.{u 0} (filter.{u} α)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B),
                    @filter.principal.{u} α t)))
         (@lattice.infi.{u 1} (filter.{u} α) nat
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
Bcbl :
  @Exists.{(max 1 (u+1))}
    (nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    (λ
     (f :
       nat →
       @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B),
       @function.surjective.{1 (max 1 (u+1))} nat
         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
         f)
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       @eq.{u+1} (filter.{u} α)
         (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (t : set.{u} α),
               @lattice.infi.{u 0} (filter.{u} α)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B),
                    @filter.principal.{u} α t)))
         (@lattice.infi.{u 1} (filter.{u} α) nat
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38    rcases Bcbl with ⟨g, gsurj⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='Bcbl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max 1 (u+1))} (nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B) (λ (f : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B), @function.surjective.{1 (max 1 (u+1))} nat (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
Bcbl :
  @Exists.{(max 1 (u+1))}
    (nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    (λ
     (f :
       nat →
       @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B),
       @function.surjective.{1 (max 1 (u+1))} nat
         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
         f)
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       @eq.{u+1} (filter.{u} α)
         (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (t : set.{u} α),
               @lattice.infi.{u 0} (filter.{u} α)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B),
                    @filter.principal.{u} α t)))
         (@lattice.infi.{u 1} (filter.{u} α) nat
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       @eq.{u+1} (filter.{u} α)
         (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (t : set.{u} α),
               @lattice.infi.{u 0} (filter.{u} α)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B),
                    @filter.principal.{u} α t)))
         (@lattice.infi.{u 1} (filter.{u} α) nat
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39    rw lattice.infi_subtype&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='lattice.infi_subtype&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 662, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α ι : Type u} [_inst_1 : lattice.complete_lattice.{u} α] {p : ι → Prop} {f : Π (i : ι), p i → α}, @eq.{u+1} α (@lattice.infi.{u u+1} α ι (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (λ (i : ι), @lattice.infi.{u 0} α (p i) (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (λ (h : p i), f i h))) (@lattice.infi.{u (max 1 (u+1))} α (@subtype.{u+1} ι p) (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (λ (x : @subtype.{u+1} ι p), f (@subtype.val.{u+1} ι p x) (@subtype.property.{u+1} ι p x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       @eq.{u+1} (filter.{u} α)
         (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (t : set.{u} α),
               @lattice.infi.{u 0} (filter.{u} α)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t B),
                    @filter.principal.{u} α t)))
         (@lattice.infi.{u 1} (filter.{u} α) nat
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       @eq.{u+1} (filter.{u} α)
         (@lattice.infi.{u (max 1 (u+1))} (filter.{u} α)
            (@subtype.{u+1} (set.{u} α)
               (λ (i : set.{u} α),
                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B))
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ
             (x :
               @subtype.{u+1} (set.{u} α)
                 (λ (i : set.{u} α),
                    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)),
               @filter.principal.{u} α
                 (@subtype.val.{u+1} (set.{u} α)
                    (λ (i : set.{u} α),
                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
                    x)))
         (@lattice.infi.{u 1} (filter.{u} α) nat
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40    use (λ n, g n), apply le_antisymm; rw le_infi_iff,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='lattice.le_infi_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : partial_order.{u} α] {a b : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a b → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) b a → @eq.{u+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {ι : Type} [_inst_1 : lattice.complete_lattice.{u} α] {s : ι → α} {a : α}, iff (@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) a (@lattice.infi.{u 1} α ι (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) s)) (∀ (i : ι), @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) a (s i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       @eq.{u+1} (filter.{u} α)
         (@lattice.infi.{u (max 1 (u+1))} (filter.{u} α)
            (@subtype.{u+1} (set.{u} α)
               (λ (i : set.{u} α),
                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B))
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ
             (x :
               @subtype.{u+1} (set.{u} α)
                 (λ (i : set.{u} α),
                    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)),
               @filter.principal.{u} α
                 (@subtype.val.{u+1} (set.{u} α)
                    (λ (i : set.{u} α),
                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
                    x)))
         (@lattice.infi.{u 1} (filter.{u} α) nat
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g
⊢ @eq.{u+1} (filter.{u} α)
    (@lattice.infi.{u (max 1 (u+1))} (filter.{u} α)
       (@subtype.{u+1} (set.{u} α)
          (λ (i : set.{u} α),
             @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B))
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ
        (x :
          @subtype.{u+1} (set.{u} α)
            (λ (i : set.{u} α),
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)),
          @filter.principal.{u} α
            (@subtype.val.{u+1} (set.{u} α)
               (λ (i : set.{u} α),
                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
               x)))
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat),
          @filter.principal.{u} α
            (@coe.{(max 1 (u+1)) (max (u+1) 1)}
               (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                  B)
               (set.{u} α)
               (@coe_to_lift.{(max 1 (u+1)) (max (u+1) 1)}
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     B)
                  (set.{u} α)
                  (@coe_base.{(max 1 (u+1)) (max (u+1) 1)}
                     (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                        (@set.has_coe_to_sort.{u} (set.{u} α))
                        B)
                     (set.{u} α)
                     (@coe_subtype.{(max (u+1) 1)} (set.{u} α)
                        (λ (x : set.{u} α),
                           @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x
                             B))))
               (g i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
    (@lattice.infi.{u (max 1 (u+1))} (filter.{u} α)
       (@subtype.{u+1} (set.{u} α)
          (λ (i : set.{u} α),
             @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B))
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ
        (x :
          @subtype.{u+1} (set.{u} α)
            (λ (i : set.{u} α),
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)),
          @filter.principal.{u} α
            (@subtype.val.{u+1} (set.{u} α)
               (λ (i : set.{u} α),
                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
               x)))
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat),
          @filter.principal.{u} α
            (@coe.{(max 1 (u+1)) (max (u+1) 1)}
               (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                  B)
               (set.{u} α)
               (@coe_to_lift.{(max 1 (u+1)) (max (u+1) 1)}
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     B)
                  (set.{u} α)
                  (@coe_base.{(max 1 (u+1)) (max (u+1) 1)}
                     (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                        (@set.has_coe_to_sort.{u} (set.{u} α))
                        B)
                     (set.{u} α)
                     (@coe_subtype.{(max (u+1) 1)} (set.{u} α)
                        (λ (x : set.{u} α),
                           @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x
                             B))))
               (g i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g
⊢ ∀ (i : nat),
    @has_le.le.{u} (filter.{u} α)
      (@preorder.to_has_le.{u} (filter.{u} α)
         (@partial_order.to_preorder.{u} (filter.{u} α)
            (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
               (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                  (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                     (@filter.lattice.complete_lattice.{u} α))))))
      (@lattice.infi.{u (max 1 (u+1))} (filter.{u} α)
         (@subtype.{u+1} (set.{u} α)
            (λ (i : set.{u} α),
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B))
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ
          (x :
            @subtype.{u+1} (set.{u} α)
              (λ (i : set.{u} α),
                 @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)),
            @filter.principal.{u} α
              (@subtype.val.{u+1} (set.{u} α)
                 (λ (i : set.{u} α),
                    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
                 x)))
      (@filter.principal.{u} α
         (@coe.{(max 1 (u+1)) (max (u+1) 1)}
            (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
            (set.{u} α)
            (@coe_to_lift.{(max 1 (u+1)) (max (u+1) 1)}
               (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                  B)
               (set.{u} α)
               (@coe_base.{(max 1 (u+1)) (max (u+1) 1)}
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     B)
                  (set.{u} α)
                  (@coe_subtype.{(max (u+1) 1)} (set.{u} α)
                     (λ (x : set.{u} α),
                        @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B))))
            (g i)))

α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g
⊢ ∀
  (i :
    @subtype.{u+1} (set.{u} α)
      (λ (i : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)),
    @has_le.le.{u} (filter.{u} α)
      (@preorder.to_has_le.{u} (filter.{u} α)
         (@partial_order.to_preorder.{u} (filter.{u} α)
            (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
               (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                  (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                     (@filter.lattice.complete_lattice.{u} α))))))
      (@lattice.infi.{u 1} (filter.{u} α) nat
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ (i : nat),
            @filter.principal.{u} α
              (@coe.{(max 1 (u+1)) (max (u+1) 1)}
                 (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                    (@set.has_coe_to_sort.{u} (set.{u} α))
                    B)
                 (set.{u} α)
                 (@coe_to_lift.{(max 1 (u+1)) (max (u+1) 1)}
                    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       B)
                    (set.{u} α)
                    (@coe_base.{(max 1 (u+1)) (max (u+1) 1)}
                       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                          (@set.has_coe_to_sort.{u} (set.{u} α))
                          B)
                       (set.{u} α)
                       (@coe_subtype.{(max (u+1) 1)} (set.{u} α)
                          (λ (x : set.{u} α),
                             @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x
                               B))))
                 (g i))))
      (@filter.principal.{u} α
         (@subtype.val.{u+1} (set.{u} α)
            (λ (i : set.{u} α),
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41    { intro i, apply infi_le_of_le (g i) _, apply le_refl _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='lattice.infi_le_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 297, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {ι : Type u} [_inst_1 : lattice.complete_lattice.{u} α] {s : ι → α} {a : α} (i : ι), @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) (s i) a → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) (@lattice.infi.{u (max 1 (u+1))} α ι (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) s) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g
⊢ ∀ (i : nat),
    @has_le.le.{u} (filter.{u} α)
      (@preorder.to_has_le.{u} (filter.{u} α)
         (@partial_order.to_preorder.{u} (filter.{u} α)
            (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
               (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                  (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                     (@filter.lattice.complete_lattice.{u} α))))))
      (@lattice.infi.{u (max 1 (u+1))} (filter.{u} α)
         (@subtype.{u+1} (set.{u} α)
            (λ (i : set.{u} α),
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B))
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ
          (x :
            @subtype.{u+1} (set.{u} α)
              (λ (i : set.{u} α),
                 @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)),
            @filter.principal.{u} α
              (@subtype.val.{u+1} (set.{u} α)
                 (λ (i : set.{u} α),
                    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
                 x)))
      (@filter.principal.{u} α
         (@coe.{(max 1 (u+1)) (max (u+1) 1)}
            (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
            (set.{u} α)
            (@coe_to_lift.{(max 1 (u+1)) (max (u+1) 1)}
               (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                  B)
               (set.{u} α)
               (@coe_base.{(max 1 (u+1)) (max (u+1) 1)}
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     B)
                  (set.{u} α)
                  (@coe_subtype.{(max (u+1) 1)} (set.{u} α)
                     (λ (x : set.{u} α),
                        @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B))))
            (g i)))

α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g
⊢ ∀
  (i :
    @subtype.{u+1} (set.{u} α)
      (λ (i : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)),
    @has_le.le.{u} (filter.{u} α)
      (@preorder.to_has_le.{u} (filter.{u} α)
         (@partial_order.to_preorder.{u} (filter.{u} α)
            (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
               (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                  (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                     (@filter.lattice.complete_lattice.{u} α))))))
      (@lattice.infi.{u 1} (filter.{u} α) nat
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ (i : nat),
            @filter.principal.{u} α
              (@coe.{(max 1 (u+1)) (max (u+1) 1)}
                 (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                    (@set.has_coe_to_sort.{u} (set.{u} α))
                    B)
                 (set.{u} α)
                 (@coe_to_lift.{(max 1 (u+1)) (max (u+1) 1)}
                    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       B)
                    (set.{u} α)
                    (@coe_base.{(max 1 (u+1)) (max (u+1) 1)}
                       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                          (@set.has_coe_to_sort.{u} (set.{u} α))
                          B)
                       (set.{u} α)
                       (@coe_subtype.{(max (u+1) 1)} (set.{u} α)
                          (λ (x : set.{u} α),
                             @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x
                               B))))
                 (g i))))
      (@filter.principal.{u} α
         (@subtype.val.{u+1} (set.{u} α)
            (λ (i : set.{u} α),
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g
⊢ ∀ (i : nat),
    @has_le.le.{u} (filter.{u} α)
      (@preorder.to_has_le.{u} (filter.{u} α)
         (@partial_order.to_preorder.{u} (filter.{u} α)
            (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
               (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                  (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                     (@filter.lattice.complete_lattice.{u} α))))))
      (@lattice.infi.{u (max 1 (u+1))} (filter.{u} α)
         (@subtype.{u+1} (set.{u} α)
            (λ (i : set.{u} α),
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B))
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ
          (x :
            @subtype.{u+1} (set.{u} α)
              (λ (i : set.{u} α),
                 @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)),
            @filter.principal.{u} α
              (@subtype.val.{u+1} (set.{u} α)
                 (λ (i : set.{u} α),
                    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
                 x)))
      (@filter.principal.{u} α
         (@coe.{(max 1 (u+1)) (max (u+1) 1)}
            (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
            (set.{u} α)
            (@coe_to_lift.{(max 1 (u+1)) (max (u+1) 1)}
               (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                  B)
               (set.{u} α)
               (@coe_base.{(max 1 (u+1)) (max (u+1) 1)}
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     B)
                  (set.{u} α)
                  (@coe_subtype.{(max (u+1) 1)} (set.{u} α)
                     (λ (x : set.{u} α),
                        @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B))))
            (g i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g,
i : nat
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α)
          (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
             (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.complete_lattice.{u} α))))))
    (@lattice.infi.{u (max 1 (u+1))} (filter.{u} α)
       (@subtype.{u+1} (set.{u} α)
          (λ (i : set.{u} α),
             @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B))
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ
        (x :
          @subtype.{u+1} (set.{u} α)
            (λ (i : set.{u} α),
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)),
          @filter.principal.{u} α
            (@subtype.val.{u+1} (set.{u} α)
               (λ (i : set.{u} α),
                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
               x)))
    (@filter.principal.{u} α
       (@coe.{(max 1 (u+1)) (max (u+1) 1)}
          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
          (set.{u} α)
          (@coe_to_lift.{(max 1 (u+1)) (max (u+1) 1)}
             (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                B)
             (set.{u} α)
             (@coe_base.{(max 1 (u+1)) (max (u+1) 1)}
                (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                   (@set.has_coe_to_sort.{u} (set.{u} α))
                   B)
                (set.{u} α)
                (@coe_subtype.{(max (u+1) 1)} (set.{u} α)
                   (λ (x : set.{u} α),
                      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B))))
          (g i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g,
i : nat
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α)
          (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
             (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.complete_lattice.{u} α))))))
    (@filter.principal.{u} α
       (@subtype.val.{u+1} (set.{u} α)
          (λ (i : set.{u} α),
             @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
          (g i)))
    (@filter.principal.{u} α
       (@coe.{(max 1 (u+1)) (max (u+1) 1)}
          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
          (set.{u} α)
          (@coe_to_lift.{(max 1 (u+1)) (max (u+1) 1)}
             (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                B)
             (set.{u} α)
             (@coe_base.{(max 1 (u+1)) (max (u+1) 1)}
                (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                   (@set.has_coe_to_sort.{u} (set.{u} α))
                   B)
                (set.{u} α)
                (@coe_subtype.{(max (u+1) 1)} (set.{u} α)
                   (λ (x : set.{u} α),
                      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B))))
          (g i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g
⊢ ∀
  (i :
    @subtype.{u+1} (set.{u} α)
      (λ (i : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)),
    @has_le.le.{u} (filter.{u} α)
      (@preorder.to_has_le.{u} (filter.{u} α)
         (@partial_order.to_preorder.{u} (filter.{u} α)
            (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
               (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                  (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                     (@filter.lattice.complete_lattice.{u} α))))))
      (@lattice.infi.{u 1} (filter.{u} α) nat
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ (i : nat),
            @filter.principal.{u} α
              (@coe.{(max 1 (u+1)) (max (u+1) 1)}
                 (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                    (@set.has_coe_to_sort.{u} (set.{u} α))
                    B)
                 (set.{u} α)
                 (@coe_to_lift.{(max 1 (u+1)) (max (u+1) 1)}
                    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       B)
                    (set.{u} α)
                    (@coe_base.{(max 1 (u+1)) (max (u+1) 1)}
                       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                          (@set.has_coe_to_sort.{u} (set.{u} α))
                          B)
                       (set.{u} α)
                       (@coe_subtype.{(max (u+1) 1)} (set.{u} α)
                          (λ (x : set.{u} α),
                             @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x
                               B))))
                 (g i))))
      (@filter.principal.{u} α
         (@subtype.val.{u+1} (set.{u} α)
            (λ (i : set.{u} α),
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42    { intros a, rcases gsurj a with i, apply infi_le_of_le i _, subst h, apply le_refl _ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='gsurj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='lattice.infi_le_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 297, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@function.surjective.{1 (max 1 (u+1))} nat (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B) g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@subtype.{u+1} (set.{u} α) (λ (i : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {ι : Type} [_inst_1 : lattice.complete_lattice.{u} α] {s : ι → α} {a : α} (i : ι), @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) (s i) a → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) (@lattice.infi.{u 1} α ι (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) s) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max 1 (u+1))} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B) (g i) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g
⊢ ∀
  (i :
    @subtype.{u+1} (set.{u} α)
      (λ (i : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)),
    @has_le.le.{u} (filter.{u} α)
      (@preorder.to_has_le.{u} (filter.{u} α)
         (@partial_order.to_preorder.{u} (filter.{u} α)
            (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
               (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                  (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                     (@filter.lattice.complete_lattice.{u} α))))))
      (@lattice.infi.{u 1} (filter.{u} α) nat
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ (i : nat),
            @filter.principal.{u} α
              (@coe.{(max 1 (u+1)) (max (u+1) 1)}
                 (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                    (@set.has_coe_to_sort.{u} (set.{u} α))
                    B)
                 (set.{u} α)
                 (@coe_to_lift.{(max 1 (u+1)) (max (u+1) 1)}
                    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       B)
                    (set.{u} α)
                    (@coe_base.{(max 1 (u+1)) (max (u+1) 1)}
                       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                          (@set.has_coe_to_sort.{u} (set.{u} α))
                          B)
                       (set.{u} α)
                       (@coe_subtype.{(max (u+1) 1)} (set.{u} α)
                          (λ (x : set.{u} α),
                             @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x
                               B))))
                 (g i))))
      (@filter.principal.{u} α
         (@subtype.val.{u+1} (set.{u} α)
            (λ (i : set.{u} α),
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g,
a :
  @subtype.{u+1} (set.{u} α)
    (λ (i : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α)
          (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
             (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.complete_lattice.{u} α))))))
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat),
          @filter.principal.{u} α
            (@coe.{(max 1 (u+1)) (max (u+1) 1)}
               (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                  B)
               (set.{u} α)
               (@coe_to_lift.{(max 1 (u+1)) (max (u+1) 1)}
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     B)
                  (set.{u} α)
                  (@coe_base.{(max 1 (u+1)) (max (u+1) 1)}
                     (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                        (@set.has_coe_to_sort.{u} (set.{u} α))
                        B)
                     (set.{u} α)
                     (@coe_subtype.{(max (u+1) 1)} (set.{u} α)
                        (λ (x : set.{u} α),
                           @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x
                             B))))
               (g i))))
    (@filter.principal.{u} α
       (@subtype.val.{u+1} (set.{u} α)
          (λ (i : set.{u} α),
             @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g,
a :
  @subtype.{u+1} (set.{u} α)
    (λ (i : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B),
i : nat,
h :
  @eq.{(max 1 (u+1))}
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    (g i)
    a
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α)
          (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
             (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.complete_lattice.{u} α))))))
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat),
          @filter.principal.{u} α
            (@coe.{(max 1 (u+1)) (max (u+1) 1)}
               (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                  B)
               (set.{u} α)
               (@coe_to_lift.{(max 1 (u+1)) (max (u+1) 1)}
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     B)
                  (set.{u} α)
                  (@coe_base.{(max 1 (u+1)) (max (u+1) 1)}
                     (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                        (@set.has_coe_to_sort.{u} (set.{u} α))
                        B)
                     (set.{u} α)
                     (@coe_subtype.{(max (u+1) 1)} (set.{u} α)
                        (λ (x : set.{u} α),
                           @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x
                             B))))
               (g i))))
    (@filter.principal.{u} α
       (@subtype.val.{u+1} (set.{u} α)
          (λ (i : set.{u} α),
             @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g,
a :
  @subtype.{u+1} (set.{u} α)
    (λ (i : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B),
i : nat,
h :
  @eq.{(max 1 (u+1))}
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    (g i)
    a
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α)
          (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
             (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.complete_lattice.{u} α))))))
    (@filter.principal.{u} α
       (@coe.{(max 1 (u+1)) (max (u+1) 1)}
          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
          (set.{u} α)
          (@coe_to_lift.{(max 1 (u+1)) (max (u+1) 1)}
             (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                B)
             (set.{u} α)
             (@coe_base.{(max 1 (u+1)) (max (u+1) 1)}
                (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                   (@set.has_coe_to_sort.{u} (set.{u} α))
                   B)
                (set.{u} α)
                (@coe_subtype.{(max (u+1) 1)} (set.{u} α)
                   (λ (x : set.{u} α),
                      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B))))
          (g i)))
    (@filter.principal.{u} α
       (@subtype.val.{u+1} (set.{u} α)
          (λ (i : set.{u} α),
             @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
B : set.{u} (set.{u} α),
Bnonempty : @set.nonempty.{u} (set.{u} α) B,
g : nat → @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B,
gsurj :
  @function.surjective.{1 (max 1 (u+1))} nat
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
    g,
i : nat
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α)
          (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
             (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.complete_lattice.{u} α))))))
    (@filter.principal.{u} α
       (@coe.{(max 1 (u+1)) (max (u+1) 1)}
          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B)
          (set.{u} α)
          (@coe_to_lift.{(max 1 (u+1)) (max (u+1) 1)}
             (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                B)
             (set.{u} α)
             (@coe_base.{(max 1 (u+1)) (max (u+1) 1)}
                (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                   (@set.has_coe_to_sort.{u} (set.{u} α))
                   B)
                (set.{u} α)
                (@coe_subtype.{(max (u+1) 1)} (set.{u} α)
                   (λ (x : set.{u} α),
                      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B))))
          (g i)))
    (@filter.principal.{u} α
       (@subtype.val.{u+1} (set.{u} α)
          (λ (i : set.{u} α),
             @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i B)
          (g i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  Different characterization of countable basis. A filter has a countable basis</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  iff it is generated by a sequence of sets.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  lemma has_countable_basis_iff_seq (f : filter α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50    f.has_countable_basis ↔</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.has_countable_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, filter.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A filter has a countable basis iff it is generated by a countable collection
of subsets of α. (A filter is a generated by a collection of sets iff it is
the infimum of the principal filters.)

Note: we do not require the collection to be closed under finite intersections.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51      ∃ x : ℕ → set α, f = ⨅ i, principal (x i) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {ι : Type} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {ι : Type} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  ⟨seq_of_has_countable_basis _, λ ⟨x, xgen⟩, has_countable_basis_of_seq _ x xgen⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.seq_of_has_countable_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xgen'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.has_countable_basis_of_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} (f : filter.{u} α), @filter.has_countable_basis.{u} α f → @Exists.{(max (u+1) 1)} (nat → set.{u} α) (λ (x : nat → set.{u} α), @eq.{u+1} (filter.{u} α) f (@lattice.infi.{u 1} (filter.{u} α) nat (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@Exists.{(max (u+1) 1)} (nat → set.{u} α) (λ (x : nat → set.{u} α), @eq.{u+1} (filter.{u} α) f (@lattice.infi.{u 1} (filter.{u} α) nat (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{u+1} (filter.{u} α) f (@lattice.infi.{u 1} (filter.{u} α) nat (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (i : nat), @filter.principal.{u} α (x i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} (f : filter.{u} α) (x : nat → set.{u} α), @eq.{u+1} (filter.{u} α) f (@lattice.infi.{u 1} (filter.{u} α) nat (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (i : nat), @filter.principal.{u} α (x i))) → @filter.has_countable_basis.{u} α f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  lemma mono_seq_of_has_countable_basis (f : filter α) (cblb : f.has_countable_basis) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.has_countable_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, filter.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                              </code><font color='orange'><a title='A filter has a countable basis iff it is generated by a countable collection
of subsets of α. (A filter is a generated by a collection of sets iff it is
the infimum of the principal filters.)

Note: we do not require the collection to be closed under finite intersections.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55    ∃ x : ℕ → set α, (∀ i j, i ≤ j → x j ⊆ x i) ∧ f = ⨅ i, principal (x i) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {ι : Type} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {ι : Type} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       and
         (∀ (i j : nat),
            @has_le.le.{0} nat nat.has_le i j →
            @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i))
         (@eq.{u+1} (filter.{u} α) f
            (@lattice.infi.{u 1} (filter.{u} α) nat
               (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
               (λ (i : nat), @filter.principal.{u} α (x i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57    rcases (seq_of_has_countable_basis f cblb) with ⟨x&#x27;, hx&#x27;⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter.seq_of_has_countable_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_fun_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cblb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} (f : filter.{u} α), @filter.has_countable_basis.{u} α f → @Exists.{(max (u+1) 1)} (nat → set.{u} α) (λ (x : nat → set.{u} α), @eq.{u+1} (filter.{u} α) f (@lattice.infi.{u 1} (filter.{u} α) nat (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{1} nat (λ (i : nat), @has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat)) (@filter.has_mem.{0} (finset.{0} nat)) s (@filter.principal.{0} (finset.{0} nat) (@set.Ici.{0} (finset.{0} nat) (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)) (finset.range i)))) → @Exists.{1} (finset.{0} nat) (λ (a : finset.{0} nat), ∀ (b : finset.{0} nat), @ge.{0} (finset.{0} nat) (@preorder.to_has_le.{0} (finset.{0} nat) (@partial_order.to_preorder.{0} (finset.{0} nat) (@lattice.semilattice_sup.to_partial_order.{0} (finset.{0} nat) (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} (finset.{0} nat) (@finset.lattice.semilattice_sup_bot.{0} nat (λ (a b : nat), nat.decidable_eq a b)))))) b a → @has_mem.mem.{0 0} (finset.{0} nat) (set.{0} (finset.{0} nat)) (@set.has_mem.{0} (finset.{0} nat)) b s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@filter.has_countable_basis.{u} α f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       and
         (∀ (i j : nat),
            @has_le.le.{0} nat nat.has_le i j →
            @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i))
         (@eq.{u+1} (filter.{u} α) f
            (@lattice.infi.{u 1} (filter.{u} α) nat
               (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
               (λ (i : nat), @filter.principal.{u} α (x i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f,
x&#x27; : nat → set.{u} α,
hx&#x27; :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i)))
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       and
         (∀ (i j : nat),
            @has_le.le.{0} nat nat.has_le i j →
            @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i))
         (@eq.{u+1} (filter.{u} α) f
            (@lattice.infi.{u 1} (filter.{u} α) nat
               (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
               (λ (i : nat), @filter.principal.{u} α (x i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58    let x := λ n, ⋂ m ≤ n, x&#x27; m,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='set.Inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.Inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {β : Type u} {ι : Type}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {β : Type u} {ι : Type}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Indexed intersection of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Indexed intersection of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f,
x&#x27; : nat → set.{u} α,
hx&#x27; :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i)))
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       and
         (∀ (i j : nat),
            @has_le.le.{0} nat nat.has_le i j →
            @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i))
         (@eq.{u+1} (filter.{u} α) f
            (@lattice.infi.{u 1} (filter.{u} α) nat
               (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
               (λ (i : nat), @filter.principal.{u} α (x i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f,
x&#x27; : nat → set.{u} α,
hx&#x27; :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m))
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       and
         (∀ (i j : nat),
            @has_le.le.{0} nat nat.has_le i j →
            @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i))
         (@eq.{u+1} (filter.{u} α) f
            (@lattice.infi.{u 1} (filter.{u} α) nat
               (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
               (λ (i : nat), @filter.principal.{u} α (x i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59    use x, split,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f,
x&#x27; : nat → set.{u} α,
hx&#x27; :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m))
⊢ @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       and
         (∀ (i j : nat),
            @has_le.le.{0} nat nat.has_le i j →
            @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i))
         (@eq.{u+1} (filter.{u} α) f
            (@lattice.infi.{u 1} (filter.{u} α) nat
               (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
               (λ (i : nat), @filter.principal.{u} α (x i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f,
x&#x27; : nat → set.{u} α,
hx&#x27; :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m))
⊢ and
    (∀ (i j : nat),
       @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i))
    (@eq.{u+1} (filter.{u} α) f
       (@lattice.infi.{u 1} (filter.{u} α) nat
          (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
          (λ (i : nat), @filter.principal.{u} α (x i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f,
x&#x27; : nat → set.{u} α,
hx&#x27; :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m))
⊢ ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i)

α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f,
x&#x27; : nat → set.{u} α,
hx&#x27; :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m))
⊢ @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    { intros i j hij a, simp [x], intros h i&#x27; hi&#x27;i, apply h, transitivity; assumption },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f,
x&#x27; : nat → set.{u} α,
hx&#x27; :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m))
⊢ ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i)

α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f,
x&#x27; : nat → set.{u} α,
hx&#x27; :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m))
⊢ @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f,
x&#x27; : nat → set.{u} α,
hx&#x27; :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m))
⊢ ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f,
x&#x27; : nat → set.{u} α,
hx&#x27; :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
i j : nat,
hij : @has_le.le.{0} nat nat.has_le i j,
a : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (x j) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (x i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f,
x&#x27; : nat → set.{u} α,
hx&#x27; :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
i j : nat,
hij : @has_le.le.{0} nat nat.has_le i j,
a : α
⊢ (∀ (i : nat),
     @has_le.le.{0} nat nat.has_le i j → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (x&#x27; i)) →
  ∀ (i_1 : nat),
    @has_le.le.{0} nat nat.has_le i_1 i → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (x&#x27; i_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f,
x&#x27; : nat → set.{u} α,
hx&#x27; :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
i j : nat,
hij : @has_le.le.{0} nat nat.has_le i j,
a : α,
h :
  ∀ (i : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (x&#x27; i),
i&#x27; : nat,
hi&#x27;i : @has_le.le.{0} nat nat.has_le i&#x27; i
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (x&#x27; i&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f,
x&#x27; : nat → set.{u} α,
hx&#x27; :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
i j : nat,
hij : @has_le.le.{0} nat nat.has_le i j,
a : α,
h :
  ∀ (i : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (x&#x27; i),
i&#x27; : nat,
hi&#x27;i : @has_le.le.{0} nat nat.has_le i&#x27; i
⊢ @has_le.le.{0} nat nat.has_le i&#x27; j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f,
x&#x27; : nat → set.{u} α,
hx&#x27; :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m))
⊢ @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61    subst hx&#x27;, apply le_antisymm; rw le_infi_iff; intro i,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hx&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='lattice.le_infi_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (filter.{u} α) f (@lattice.infi.{u 1} (filter.{u} α) nat (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (i : nat), @filter.principal.{u} α (x&#x27; i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : partial_order.{u} α] {a b : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a b → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) b a → @eq.{u+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {ι : Type} [_inst_1 : lattice.complete_lattice.{u} α] {s : ι → α} {a : α}, iff (@has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) a (@lattice.infi.{u 1} α ι (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) s)) (∀ (i : ι), @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) a (s i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
cblb : @filter.has_countable_basis.{u} α f,
x&#x27; : nat → set.{u} α,
hx&#x27; :
  @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m))
⊢ @eq.{u+1} (filter.{u} α) f
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i)))
⊢ @eq.{u+1} (filter.{u} α)
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i)))
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i)))
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i)))
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i)))
⊢ @eq.{u+1} (filter.{u} α)
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i)))
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i : nat
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α)
          (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
             (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.complete_lattice.{u} α))))))
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i)))
    (@filter.principal.{u} α (x i))

α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i : nat
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α)
          (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
             (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.complete_lattice.{u} α))))))
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x i)))
    (@filter.principal.{u} α (x&#x27; i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62    { rw le_principal_iff, apply Inter_mem_sets (finite_le_nat _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter.le_principal_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='filter.Inter_mem_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.finite_le_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 374, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α} {f : filter.{u} α}, iff (@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@filter.principal.{u} α s)) (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {f : filter.{u} α} {β : Type} {s : β → set.{u} α} {is : set.{0} β}, @set.finite.{0} β is → (∀ (i : β), @has_mem.mem.{0 0} β (set.{0} β) (@set.has_mem.{0} β) i is → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (s i) f) → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@set.Inter.{u 1} α β (λ (i : β), @set.Inter.{u 0} α (@has_mem.mem.{0 0} β (set.{0} β) (@set.has_mem.{0} β) i is) (λ (H : @has_mem.mem.{0 0} β (set.{0} β) (@set.has_mem.{0} β) i is), s i))) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (n : nat), @set.finite.{0} nat (@set_of.{0} nat (λ (i : nat), @has_le.le.{0} nat nat.has_le i n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i : nat
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α)
          (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
             (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.complete_lattice.{u} α))))))
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i)))
    (@filter.principal.{u} α (x i))

α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i : nat
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α)
          (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
             (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.complete_lattice.{u} α))))))
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x i)))
    (@filter.principal.{u} α (x&#x27; i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i : nat
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α)
          (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
             (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.complete_lattice.{u} α))))))
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i)))
    (@filter.principal.{u} α (x i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i : nat
⊢ @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (x i)
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i : nat
⊢ ∀ (i_1 : nat),
    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
      (@set_of.{0} nat (λ (i_1 : nat), @has_le.le.{0} nat nat.has_le i_1 i)) →
    @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (x&#x27; i_1)
      (@lattice.infi.{u 1} (filter.{u} α) nat
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ (i : nat), @filter.principal.{u} α (x&#x27; i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63      intros j hji, rw ← le_principal_iff, apply infi_le_of_le j _, apply le_refl _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='filter.le_principal_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lattice.infi_le_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 374, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 297, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α} {f : filter.{u} α}, iff (@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@filter.principal.{u} α s)) (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {ι : Type} [_inst_1 : lattice.complete_lattice.{u} α] {s : ι → α} {a : α} (i : ι), @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) (s i) a → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) (@lattice.infi.{u 1} α ι (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) s) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i : nat
⊢ ∀ (i_1 : nat),
    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
      (@set_of.{0} nat (λ (i_1 : nat), @has_le.le.{0} nat nat.has_le i_1 i)) →
    @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (x&#x27; i_1)
      (@lattice.infi.{u 1} (filter.{u} α) nat
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ (i : nat), @filter.principal.{u} α (x&#x27; i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i j : nat,
hji :
  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) j
    (@set_of.{0} nat (λ (i_1 : nat), @has_le.le.{0} nat nat.has_le i_1 i))
⊢ @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (x&#x27; j)
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i j : nat,
hji :
  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) j
    (@set_of.{0} nat (λ (i_1 : nat), @has_le.le.{0} nat nat.has_le i_1 i))
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i)))
    (@filter.principal.{u} α (x&#x27; j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i j : nat,
hji :
  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) j
    (@set_of.{0} nat (λ (i_1 : nat), @has_le.le.{0} nat nat.has_le i_1 i))
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α)
          (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
             (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.complete_lattice.{u} α))))))
    (@filter.principal.{u} α (x&#x27; j))
    (@filter.principal.{u} α (x&#x27; j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i : nat
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α)
          (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
             (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.complete_lattice.{u} α))))))
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x i)))
    (@filter.principal.{u} α (x&#x27; i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64    { apply infi_le_of_le i _, rw principal_mono, intro a, simp [x], intro h, apply h, refl },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='lattice.infi_le_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter.principal_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 297, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 378, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {ι : Type} [_inst_1 : lattice.complete_lattice.{u} α] {s : ι → α} {a : α} (i : ι), @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) (s i) a → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) (@lattice.infi.{u 1} α ι (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) s) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α}, iff (@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) (@filter.principal.{u} α s) (@filter.principal.{u} α t)) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i : nat
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α)
          (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
             (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.complete_lattice.{u} α))))))
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x i)))
    (@filter.principal.{u} α (x&#x27; i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i : nat
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α)
          (@lattice.order_bot.to_partial_order.{u} (filter.{u} α)
             (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                   (@filter.lattice.complete_lattice.{u} α))))))
    (@filter.principal.{u} α (x i))
    (@filter.principal.{u} α (x&#x27; i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i : nat
⊢ @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x i) (x&#x27; i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i : nat,
a : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (x i) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (x&#x27; i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i : nat,
a : α
⊢ (∀ (i_1 : nat),
     @has_le.le.{0} nat nat.has_le i_1 i → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (x&#x27; i_1)) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (x&#x27; i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i : nat,
a : α,
h :
  ∀ (i_1 : nat),
    @has_le.le.{0} nat nat.has_le i_1 i → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (x&#x27; i_1)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (x&#x27; i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x&#x27; : nat → set.{u} α,
x : nat → set.{u} α :=
  λ (n : nat),
    @set.Inter.{u 1} α nat
      (λ (m : nat),
         @set.Inter.{u 0} α (@has_le.le.{0} nat nat.has_le m n) (λ (H : @has_le.le.{0} nat nat.has_le m n), x&#x27; m)),
cblb :
  @filter.has_countable_basis.{u} α
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (x&#x27; i))),
i : nat,
a : α,
h :
  ∀ (i_1 : nat),
    @has_le.le.{0} nat nat.has_le i_1 i → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (x&#x27; i_1)
⊢ @has_le.le.{0} nat nat.has_le i i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  Different characterization of countable basis. A filter has a countable basis</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  iff it is generated by a monotonically decreasing sequence of sets.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  lemma has_countable_basis_iff_mono_seq (f : filter α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='blue'><a title='filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72    f.has_countable_basis ↔</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.has_countable_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, filter.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A filter has a countable basis iff it is generated by a countable collection
of subsets of α. (A filter is a generated by a collection of sets iff it is
the infimum of the principal filters.)

Note: we do not require the collection to be closed under finite intersections.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73      ∃ x : ℕ → set α, (∀ i j, i ≤ j → x j ⊆ x i) ∧ f = ⨅ i, principal (x i) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {ι : Type} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {ι : Type} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  ⟨mono_seq_of_has_countable_basis _, λ ⟨x, _, xgen⟩, has_countable_basis_of_seq _ x xgen⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.mono_seq_of_has_countable_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='xgen'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.has_countable_basis_of_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} (f : filter.{u} α), @filter.has_countable_basis.{u} α f → @Exists.{(max (u+1) 1)} (nat → set.{u} α) (λ (x : nat → set.{u} α), and (∀ (i j : nat), @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i)) (@eq.{u+1} (filter.{u} α) f (@lattice.infi.{u 1} (filter.{u} α) nat (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (i : nat), @filter.principal.{u} α (x i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@Exists.{(max (u+1) 1)} (nat → set.{u} α) (λ (x : nat → set.{u} α), and (∀ (i j : nat), @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i)) (@eq.{u+1} (filter.{u} α) f (@lattice.infi.{u 1} (filter.{u} α) nat (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (i : nat), @filter.principal.{u} α (x i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@eq.{u+1} (filter.{u} α) f (@lattice.infi.{u 1} (filter.{u} α) nat (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (i : nat), @filter.principal.{u} α (x i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} (f : filter.{u} α) (x : nat → set.{u} α), @eq.{u+1} (filter.{u} α) f (@lattice.infi.{u 1} (filter.{u} α) nat (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (i : nat), @filter.principal.{u} α (x i))) → @filter.has_countable_basis.{u} α f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  Different characterization of countable basis. A filter has a countable basis</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  iff there exists a monotonically decreasing sequence of sets `x i`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  such that `s ∈ f ↔ ∃ i, x i ⊆ s`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  lemma has_countable_basis_iff_mono_seq&#x27; (f : filter α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81    f.has_countable_basis ↔</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.has_countable_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, filter.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A filter has a countable basis iff it is generated by a countable collection
of subsets of α. (A filter is a generated by a collection of sets iff it is
the infimum of the principal filters.)

Note: we do not require the collection to be closed under finite intersections.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82      ∃ x : ℕ → set α, (∀ i j, i ≤ j → x j ⊆ x i) ∧ (∀ {s}, s ∈ f ↔ ∃ i, x i ⊆ s) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α
⊢ iff (@filter.has_countable_basis.{u} α f)
    (@Exists.{(max (u+1) 1)} (nat → set.{u} α)
       (λ (x : nat → set.{u} α),
          and
            (∀ (i j : nat),
               @has_le.le.{0} nat nat.has_le i j →
               @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i))
            (∀ {s : set.{u} α},
               iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f)
                 (@Exists.{1} nat
                    (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x i) s)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84    refine (has_countable_basis_iff_mono_seq f).trans (exists_congr $ λ x, and_congr_right _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter.has_countable_basis_iff_mono_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='exists_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='and_congr_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 71, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 577, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 375, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} (f : filter.{u} α), iff (@filter.has_countable_basis.{u} α f) (@Exists.{(max (u+1) 1)} (nat → set.{u} α) (λ (x : nat → set.{u} α), and (∀ (i j : nat), @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i)) (@eq.{u+1} (filter.{u} α) f (@lattice.infi.{u 1} (filter.{u} α) nat (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (i : nat), @filter.principal.{u} α (x i))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {p q : α → Prop}, (∀ (a : α), iff (p a) (q a)) → iff (@Exists.{(max (u+1) 1)} α p) (@Exists.{(max (u+1) 1)} α (λ (a : α), q a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b c : Prop}, (a → iff b c) → iff (and a b) (and a c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Different characterization of countable basis. A filter has a countable basis
iff it is generated by a monotonically decreasing sequence of sets.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α
⊢ iff (@filter.has_countable_basis.{u} α f)
    (@Exists.{(max (u+1) 1)} (nat → set.{u} α)
       (λ (x : nat → set.{u} α),
          and
            (∀ (i j : nat),
               @has_le.le.{0} nat nat.has_le i j →
               @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i))
            (∀ {s : set.{u} α},
               iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f)
                 (@Exists.{1} nat
                    (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x i) s)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
x : nat → set.{u} α
⊢ (∀ (i j : nat),
     @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i)) →
  iff
    (@eq.{u+1} (filter.{u} α) f
       (@lattice.infi.{u 1} (filter.{u} α) nat
          (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
          (λ (i : nat), @filter.principal.{u} α (x i))))
    (∀ {s : set.{u} α},
       iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f)
         (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x i) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85    intro hmono,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
x : nat → set.{u} α
⊢ (∀ (i j : nat),
     @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i)) →
  iff
    (@eq.{u+1} (filter.{u} α) f
       (@lattice.infi.{u 1} (filter.{u} α) nat
          (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
          (λ (i : nat), @filter.principal.{u} α (x i))))
    (∀ {s : set.{u} α},
       iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f)
         (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x i) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
x : nat → set.{u} α,
hmono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i)
⊢ iff
    (@eq.{u+1} (filter.{u} α) f
       (@lattice.infi.{u 1} (filter.{u} α) nat
          (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
          (λ (i : nat), @filter.principal.{u} α (x i))))
    (∀ {s : set.{u} α},
       iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f)
         (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x i) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86    have : directed (≥) (λ i, principal (x i)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='directed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ge'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 571, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 371, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → α → Prop) → Π {ι : Type}, (ι → α) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : has_le.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A family of elements of α is directed (with respect to a relation `≼` on α)
 if there is a member of the family `≼`-above any pair in the family.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
x : nat → set.{u} α,
hmono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i)
⊢ iff
    (@eq.{u+1} (filter.{u} α) f
       (@lattice.infi.{u 1} (filter.{u} α) nat
          (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
          (λ (i : nat), @filter.principal.{u} α (x i))))
    (∀ {s : set.{u} α},
       iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f)
         (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x i) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
f : filter.{u} α,
x : nat → set.{u} α,
hmono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i)
⊢ @directed.{u 1} (filter.{u} α)
    (@ge.{u} (filter.{u} α)
       (@preorder.to_has_le.{u} (filter.{u} α)
          (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))))
    nat
    (λ (i : nat), @filter.principal.{u} α (x i))

α : Type u,
f : filter.{u} α,
x : nat → set.{u} α,
hmono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i),
this :
  @directed.{u 1} (filter.{u} α)
    (@ge.{u} (filter.{u} α)
       (@preorder.to_has_le.{u} (filter.{u} α)
          (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))))
    nat
    (λ (i : nat), @filter.principal.{u} α (x i))
⊢ iff
    (@eq.{u+1} (filter.{u} α) f
       (@lattice.infi.{u 1} (filter.{u} α) nat
          (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
          (λ (i : nat), @filter.principal.{u} α (x i))))
    (∀ {s : set.{u} α},
       iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f)
         (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x i) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87      from directed_of_mono _ (λ i j hij, principal_mono.2 (hmono _ _ hij)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='lattice.directed_of_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='filter.principal_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hmono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 100, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 378, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : lattice.semilattice_sup.{0} α] {β : Type u} (f : α → β) {r : β → β → Prop}, (∀ ⦃i j : α⦄, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.semilattice_sup.to_partial_order.{0} α _inst_1))) i j → r (f i) (f j)) → @directed.{u 1} β r α f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α}, iff (@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) (@filter.principal.{u} α s) (@filter.principal.{u} α t)) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i j : nat), @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A monotone function on a sup-semilattice is directed.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
f : filter.{u} α,
x : nat → set.{u} α,
hmono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i)
⊢ @directed.{u 1} (filter.{u} α)
    (@ge.{u} (filter.{u} α)
       (@preorder.to_has_le.{u} (filter.{u} α)
          (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))))
    nat
    (λ (i : nat), @filter.principal.{u} α (x i))

α : Type u,
f : filter.{u} α,
x : nat → set.{u} α,
hmono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i),
this :
  @directed.{u 1} (filter.{u} α)
    (@ge.{u} (filter.{u} α)
       (@preorder.to_has_le.{u} (filter.{u} α)
          (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))))
    nat
    (λ (i : nat), @filter.principal.{u} α (x i))
⊢ iff
    (@eq.{u+1} (filter.{u} α) f
       (@lattice.infi.{u 1} (filter.{u} α) nat
          (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
          (λ (i : nat), @filter.principal.{u} α (x i))))
    (∀ {s : set.{u} α},
       iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f)
         (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x i) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
x : nat → set.{u} α,
hmono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i),
this :
  @directed.{u 1} (filter.{u} α)
    (@ge.{u} (filter.{u} α)
       (@preorder.to_has_le.{u} (filter.{u} α)
          (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))))
    nat
    (λ (i : nat), @filter.principal.{u} α (x i))
⊢ iff
    (@eq.{u+1} (filter.{u} α) f
       (@lattice.infi.{u 1} (filter.{u} α) nat
          (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
          (λ (i : nat), @filter.principal.{u} α (x i))))
    (∀ {s : set.{u} α},
       iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f)
         (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x i) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88    simp only [filter.ext_iff, mem_infi this ⟨0⟩, mem_Union, mem_principal_sets]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='filter.ext_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.mem_infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.mem_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.mem_principal_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 111, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 448, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 194, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {f g : filter.{?l_1} α}, iff (@eq.{?l_1+1} (filter.{?l_1} α) f g) (∀ (s : set.{?l_1} α), iff (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} α) (filter.{?l_1} α) (@filter.has_mem.{?l_1} α) s f) (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} α) (filter.{?l_1} α) (@filter.has_mem.{?l_1} α) s g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {ι : Type} {f : ι → filter.{u} α}, @directed.{u 1} (filter.{u} α) (@ge.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))) ι f → nonempty.{1} ι → ∀ (s : set.{u} α), iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@lattice.infi.{u 1} (filter.{u} α) ι (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) f)) (@Exists.{1} ι (λ (i : ι), @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (f i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@directed.{u 1} (filter.{u} α) (@ge.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))) nat (λ (i : nat), @filter.principal.{u} α (x i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type ?l_1} {ι : Sort ?l_2} {x : β} {s : ι → set.{?l_1} β}, iff (@has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x (@set.Union.{?l_1 ?l_2} β ι s)) (@Exists.{?l_2} ι (λ (i : ι), @has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x (s i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {s t : set.{?l_1} α}, iff (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} α) (filter.{?l_1} α) (@filter.has_mem.{?l_1} α) s (@filter.principal.{?l_1} α t)) (@has_subset.subset.{?l_1} (set.{?l_1} α) (@set.has_subset.{?l_1} α) t s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
f : filter.{u} α,
x : nat → set.{u} α,
hmono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i),
this :
  @directed.{u 1} (filter.{u} α)
    (@ge.{u} (filter.{u} α)
       (@preorder.to_has_le.{u} (filter.{u} α)
          (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))))
    nat
    (λ (i : nat), @filter.principal.{u} α (x i))
⊢ iff
    (@eq.{u+1} (filter.{u} α) f
       (@lattice.infi.{u 1} (filter.{u} α) nat
          (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
          (λ (i : nat), @filter.principal.{u} α (x i))))
    (∀ {s : set.{u} α},
       iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f)
         (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x i) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  lemma has_countable_basis.comap {l : filter β} (h : has_countable_basis l) (f : α → β) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter.has_countable_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u}, filter.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title='A filter has a countable basis iff it is generated by a countable collection
of subsets of α. (A filter is a generated by a collection of sets iff it is
the infimum of the principal filters.)

Note: we do not require the collection to be closed under finite intersections.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92    has_countable_basis (l.comap f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.has_countable_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, filter.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{v} β → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A filter has a countable basis iff it is generated by a countable collection
of subsets of α. (A filter is a generated by a collection of sets iff it is
the infimum of the principal filters.)

Note: we do not require the collection to be closed under finite intersections.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
h : @filter.has_countable_basis.{v} β l,
f : α → β
⊢ @filter.has_countable_basis.{u} α (@filter.comap.{u v} α β f l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94    rcases h with ⟨S, h₁, h₂⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@filter.has_countable_basis.{v} β l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
h : @filter.has_countable_basis.{v} β l,
f : α → β
⊢ @filter.has_countable_basis.{u} α (@filter.comap.{u v} α β f l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t)))
⊢ @filter.has_countable_basis.{u} α (@filter.comap.{u v} α β f l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95    refine ⟨preimage f &#x27;&#x27; S, countable_image _ h₁, _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.countable_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{v} β → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : Type u}, (α → β) → set.{v} α → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{v} (set.{v} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {β : Type u} {s : set.{v} α} (f : α → β), @set.countable.{v} α s → @set.countable.{u} β (@set.image.{v u} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@set.countable.{v} (set.{v} β) S'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t)))
⊢ @filter.has_countable_basis.{u} α (@filter.comap.{u v} α β f l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t)))
⊢ @eq.{u+1} (filter.{u} α) (@filter.comap.{u v} α β f l)
    (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (t : set.{u} α),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
               (@set.image.{v u} (set.{v} β) (set.{u} α) (@set.preimage.{u v} α β f) S))
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
                 (@set.image.{v u} (set.{v} β) (set.{u} α) (@set.preimage.{u v} α β f) S)),
               @filter.principal.{u} α t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96    calc comap f l = ⨅ s ∈ S, principal (f ⁻¹&#x27; s) : by simp [h₂]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tactic.interactive.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{v} β → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='filter.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{v} (set.{v} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (filter.{v} β) l (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β) (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β)) (λ (t : set.{v} β), @lattice.infi.{v 0} (filter.{v} β) (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S) (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β)) (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S), @filter.principal.{v} β t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t)))
⊢ @eq.{u+1} (filter.{u} α) (@filter.comap.{u v} α β f l)
    (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (t : set.{u} α),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
               (@set.image.{v u} (set.{v} β) (set.{u} α) (@set.preimage.{u v} α β f) S))
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
                 (@set.image.{v u} (set.{v} β) (set.{u} α) (@set.preimage.{u v} α β f) S)),
               @filter.principal.{u} α t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t)))
⊢ @eq.{u+1} (filter.{u} α) (@filter.comap.{u v} α β f l)
    (@lattice.infi.{u v+1} (filter.{u} α) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (s : set.{v} β),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S),
               @filter.principal.{u} α (@set.preimage.{u v} α β f s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97    ... = ⨅ s ∈ S, ⨅ (t : set α) (H : f ⁻¹&#x27; s = t), principal t : by simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f s) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t)))
⊢ @eq.{u+1} (filter.{u} α) (@filter.comap.{u v} α β f l)
    (@lattice.infi.{u v+1} (filter.{u} α) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (s : set.{v} β),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S),
               @filter.principal.{u} α (@set.preimage.{u v} α β f s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t)))
⊢ @eq.{u+1} (filter.{u} α) (@filter.comap.{u v} α β f l)
    (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (t : set.{u} α),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
               (@set.image.{v u} (set.{v} β) (set.{u} α) (@set.preimage.{u v} α β f) S))
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
                 (@set.image.{v u} (set.{v} β) (set.{u} α) (@set.preimage.{u v} α β f) S)),
               @filter.principal.{u} α t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t)))
⊢ @eq.{u+1} (filter.{u} α)
    (@lattice.infi.{u v+1} (filter.{u} α) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (s : set.{v} β),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S),
               @filter.principal.{u} α (@set.preimage.{u v} α β f s))))
    (@lattice.infi.{u v+1} (filter.{u} α) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (s : set.{v} β),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S),
               @lattice.infi.{u (max (u+1) 1)} (filter.{u} α) (set.{u} α)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (t : set.{u} α),
                    @lattice.infi.{u 0} (filter.{u} α)
                      (@eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f s) t)
                      (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α)
                         (@filter.lattice.complete_lattice.{u} α))
                      (λ (H : @eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f s) t),
                         @filter.principal.{u} α t)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98    ... = ⨅ (t : set α) (s ∈ S) (h₂ : f ⁻¹&#x27; s = t), principal t :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u} {ι : Type u} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {ι : Type u} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t)))
⊢ @eq.{u+1} (filter.{u} α)
    (@lattice.infi.{u v+1} (filter.{u} α) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (s : set.{v} β),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S),
               @filter.principal.{u} α (@set.preimage.{u v} α β f s))))
    (@lattice.infi.{u v+1} (filter.{u} α) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (s : set.{v} β),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S),
               @lattice.infi.{u (max (u+1) 1)} (filter.{u} α) (set.{u} α)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (t : set.{u} α),
                    @lattice.infi.{u 0} (filter.{u} α)
                      (@eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f s) t)
                      (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α)
                         (@filter.lattice.complete_lattice.{u} α))
                      (λ (H : @eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f s) t),
                         @filter.principal.{u} α t)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t)))
⊢ @eq.{u+1} (filter.{u} α) (@filter.comap.{u v} α β f l)
    (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (t : set.{u} α),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
               (@set.image.{v u} (set.{v} β) (set.{u} α) (@set.preimage.{u v} α β f) S))
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
                 (@set.image.{v u} (set.{v} β) (set.{u} α) (@set.preimage.{u v} α β f) S)),
               @filter.principal.{u} α t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99      by { rw [infi_comm], congr&#x27; 1, ext t, rw [infi_comm] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='lattice.infi_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='lattice.infi_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 378, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 378, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {ι : Type u} {ι₂ : Type v} [_inst_1 : lattice.complete_lattice.{u} α] {f : ι → ι₂ → α}, @eq.{u+1} α (@lattice.infi.{u (max (u+1) 1)} α ι (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (λ (i : ι), @lattice.infi.{u v+1} α ι₂ (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (λ (j : ι₂), f i j))) (@lattice.infi.{u v+1} α ι₂ (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (λ (j : ι₂), @lattice.infi.{u (max (u+1) 1)} α ι (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (λ (i : ι), f i j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@interactive.with_desc nat (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {ι : Prop} {ι₂ : Type u} [_inst_1 : lattice.complete_lattice.{u} α] {f : ι → ι₂ → α}, @eq.{u+1} α (@lattice.infi.{u 0} α ι (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (λ (i : ι), @lattice.infi.{u (max (u+1) 1)} α ι₂ (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (λ (j : ι₂), f i j))) (@lattice.infi.{u (max (u+1) 1)} α ι₂ (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (λ (j : ι₂), @lattice.infi.{u 0} α ι (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (λ (i : ι), f i j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Same as the `congr` tactic, but takes an optional argument which gives
the depth of recursive applications. This is useful when `congr`
is too aggressive in breaking down the goal. For example, given
`⊢ f (g (x + y)) = f (g (y + x))`, `congr&#x27;` produces the goals `⊢ x = y`
and `⊢ y = x`, while `congr&#x27; 2` produces the intended `⊢ x + y = y + x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;n?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t)))
⊢ @eq.{u+1} (filter.{u} α) (@filter.comap.{u v} α β f l)
    (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (t : set.{u} α),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
               (@set.image.{v u} (set.{v} β) (set.{u} α) (@set.preimage.{u v} α β f) S))
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
                 (@set.image.{v u} (set.{v} β) (set.{u} α) (@set.preimage.{u v} α β f) S)),
               @filter.principal.{u} α t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t)))
⊢ @eq.{u+1} (filter.{u} α)
    (@lattice.infi.{u v+1} (filter.{u} α) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (s : set.{v} β),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S),
               @lattice.infi.{u (max (u+1) 1)} (filter.{u} α) (set.{u} α)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (t : set.{u} α),
                    @lattice.infi.{u 0} (filter.{u} α)
                      (@eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f s) t)
                      (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α)
                         (@filter.lattice.complete_lattice.{u} α))
                      (λ (H : @eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f s) t),
                         @filter.principal.{u} α t)))))
    (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α) (set.{u} α)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (t : set.{u} α),
          @lattice.infi.{u v+1} (filter.{u} α) (set.{v} β)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (s : set.{v} β),
               @lattice.infi.{u 0} (filter.{u} α)
                 (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S),
                    @lattice.infi.{u 0} (filter.{u} α)
                      (@eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f s) t)
                      (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α)
                         (@filter.lattice.complete_lattice.{u} α))
                      (λ (h₂ : @eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f s) t),
                         @filter.principal.{u} α t)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t)))
⊢ @eq.{u+1} (filter.{u} α)
    (@lattice.infi.{u v+1} (filter.{u} α) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (s : set.{v} β),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S),
               @lattice.infi.{u (max (u+1) 1)} (filter.{u} α) (set.{u} α)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (t : set.{u} α),
                    @lattice.infi.{u 0} (filter.{u} α)
                      (@eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f s) t)
                      (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α)
                         (@filter.lattice.complete_lattice.{u} α))
                      (λ (H : @eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f s) t),
                         @filter.principal.{u} α t)))))
    (@lattice.infi.{u v+1} (filter.{u} α) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (j : set.{v} β),
          @lattice.infi.{u (max (u+1) 1)} (filter.{u} α) (set.{u} α)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (i : set.{u} α),
               @lattice.infi.{u 0} (filter.{u} α)
                 (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) j S)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) j S),
                    @lattice.infi.{u 0} (filter.{u} α)
                      (@eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f j) i)
                      (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α)
                         (@filter.lattice.complete_lattice.{u} α))
                      (λ (h₂ : @eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f j) i),
                         @filter.principal.{u} α i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t)))
⊢ @eq.{(max (max (v+1) 1) (u+1))} (set.{v} β → filter.{u} α)
    (λ (s : set.{v} β),
       @lattice.infi.{u 0} (filter.{u} α)
         (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S)
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S),
            @lattice.infi.{u (max (u+1) 1)} (filter.{u} α) (set.{u} α)
              (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
              (λ (t : set.{u} α),
                 @lattice.infi.{u 0} (filter.{u} α)
                   (@eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f s) t)
                   (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                   (λ (H : @eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f s) t),
                      @filter.principal.{u} α t))))
    (λ (j : set.{v} β),
       @lattice.infi.{u (max (u+1) 1)} (filter.{u} α) (set.{u} α)
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ (i : set.{u} α),
            @lattice.infi.{u 0} (filter.{u} α)
              (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) j S)
              (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
              (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) j S),
                 @lattice.infi.{u 0} (filter.{u} α)
                   (@eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f j) i)
                   (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                   (λ (h₂ : @eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f j) i),
                      @filter.principal.{u} α i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t))),
t : set.{v} β,
s : set.{u} α
⊢ iff
    (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s
       (@lattice.infi.{u 0} (filter.{u} α)
          (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
          (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
          (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
             @lattice.infi.{u (max (u+1) 1)} (filter.{u} α) (set.{u} α)
               (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
               (λ (t_1 : set.{u} α),
                  @lattice.infi.{u 0} (filter.{u} α)
                    (@eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f t) t_1)
                    (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                    (λ (H : @eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f t) t_1),
                       @filter.principal.{u} α t_1)))))
    (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s
       (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α) (set.{u} α)
          (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
          (λ (i : set.{u} α),
             @lattice.infi.{u 0} (filter.{u} α)
               (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
               (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
               (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
                  @lattice.infi.{u 0} (filter.{u} α)
                    (@eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f t) i)
                    (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                    (λ (h₂ : @eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f t) i),
                       @filter.principal.{u} α i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t))),
t : set.{v} β,
s : set.{u} α
⊢ iff
    (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s
       (@lattice.infi.{u 0} (filter.{u} α)
          (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
          (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
          (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
             @lattice.infi.{u (max (u+1) 1)} (filter.{u} α) (set.{u} α)
               (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
               (λ (t_1 : set.{u} α),
                  @lattice.infi.{u 0} (filter.{u} α)
                    (@eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f t) t_1)
                    (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                    (λ (H : @eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f t) t_1),
                       @filter.principal.{u} α t_1)))))
    (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s
       (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α) (set.{u} α)
          (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
          (λ (i : set.{u} α),
             @lattice.infi.{u 0} (filter.{u} α)
               (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
               (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
               (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
                  @lattice.infi.{u 0} (filter.{u} α)
                    (@eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f t) i)
                    (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                    (λ (h₂ : @eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f t) i),
                       @filter.principal.{u} α i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100    ... = _ : by simp [-infi_infi_eq_right, infi_and]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='lattice.infi_and'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 491, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : lattice.complete_lattice.{?l_1} α] {p q : Prop} {s : and p q → α}, @eq.{?l_1+1} α (@lattice.infi.{?l_1 0} α (and p q) (@lattice.complete_lattice.to_has_Inf.{?l_1} α _inst_1) s) (@lattice.infi.{?l_1 0} α p (@lattice.complete_lattice.to_has_Inf.{?l_1} α _inst_1) (λ (h₁ : p), @lattice.infi.{?l_1 0} α q (@lattice.complete_lattice.to_has_Inf.{?l_1} α _inst_1) (λ (h₂ : q), s (@and.intro p q h₁ h₂))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t)))
⊢ @eq.{u+1} (filter.{u} α) (@filter.comap.{u v} α β f l)
    (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (t : set.{u} α),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
               (@set.image.{v u} (set.{v} β) (set.{u} α) (@set.preimage.{u v} α β f) S))
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
                 (@set.image.{v u} (set.{v} β) (set.{u} α) (@set.preimage.{u v} α β f) S)),
               @filter.principal.{u} α t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
l : filter.{v} β,
f : α → β,
S : set.{v} (set.{v} β),
h₁ : @set.countable.{v} (set.{v} β) S,
h₂ :
  @eq.{v+1} (filter.{v} β) l
    (@lattice.infi.{v v+1} (filter.{v} β) (set.{v} β)
       (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
       (λ (t : set.{v} β),
          @lattice.infi.{v 0} (filter.{v} β)
            (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S)
            (@lattice.complete_lattice.to_has_Inf.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β))
            (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t S),
               @filter.principal.{v} β t)))
⊢ @eq.{u+1} (filter.{u} α)
    (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α) (set.{u} α)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (t : set.{u} α),
          @lattice.infi.{u v+1} (filter.{u} α) (set.{v} β)
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ (s : set.{v} β),
               @lattice.infi.{u 0} (filter.{u} α)
                 (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S)
                 (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                 (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) s S),
                    @lattice.infi.{u 0} (filter.{u} α)
                      (@eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f s) t)
                      (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α)
                         (@filter.lattice.complete_lattice.{u} α))
                      (λ (h₂ : @eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β f s) t),
                         @filter.principal.{u} α t)))))
    (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (t : set.{u} α),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
               (@set.image.{v u} (set.{v} β) (set.{u} α) (@set.preimage.{u v} α β f) S))
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
                 (@set.image.{v u} (set.{v} β) (set.{u} α) (@set.preimage.{u v} α β f) S)),
               @filter.principal.{u} α t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  -- TODO : prove this for a encodable type</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  lemma has_countable_basis_at_top_finset_nat : has_countable_basis (@at_top (finset ℕ) _) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='blue'><a title='filter.has_countable_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 17, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='green'><a title='Π {α : Type u}, filter.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_4 → Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title='A filter has a countable basis iff it is generated by a countable collection
of subsets of α. (A filter is a generated by a collection of sets iff it is
the infimum of the principal filters.)

Note: we do not require the collection to be closed under finite intersections.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`finset α` is the type of finite sets of elements of `α`. It is implemented
 as a multiset (a list up to permutation) which has no duplicate elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @filter.has_countable_basis.{0} (finset.{0} nat)
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106    refine has_countable_basis_of_seq _ (λN, Ici (finset.range N)) (eq_infi_of_mem_sets_iff_exists_mem _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='filter.has_countable_basis_of_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.Ici'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='filter.eq_infi_of_mem_sets_iff_exists_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 847, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 416, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} (f : filter.{0} α) (x : nat → set.{0} α), @eq.{1} (filter.{0} α) f (@lattice.infi.{0 1} (filter.{0} α) nat (@lattice.complete_lattice.to_has_Inf.{0} (filter.{0} α) (@filter.lattice.complete_lattice.{0} α)) (λ (i : nat), @filter.principal.{0} α (x i))) → @filter.has_countable_basis.{0} α f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], α → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → finset.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α ι : Type} {f : ι → filter.{0} α} {l : filter.{0} α}, (∀ {s : set.{0} α}, iff (@has_mem.mem.{0 0} (set.{0} α) (filter.{0} α) (@filter.has_mem.{0} α) s l) (@Exists.{1} ι (λ (i : ι), @has_mem.mem.{0 0} (set.{0} α) (filter.{0} α) (@filter.has_mem.{0} α) s (f i)))) → @eq.{1} (filter.{0} α) l (@lattice.infi.{0 1} (filter.{0} α) ι (@lattice.complete_lattice.to_has_Inf.{0} (filter.{0} α) (@filter.lattice.complete_lattice.{0} α)) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Left-closed right-infinite interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`range n` is the set of natural numbers less than `n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @filter.has_countable_basis.{0} (finset.{0} nat)
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ ∀ {s : set.{0} (finset.{0} nat)},
    iff
      (@has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat))
         (@filter.has_mem.{0} (finset.{0} nat))
         s
         (@filter.at_top.{0} (finset.{0} nat)
            (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))))
      (@Exists.{1} nat
         (λ (i : nat),
            @has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat))
              (@filter.has_mem.{0} (finset.{0} nat))
              s
              (@filter.principal.{0} (finset.{0} nat)
                 (@set.Ici.{0} (finset.{0} nat)
                    (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))
                    (finset.range i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107    assume s,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ ∀ {s : set.{0} (finset.{0} nat)},
    iff
      (@has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat))
         (@filter.has_mem.{0} (finset.{0} nat))
         s
         (@filter.at_top.{0} (finset.{0} nat)
            (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))))
      (@Exists.{1} nat
         (λ (i : nat),
            @has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat))
              (@filter.has_mem.{0} (finset.{0} nat))
              s
              (@filter.principal.{0} (finset.{0} nat)
                 (@set.Ici.{0} (finset.{0} nat)
                    (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))
                    (finset.range i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} (finset.{0} nat)
⊢ iff
    (@has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat)) (@filter.has_mem.{0} (finset.{0} nat))
       s
       (@filter.at_top.{0} (finset.{0} nat)
          (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))))
    (@Exists.{1} nat
       (λ (i : nat),
          @has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat))
            (@filter.has_mem.{0} (finset.{0} nat))
            s
            (@filter.principal.{0} (finset.{0} nat)
               (@set.Ici.{0} (finset.{0} nat)
                  (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))
                  (finset.range i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108    rw mem_at_top_sets,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='filter.mem_at_top_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1662, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : nonempty.{1} α] [_inst_2 : lattice.semilattice_sup.{0} α] {s : set.{0} α}, iff (@has_mem.mem.{0 0} (set.{0} α) (filter.{0} α) (@filter.has_mem.{0} α) s (@filter.at_top.{0} α (@partial_order.to_preorder.{0} α (@lattice.semilattice_sup.to_partial_order.{0} α _inst_2)))) (@Exists.{1} α (λ (a : α), ∀ (b : α), @ge.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.semilattice_sup.to_partial_order.{0} α _inst_2))) b a → @has_mem.mem.{0 0} α (set.{0} α) (@set.has_mem.{0} α) b s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} (finset.{0} nat)
⊢ iff
    (@has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat)) (@filter.has_mem.{0} (finset.{0} nat))
       s
       (@filter.at_top.{0} (finset.{0} nat)
          (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))))
    (@Exists.{1} nat
       (λ (i : nat),
          @has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat))
            (@filter.has_mem.{0} (finset.{0} nat))
            s
            (@filter.principal.{0} (finset.{0} nat)
               (@set.Ici.{0} (finset.{0} nat)
                  (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))
                  (finset.range i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} (finset.{0} nat)
⊢ iff
    (@Exists.{1} (finset.{0} nat)
       (λ (a : finset.{0} nat),
          ∀ (b : finset.{0} nat),
            @ge.{0} (finset.{0} nat)
              (@preorder.to_has_le.{0} (finset.{0} nat)
                 (@partial_order.to_preorder.{0} (finset.{0} nat)
                    (@lattice.semilattice_sup.to_partial_order.{0} (finset.{0} nat)
                       (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} (finset.{0} nat)
                          (@finset.lattice.semilattice_sup_bot.{0} nat (λ (a b : nat), nat.decidable_eq a b))))))
              b
              a →
            @has_mem.mem.{0 0} (finset.{0} nat) (set.{0} (finset.{0} nat)) (@set.has_mem.{0} (finset.{0} nat)) b s))
    (@Exists.{1} nat
       (λ (i : nat),
          @has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat))
            (@filter.has_mem.{0} (finset.{0} nat))
            s
            (@filter.principal.{0} (finset.{0} nat)
               (@set.Ici.{0} (finset.{0} nat)
                  (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))
                  (finset.range i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109    refine ⟨_, λ ⟨N, hN⟩, ⟨finset.range N, hN⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hN'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='finset.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 847, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat)) (@filter.has_mem.{0} (finset.{0} nat)) s (@filter.principal.{0} (finset.{0} nat) (@set.Ici.{0} (finset.{0} nat) (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)) (finset.range N)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → finset.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`range n` is the set of natural numbers less than `n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} (finset.{0} nat)
⊢ iff
    (@Exists.{1} (finset.{0} nat)
       (λ (a : finset.{0} nat),
          ∀ (b : finset.{0} nat),
            @ge.{0} (finset.{0} nat)
              (@preorder.to_has_le.{0} (finset.{0} nat)
                 (@partial_order.to_preorder.{0} (finset.{0} nat)
                    (@lattice.semilattice_sup.to_partial_order.{0} (finset.{0} nat)
                       (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} (finset.{0} nat)
                          (@finset.lattice.semilattice_sup_bot.{0} nat (λ (a b : nat), nat.decidable_eq a b))))))
              b
              a →
            @has_mem.mem.{0 0} (finset.{0} nat) (set.{0} (finset.{0} nat)) (@set.has_mem.{0} (finset.{0} nat)) b s))
    (@Exists.{1} nat
       (λ (i : nat),
          @has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat))
            (@filter.has_mem.{0} (finset.{0} nat))
            s
            (@filter.principal.{0} (finset.{0} nat)
               (@set.Ici.{0} (finset.{0} nat)
                  (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))
                  (finset.range i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} (finset.{0} nat)
⊢ @Exists.{1} (finset.{0} nat)
    (λ (a : finset.{0} nat),
       ∀ (b : finset.{0} nat),
         @ge.{0} (finset.{0} nat)
           (@preorder.to_has_le.{0} (finset.{0} nat)
              (@partial_order.to_preorder.{0} (finset.{0} nat)
                 (@lattice.semilattice_sup.to_partial_order.{0} (finset.{0} nat)
                    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} (finset.{0} nat)
                       (@finset.lattice.semilattice_sup_bot.{0} nat (λ (a b : nat), nat.decidable_eq a b))))))
           b
           a →
         @has_mem.mem.{0 0} (finset.{0} nat) (set.{0} (finset.{0} nat)) (@set.has_mem.{0} (finset.{0} nat)) b s) →
  @Exists.{1} nat
    (λ (i : nat),
       @has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat))
         (@filter.has_mem.{0} (finset.{0} nat))
         s
         (@filter.principal.{0} (finset.{0} nat)
            (@set.Ici.{0} (finset.{0} nat)
               (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))
               (finset.range i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110    rintros ⟨t, ht⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} (finset.{0} nat)
⊢ @Exists.{1} (finset.{0} nat)
    (λ (a : finset.{0} nat),
       ∀ (b : finset.{0} nat),
         @ge.{0} (finset.{0} nat)
           (@preorder.to_has_le.{0} (finset.{0} nat)
              (@partial_order.to_preorder.{0} (finset.{0} nat)
                 (@lattice.semilattice_sup.to_partial_order.{0} (finset.{0} nat)
                    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} (finset.{0} nat)
                       (@finset.lattice.semilattice_sup_bot.{0} nat (λ (a b : nat), nat.decidable_eq a b))))))
           b
           a →
         @has_mem.mem.{0 0} (finset.{0} nat) (set.{0} (finset.{0} nat)) (@set.has_mem.{0} (finset.{0} nat)) b s) →
  @Exists.{1} nat
    (λ (i : nat),
       @has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat))
         (@filter.has_mem.{0} (finset.{0} nat))
         s
         (@filter.principal.{0} (finset.{0} nat)
            (@set.Ici.{0} (finset.{0} nat)
               (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))
               (finset.range i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} (finset.{0} nat),
t : finset.{0} nat,
ht :
  ∀ (b : finset.{0} nat),
    @ge.{0} (finset.{0} nat)
      (@preorder.to_has_le.{0} (finset.{0} nat)
         (@partial_order.to_preorder.{0} (finset.{0} nat)
            (@lattice.semilattice_sup.to_partial_order.{0} (finset.{0} nat)
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} (finset.{0} nat)
                  (@finset.lattice.semilattice_sup_bot.{0} nat (λ (a b : nat), nat.decidable_eq a b))))))
      b
      t →
    @has_mem.mem.{0 0} (finset.{0} nat) (set.{0} (finset.{0} nat)) (@set.has_mem.{0} (finset.{0} nat)) b s
⊢ @Exists.{1} nat
    (λ (i : nat),
       @has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat))
         (@filter.has_mem.{0} (finset.{0} nat))
         s
         (@filter.principal.{0} (finset.{0} nat)
            (@set.Ici.{0} (finset.{0} nat)
               (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))
               (finset.range i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111    rcases mem_at_top_sets.1 (tendsto_finset_range (mem_at_top t)) with ⟨N, hN⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='filter.mem_at_top_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='filter.tendsto_finset_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.mem_at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1662, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1836, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1653, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : nonempty.{1} α] [_inst_2 : lattice.semilattice_sup.{0} α] {s : set.{0} α}, iff (@has_mem.mem.{0 0} (set.{0} α) (filter.{0} α) (@filter.has_mem.{0} α) s (@filter.at_top.{0} α (@partial_order.to_preorder.{0} α (@lattice.semilattice_sup.to_partial_order.{0} α _inst_2)))) (@Exists.{1} α (λ (a : α), ∀ (b : α), @ge.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.semilattice_sup.to_partial_order.{0} α _inst_2))) b a → @has_mem.mem.{0 0} α (set.{0} α) (@set.has_mem.{0} α) b s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@filter.tendsto.{0 0} nat (finset.{0} nat) finset.range (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) (@filter.at_top.{0} (finset.{0} nat) (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] (a : α), @has_mem.mem.{0 0} (set.{0} α) (filter.{0} α) (@filter.has_mem.{0} α) (@set_of.{0} α (λ (b : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b)) (@filter.at_top.{0} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='finset.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} (finset.{0} nat),
t : finset.{0} nat,
ht :
  ∀ (b : finset.{0} nat),
    @ge.{0} (finset.{0} nat)
      (@preorder.to_has_le.{0} (finset.{0} nat)
         (@partial_order.to_preorder.{0} (finset.{0} nat)
            (@lattice.semilattice_sup.to_partial_order.{0} (finset.{0} nat)
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} (finset.{0} nat)
                  (@finset.lattice.semilattice_sup_bot.{0} nat (λ (a b : nat), nat.decidable_eq a b))))))
      b
      t →
    @has_mem.mem.{0 0} (finset.{0} nat) (set.{0} (finset.{0} nat)) (@set.has_mem.{0} (finset.{0} nat)) b s
⊢ @Exists.{1} nat
    (λ (i : nat),
       @has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat))
         (@filter.has_mem.{0} (finset.{0} nat))
         s
         (@filter.principal.{0} (finset.{0} nat)
            (@set.Ici.{0} (finset.{0} nat)
               (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))
               (finset.range i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} (finset.{0} nat),
t : finset.{0} nat,
ht :
  ∀ (b : finset.{0} nat),
    @ge.{0} (finset.{0} nat)
      (@preorder.to_has_le.{0} (finset.{0} nat)
         (@partial_order.to_preorder.{0} (finset.{0} nat)
            (@lattice.semilattice_sup.to_partial_order.{0} (finset.{0} nat)
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} (finset.{0} nat)
                  (@finset.lattice.semilattice_sup_bot.{0} nat (λ (a b : nat), nat.decidable_eq a b))))))
      b
      t →
    @has_mem.mem.{0 0} (finset.{0} nat) (set.{0} (finset.{0} nat)) (@set.has_mem.{0} (finset.{0} nat)) b s,
N : nat,
hN :
  ∀ (b : nat),
    @ge.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      b
      N →
    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) b
      (@set.preimage.{0 0} nat (finset.{0} nat) finset.range
         (@set_of.{0} (finset.{0} nat)
            (λ (b : finset.{0} nat),
               @has_le.le.{0} (finset.{0} nat)
                 (@preorder.to_has_le.{0} (finset.{0} nat)
                    (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
                 t
                 b)))
⊢ @Exists.{1} nat
    (λ (i : nat),
       @has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat))
         (@filter.has_mem.{0} (finset.{0} nat))
         s
         (@filter.principal.{0} (finset.{0} nat)
            (@set.Ici.{0} (finset.{0} nat)
               (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))
               (finset.range i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112    simp only [preimage, mem_set_of_eq] at hN,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_set_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2}, (α → β) → set.{?l_2} β → set.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {a : α} {p : α → Prop}, @eq.{1} Prop (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@set_of.{?l_1} α (λ (a : α), p a))) (p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} (finset.{0} nat),
t : finset.{0} nat,
ht :
  ∀ (b : finset.{0} nat),
    @ge.{0} (finset.{0} nat)
      (@preorder.to_has_le.{0} (finset.{0} nat)
         (@partial_order.to_preorder.{0} (finset.{0} nat)
            (@lattice.semilattice_sup.to_partial_order.{0} (finset.{0} nat)
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} (finset.{0} nat)
                  (@finset.lattice.semilattice_sup_bot.{0} nat (λ (a b : nat), nat.decidable_eq a b))))))
      b
      t →
    @has_mem.mem.{0 0} (finset.{0} nat) (set.{0} (finset.{0} nat)) (@set.has_mem.{0} (finset.{0} nat)) b s,
N : nat,
hN :
  ∀ (b : nat),
    @ge.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      b
      N →
    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) b
      (@set.preimage.{0 0} nat (finset.{0} nat) finset.range
         (@set_of.{0} (finset.{0} nat)
            (λ (b : finset.{0} nat),
               @has_le.le.{0} (finset.{0} nat)
                 (@preorder.to_has_le.{0} (finset.{0} nat)
                    (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
                 t
                 b)))
⊢ @Exists.{1} nat
    (λ (i : nat),
       @has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat))
         (@filter.has_mem.{0} (finset.{0} nat))
         s
         (@filter.principal.{0} (finset.{0} nat)
            (@set.Ici.{0} (finset.{0} nat)
               (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))
               (finset.range i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} (finset.{0} nat),
t : finset.{0} nat,
ht :
  ∀ (b : finset.{0} nat),
    @ge.{0} (finset.{0} nat)
      (@preorder.to_has_le.{0} (finset.{0} nat)
         (@partial_order.to_preorder.{0} (finset.{0} nat)
            (@lattice.semilattice_sup.to_partial_order.{0} (finset.{0} nat)
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} (finset.{0} nat)
                  (@finset.lattice.semilattice_sup_bot.{0} nat (λ (a b : nat), nat.decidable_eq a b))))))
      b
      t →
    @has_mem.mem.{0 0} (finset.{0} nat) (set.{0} (finset.{0} nat)) (@set.has_mem.{0} (finset.{0} nat)) b s,
N : nat,
hN :
  ∀ (b : nat),
    @ge.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      b
      N →
    @has_le.le.{0} (finset.{0} nat)
      (@preorder.to_has_le.{0} (finset.{0} nat)
         (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
      t
      (finset.range b)
⊢ @Exists.{1} nat
    (λ (i : nat),
       @has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat))
         (@filter.has_mem.{0} (finset.{0} nat))
         s
         (@filter.principal.{0} (finset.{0} nat)
            (@set.Ici.{0} (finset.{0} nat)
               (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))
               (finset.range i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113    exact ⟨N, mem_principal_sets.2 $ λ t&#x27; ht&#x27;, ht t&#x27; $ le_trans (hN _ $ le_refl N) ht&#x27;⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='filter.mem_principal_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hN'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 194, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {s t : set.{0} α}, iff (@has_mem.mem.{0 0} (set.{0} α) (filter.{0} α) (@filter.has_mem.{0} α) s (@filter.principal.{0} α t)) (@has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) t s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (b : finset.{0} nat), @ge.{0} (finset.{0} nat) (@preorder.to_has_le.{0} (finset.{0} nat) (@partial_order.to_preorder.{0} (finset.{0} nat) (@lattice.semilattice_sup.to_partial_order.{0} (finset.{0} nat) (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} (finset.{0} nat) (@finset.lattice.semilattice_sup_bot.{0} nat (λ (a b : nat), nat.decidable_eq a b)))))) b t → @has_mem.mem.{0 0} (finset.{0} nat) (set.{0} (finset.{0} nat)) (@set.has_mem.{0} (finset.{0} nat)) b s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (b : nat), @ge.{0} nat (@preorder.to_has_le.{0} nat (@partial_order.to_preorder.{0} nat (@lattice.semilattice_sup.to_partial_order.{0} nat (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))) b N → @has_le.le.{0} (finset.{0} nat) (@preorder.to_has_le.{0} (finset.{0} nat) (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))) t (finset.range b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] (a : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} (finset.{0} nat),
t : finset.{0} nat,
ht :
  ∀ (b : finset.{0} nat),
    @ge.{0} (finset.{0} nat)
      (@preorder.to_has_le.{0} (finset.{0} nat)
         (@partial_order.to_preorder.{0} (finset.{0} nat)
            (@lattice.semilattice_sup.to_partial_order.{0} (finset.{0} nat)
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} (finset.{0} nat)
                  (@finset.lattice.semilattice_sup_bot.{0} nat (λ (a b : nat), nat.decidable_eq a b))))))
      b
      t →
    @has_mem.mem.{0 0} (finset.{0} nat) (set.{0} (finset.{0} nat)) (@set.has_mem.{0} (finset.{0} nat)) b s,
N : nat,
hN :
  ∀ (b : nat),
    @ge.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      b
      N →
    @has_le.le.{0} (finset.{0} nat)
      (@preorder.to_has_le.{0} (finset.{0} nat)
         (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
      t
      (finset.range b)
⊢ @Exists.{1} nat
    (λ (i : nat),
       @has_mem.mem.{0 0} (set.{0} (finset.{0} nat)) (filter.{0} (finset.{0} nat))
         (@filter.has_mem.{0} (finset.{0} nat))
         s
         (@filter.principal.{0} (finset.{0} nat)
            (@set.Ici.{0} (finset.{0} nat)
               (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat))
               (finset.range i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  lemma has_countable_basis.tendsto_iff_seq_tendsto {f : α → β} {k : filter α} {l : filter β}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117    (hcb : k.has_countable_basis) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.has_countable_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, filter.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A filter has a countable basis iff it is generated by a countable collection
of subsets of α. (A filter is a generated by a collection of sets iff it is
the infimum of the principal filters.)

Note: we do not require the collection to be closed under finite intersections.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118    tendsto f k l ↔ (∀ x : ℕ → α, tendsto x at_top k → tendsto (f ∘ x) at_top l) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {β : Type u} {φ : Type v}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  suffices (∀ x : ℕ → α, tendsto x at_top k → tendsto (f ∘ x) at_top l) → tendsto f k l,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='∀ (x : nat → α), @filter.tendsto.{0 u} nat α x (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) k → @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x) (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} {β : Type u}, (α → β) → filter.{0} α → filter.{u} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], filter.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type} {β : Type v}, (α → β) → filter.{0} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {β : Type u} {φ : Type v}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], filter.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120    from ⟨by intros; apply tendsto.comp; assumption, by assumption⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='filter.tendsto.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1391, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u} {γ : Type v} {f : α → β} {g : β → γ} {x : filter.{0} α} {y : filter.{u} β} {z : filter.{v} γ}, @filter.tendsto.{u v} β γ g y z → @filter.tendsto.{0 u} α β f x y → @filter.tendsto.{0 v} α γ (@function.comp.{1 u+1 v+1} α β γ g f) x z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
hcb : @filter.has_countable_basis.{u} α k,
this :
  (∀ (x : nat → α),
     @filter.tendsto.{0 u} nat α x
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       k →
     @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l) →
  @filter.tendsto.{u v} α β f k l
⊢ @filter.tendsto.{u v} α β f k l →
  ∀ (x : nat → α),
    @filter.tendsto.{0 u} nat α x
      (@filter.at_top.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@ordered_comm_monoid.to_partial_order.{0} nat
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
      k →
    @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
      (@filter.at_top.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@ordered_comm_monoid.to_partial_order.{0} nat
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
      l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
hcb : @filter.has_countable_basis.{u} α k,
this :
  (∀ (x : nat → α),
     @filter.tendsto.{0 u} nat α x
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       k →
     @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l) →
  @filter.tendsto.{u v} α β f k l
⊢ (∀ (x : nat → α),
     @filter.tendsto.{0 u} nat α x
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       k →
     @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l) →
  @filter.tendsto.{u v} α β f k l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
hcb : @filter.has_countable_basis.{u} α k
⊢ (∀ (x : nat → α),
     @filter.tendsto.{0 u} nat α x
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       k →
     @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l) →
  @filter.tendsto.{u v} α β f k l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122    rw filter.has_countable_basis_iff_mono_seq at hcb,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='filter.has_countable_basis_iff_mono_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 71, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (f : filter.{u} α), iff (@filter.has_countable_basis.{u} α f) (@Exists.{(max (u+1) 1)} (nat → set.{u} α) (λ (x : nat → set.{u} α), and (∀ (i j : nat), @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i)) (@eq.{u+1} (filter.{u} α) f (@lattice.infi.{u 1} (filter.{u} α) nat (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (i : nat), @filter.principal.{u} α (x i))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Different characterization of countable basis. A filter has a countable basis
iff it is generated by a monotonically decreasing sequence of sets.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
hcb : @filter.has_countable_basis.{u} α k
⊢ (∀ (x : nat → α),
     @filter.tendsto.{0 u} nat α x
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       k →
     @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l) →
  @filter.tendsto.{u v} α β f k l'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
hcb :
  @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       and
         (∀ (i j : nat),
            @has_le.le.{0} nat nat.has_le i j →
            @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i))
         (@eq.{u+1} (filter.{u} α) k
            (@lattice.infi.{u 1} (filter.{u} α) nat
               (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
               (λ (i : nat), @filter.principal.{u} α (x i)))))
⊢ (∀ (x : nat → α),
     @filter.tendsto.{0 u} nat α x
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       k →
     @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l) →
  @filter.tendsto.{u v} α β f k l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123    rcases hcb with ⟨g, gmon, gbasis⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hcb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max (u+1) 1)} (nat → set.{u} α) (λ (x : nat → set.{u} α), and (∀ (i j : nat), @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i)) (@eq.{u+1} (filter.{u} α) k (@lattice.infi.{u 1} (filter.{u} α) nat (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (i : nat), @filter.principal.{u} α (x i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
hcb :
  @Exists.{(max (u+1) 1)} (nat → set.{u} α)
    (λ (x : nat → set.{u} α),
       and
         (∀ (i j : nat),
            @has_le.le.{0} nat nat.has_le i j →
            @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (x j) (x i))
         (@eq.{u+1} (filter.{u} α) k
            (@lattice.infi.{u 1} (filter.{u} α) nat
               (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
               (λ (i : nat), @filter.principal.{u} α (x i)))))
⊢ (∀ (x : nat → α),
     @filter.tendsto.{0 u} nat α x
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       k →
     @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l) →
  @filter.tendsto.{u v} α β f k l'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i)))
⊢ (∀ (x : nat → α),
     @filter.tendsto.{0 u} nat α x
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       k →
     @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l) →
  @filter.tendsto.{u v} α β f k l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124    have gbasis : ∀ A, A ∈ k ↔ ∃ i, g i ⊆ A,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i)))
⊢ (∀ (x : nat → α),
     @filter.tendsto.{0 u} nat α x
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       k →
     @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l) →
  @filter.tendsto.{u v} α β f k l'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i)))
⊢ ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A))

α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A))
⊢ (∀ (x : nat → α),
     @filter.tendsto.{0 u} nat α x
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       k →
     @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l) →
  @filter.tendsto.{u v} α β f k l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125    { intro A,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i)))
⊢ ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A))

α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A))
⊢ (∀ (x : nat → α),
     @filter.tendsto.{0 u} nat α x
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       k →
     @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l) →
  @filter.tendsto.{u v} α β f k l'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i)))
⊢ ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
A : set.{u} α
⊢ iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
    (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126      subst gbasis,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='gbasis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (filter.{u} α) k (@lattice.infi.{u 1} (filter.{u} α) nat (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (i : nat), @filter.principal.{u} α (g i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
A : set.{u} α
⊢ iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
    (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
A : set.{u} α
⊢ iff
    (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A
       (@lattice.infi.{u 1} (filter.{u} α) nat
          (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
          (λ (i : nat), @filter.principal.{u} α (g i))))
    (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127      rw mem_infi,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter.mem_infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 448, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {ι : Type} {f : ι → filter.{u} α}, @directed.{u 1} (filter.{u} α) (@ge.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))) ι f → nonempty.{1} ι → ∀ (s : set.{u} α), iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@lattice.infi.{u 1} (filter.{u} α) ι (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) f)) (@Exists.{1} ι (λ (i : ι), @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (f i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
A : set.{u} α
⊢ iff
    (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A
       (@lattice.infi.{u 1} (filter.{u} α) nat
          (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
          (λ (i : nat), @filter.principal.{u} α (g i))))
    (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
f : α → β,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
A : set.{u} α
⊢ iff
    (@Exists.{1} nat
       (λ (i : nat),
          @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A (@filter.principal.{u} α (g i))))
    (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A))

α : Type u,
β : Type v,
f : α → β,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
A : set.{u} α
⊢ @directed.{u 1} (filter.{u} α)
    (@ge.{u} (filter.{u} α)
       (@preorder.to_has_le.{u} (filter.{u} α)
          (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))))
    nat
    (λ (i : nat), @filter.principal.{u} α (g i))

α : Type u,
β : Type v,
f : α → β,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
A : set.{u} α
⊢ nonempty.{1} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128      { simp only [set.mem_Union, iff_self, filter.mem_principal_sets] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='set.mem_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.mem_principal_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 504, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 194, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type ?l_1} {ι : Sort ?l_2} {x : β} {s : ι → set.{?l_1} β}, iff (@has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x (@set.Union.{?l_1 ?l_2} β ι s)) (@Exists.{?l_2} ι (λ (i : ι), @has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x (s i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : Prop), iff (iff a a) true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {s t : set.{?l_1} α}, iff (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} α) (filter.{?l_1} α) (@filter.has_mem.{?l_1} α) s (@filter.principal.{?l_1} α t)) (@has_subset.subset.{?l_1} (set.{?l_1} α) (@set.has_subset.{?l_1} α) t s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
f : α → β,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
A : set.{u} α
⊢ iff
    (@Exists.{1} nat
       (λ (i : nat),
          @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A (@filter.principal.{u} α (g i))))
    (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A))

α : Type u,
β : Type v,
f : α → β,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
A : set.{u} α
⊢ @directed.{u 1} (filter.{u} α)
    (@ge.{u} (filter.{u} α)
       (@preorder.to_has_le.{u} (filter.{u} α)
          (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))))
    nat
    (λ (i : nat), @filter.principal.{u} α (g i))

α : Type u,
β : Type v,
f : α → β,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
A : set.{u} α
⊢ nonempty.{1} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
A : set.{u} α
⊢ iff
    (@Exists.{1} nat
       (λ (i : nat),
          @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A (@filter.principal.{u} α (g i))))
    (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
f : α → β,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
A : set.{u} α
⊢ @directed.{u 1} (filter.{u} α)
    (@ge.{u} (filter.{u} α)
       (@preorder.to_has_le.{u} (filter.{u} α)
          (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))))
    nat
    (λ (i : nat), @filter.principal.{u} α (g i))

α : Type u,
β : Type v,
f : α → β,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
A : set.{u} α
⊢ nonempty.{1} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129      { exact directed_of_mono _ (λ i j h, principal_mono.mpr $ gmon _ _ h) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='lattice.directed_of_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='filter.principal_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gmon'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 100, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 378, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : lattice.semilattice_sup.{0} α] {β : Type u} (f : α → β) {r : β → β → Prop}, (∀ ⦃i j : α⦄, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.semilattice_sup.to_partial_order.{0} α _inst_1))) i j → r (f i) (f j)) → @directed.{u 1} β r α f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α}, iff (@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) (@filter.principal.{u} α s) (@filter.principal.{u} α t)) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i j : nat), @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A monotone function on a sup-semilattice is directed.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
f : α → β,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
A : set.{u} α
⊢ @directed.{u 1} (filter.{u} α)
    (@ge.{u} (filter.{u} α)
       (@preorder.to_has_le.{u} (filter.{u} α)
          (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))))
    nat
    (λ (i : nat), @filter.principal.{u} α (g i))

α : Type u,
β : Type v,
f : α → β,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
A : set.{u} α
⊢ nonempty.{1} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
A : set.{u} α
⊢ @directed.{u 1} (filter.{u} α)
    (@ge.{u} (filter.{u} α)
       (@preorder.to_has_le.{u} (filter.{u} α)
          (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))))
    nat
    (λ (i : nat), @filter.principal.{u} α (g i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
A : set.{u} α
⊢ nonempty.{1} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130      { apply_instance } },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
A : set.{u} α
⊢ nonempty.{1} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A))
⊢ (∀ (x : nat → α),
     @filter.tendsto.{0 u} nat α x
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       k →
     @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l) →
  @filter.tendsto.{u v} α β f k l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131    classical, contrapose,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/push_neg.lean&#x27;, &#x27;line&#x27;: 158, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse (option.{0} (prod.{0 0} name (option.{0} name))) (λ (a : option.{0} (prod.{0 0} name (option.{0} name))), @option.has_reflect (prod.{0 0} name (option.{0} name)) (λ (a : prod.{0 0} name (option.{0} name)), @prod.has_reflect name (λ (a : name), name.reflect a) (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) `(name) `(option.{0} name) a) `(prod.{0 0} name (option.{0} name)) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (prod.{0 0} name (option.{0} name)) name_with_opt) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Make every propositions in the context decidable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transforms the goal into its contrapositive.
`contrapose`     turns a goal `P → Q` into `¬ Q → ¬ P`
`contrapose!`    turns a goal `P → Q` into `¬ Q → ¬ P` and pushes negations inside `P` and `Q`
                 using `push_neg`
`contrapose h`   first reverts the local assumption `h`, and then uses `contrapose` and `intro h`
`contrapose! h`  first reverts the local assumption `h`, and then uses `contrapose!` and `intro h`
`contrapose h with new_h` uses the name `new_h` for the introduced hypothesis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='classical'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='contrapose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print @ [has_bind.bind (@monad.to_has_bind.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))] unit name (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (λ (_x : unit), lean.parser.ident)&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A))
⊢ (∀ (x : nat → α),
     @filter.tendsto.{0 u} nat α x
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       k →
     @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l) →
  @filter.tendsto.{u v} α β f k l'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a
⊢ (∀ (x : nat → α),
     @filter.tendsto.{0 u} nat α x
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       k →
     @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l) →
  @filter.tendsto.{u v} α β f k l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a
⊢ not (@filter.tendsto.{u v} α β f k l) →
  not
    (∀ (x : nat → α),
       @filter.tendsto.{0 u} nat α x
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         k →
       @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132    simp only [not_forall, not_imp, not_exists, subset_def, @tendsto_def _ _ f, gbasis],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='not_forall'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not_imp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not_exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.tendsto_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='gbasis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 453, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 304, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 447, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {p : α → Prop} [_inst_1 : decidable (@Exists.{?l_1} α (λ (x : α), not (p x)))] [_inst_2 : Π (x : α), decidable (p x)], iff (not (∀ (x : α), p x)) (@Exists.{?l_1} α (λ (x : α), not (p x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop} [_inst_1 : decidable a], iff (not (a → b)) (and a (not b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {p : α → Prop}, iff (not (@Exists.{?l_1} α (λ (x : α), p x))) (∀ (x : α), not (p x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {s t : set.{?l_1} α}, @eq.{1} Prop (@has_subset.subset.{?l_1} (set.{?l_1} α) (@set.has_subset.{?l_1} α) s t) (∀ (x : α), @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x s → @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {f : α → β} {l₁ : filter.{u} α} {l₂ : filter.{v} β}, iff (@filter.tendsto.{u v} α β f l₁ l₂) (∀ (s : set.{v} β), @has_mem.mem.{v v} (set.{v} β) (filter.{v} β) (@filter.has_mem.{v} β) s l₂ → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@set.preimage.{u v} α β f s) l₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (A : set.{u} α), iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k) (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a
⊢ not (@filter.tendsto.{u v} α β f k l) →
  not
    (∀ (x : nat → α),
       @filter.tendsto.{0 u} nat α x
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         k →
       @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a
⊢ @Exists.{(max (v+1) 1)} (set.{v} β)
    (λ (x : set.{v} β),
       and
         (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) x
            (@filter.sets.{v} β l))
         (∀ (x_1 : nat),
            @Exists.{u+1} α
              (λ (x_2 : α),
                 and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_2 (g x_1))
                   (not
                      (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_2
                         (@set.preimage.{u v} α β f x)))))) →
  @Exists.{(max 1 (u+1))} (nat → α)
    (λ (x : nat → α),
       and
         (@filter.tendsto.{0 u} nat α x
            (@filter.at_top.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
            k)
         (not
            (@filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
               (@filter.at_top.{0} nat
                  (@partial_order.to_preorder.{0} nat
                     (@ordered_comm_monoid.to_partial_order.{0} nat
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                           (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
               l)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133    rintro ⟨B, hBl, hfBk⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a
⊢ @Exists.{(max (v+1) 1)} (set.{v} β)
    (λ (x : set.{v} β),
       and
         (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) x
            (@filter.sets.{v} β l))
         (∀ (x_1 : nat),
            @Exists.{u+1} α
              (λ (x_2 : α),
                 and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_2 (g x_1))
                   (not
                      (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_2
                         (@set.preimage.{u v} α β f x)))))) →
  @Exists.{(max 1 (u+1))} (nat → α)
    (λ (x : nat → α),
       and
         (@filter.tendsto.{0 u} nat α x
            (@filter.at_top.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
            k)
         (not
            (@filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
               (@filter.at_top.{0} nat
                  (@partial_order.to_preorder.{0} nat
                     (@ordered_comm_monoid.to_partial_order.{0} nat
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                           (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
               l)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
hfBk :
  ∀ (x : nat),
    @Exists.{u+1} α
      (λ (x_1 : α),
         and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1 (g x))
           (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1 (@set.preimage.{u v} α β f B))))
⊢ @Exists.{(max 1 (u+1))} (nat → α)
    (λ (x : nat → α),
       and
         (@filter.tendsto.{0 u} nat α x
            (@filter.at_top.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
            k)
         (not
            (@filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
               (@filter.at_top.{0} nat
                  (@partial_order.to_preorder.{0} nat
                     (@ordered_comm_monoid.to_partial_order.{0} nat
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                           (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
               l)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134    choose x h using hfBk,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='hfBk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : nat), @Exists.{u+1} α (λ (x_1 : α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1 (g x)) (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1 (@set.preimage.{u v} α β f B))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
hfBk :
  ∀ (x : nat),
    @Exists.{u+1} α
      (λ (x_1 : α),
         and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1 (g x))
           (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1 (@set.preimage.{u v} α β f B))))
⊢ @Exists.{(max 1 (u+1))} (nat → α)
    (λ (x : nat → α),
       and
         (@filter.tendsto.{0 u} nat α x
            (@filter.at_top.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
            k)
         (not
            (@filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
               (@filter.at_top.{0} nat
                  (@partial_order.to_preorder.{0} nat
                     (@ordered_comm_monoid.to_partial_order.{0} nat
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                           (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
               l)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))
⊢ @Exists.{(max 1 (u+1))} (nat → α)
    (λ (x : nat → α),
       and
         (@filter.tendsto.{0 u} nat α x
            (@filter.at_top.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
            k)
         (not
            (@filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
               (@filter.at_top.{0} nat
                  (@partial_order.to_preorder.{0} nat
                     (@ordered_comm_monoid.to_partial_order.{0} nat
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                           (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
               l)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135    use x, split,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))
⊢ @Exists.{(max 1 (u+1))} (nat → α)
    (λ (x : nat → α),
       and
         (@filter.tendsto.{0 u} nat α x
            (@filter.at_top.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@ordered_comm_monoid.to_partial_order.{0} nat
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                        (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
            k)
         (not
            (@filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
               (@filter.at_top.{0} nat
                  (@partial_order.to_preorder.{0} nat
                     (@ordered_comm_monoid.to_partial_order.{0} nat
                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                           (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
               l)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))
⊢ and
    (@filter.tendsto.{0 u} nat α x
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       k)
    (not
       (@filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
          (@filter.at_top.{0} nat
             (@partial_order.to_preorder.{0} nat
                (@ordered_comm_monoid.to_partial_order.{0} nat
                   (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                      (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
          l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))
⊢ @filter.tendsto.{0 u} nat α x
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    k

α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))
⊢ not
    (@filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136    { simp only [tendsto_at_top&#x27;, gbasis],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='filter.tendsto_at_top&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='gbasis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1797, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : nonempty.{?l_1+1} α] [_inst_2 : lattice.semilattice_sup.{?l_1} α] (f : α → β) (l : filter.{?l_2} β), iff (@filter.tendsto.{?l_1 ?l_2} α β f (@filter.at_top.{?l_1} α (@partial_order.to_preorder.{?l_1} α (@lattice.semilattice_sup.to_partial_order.{?l_1} α _inst_2))) l) (∀ (s : set.{?l_2} β), @has_mem.mem.{?l_2 ?l_2} (set.{?l_2} β) (filter.{?l_2} β) (@filter.has_mem.{?l_2} β) s l → @Exists.{?l_1+1} α (λ (a : α), ∀ (b : α), @ge.{?l_1} α (@preorder.to_has_le.{?l_1} α (@partial_order.to_preorder.{?l_1} α (@lattice.semilattice_sup.to_partial_order.{?l_1} α _inst_2))) b a → @has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) (f b) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (A : set.{u} α), iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k) (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))
⊢ @filter.tendsto.{0 u} nat α x
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    k

α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))
⊢ not
    (@filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))
⊢ @filter.tendsto.{0 u} nat α x
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    k'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))
⊢ ∀ (s : set.{u} α),
    @Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) s) →
    @Exists.{1} nat
      (λ (a : nat),
         ∀ (b : nat),
           @ge.{0} nat
             (@preorder.to_has_le.{0} nat
                (@partial_order.to_preorder.{0} nat
                   (@lattice.semilattice_sup.to_partial_order.{0} nat
                      (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
             b
             a →
           @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x b) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137      rintros A ⟨i, hgiA⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))
⊢ ∀ (s : set.{u} α),
    @Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) s) →
    @Exists.{1} nat
      (λ (a : nat),
         ∀ (b : nat),
           @ge.{0} nat
             (@preorder.to_has_le.{0} nat
                (@partial_order.to_preorder.{0} nat
                   (@lattice.semilattice_sup.to_partial_order.{0} nat
                      (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
             b
             a →
           @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x b) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B))),
A : set.{u} α,
i : nat,
hgiA : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A
⊢ @Exists.{1} nat
    (λ (a : nat),
       ∀ (b : nat),
         @ge.{0} nat
           (@preorder.to_has_le.{0} nat
              (@partial_order.to_preorder.{0} nat
                 (@lattice.semilattice_sup.to_partial_order.{0} nat
                    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
           b
           a →
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x b) A)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138      use i,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B))),
A : set.{u} α,
i : nat,
hgiA : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A
⊢ @Exists.{1} nat
    (λ (a : nat),
       ∀ (b : nat),
         @ge.{0} nat
           (@preorder.to_has_le.{0} nat
              (@partial_order.to_preorder.{0} nat
                 (@lattice.semilattice_sup.to_partial_order.{0} nat
                    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
           b
           a →
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x b) A)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B))),
A : set.{u} α,
i : nat,
hgiA : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A
⊢ ∀ (b : nat),
    @ge.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      b
      i →
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x b) A'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139      refine (λ j hj, hgiA $ gmon _ _ hj _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='hgiA'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gmon'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i j : nat), @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B))),
A : set.{u} α,
i : nat,
hgiA : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A
⊢ ∀ (b : nat),
    @ge.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      b
      i →
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x b) A'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B))),
A : set.{u} α,
i : nat,
hgiA : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A,
j : nat,
hj :
  @ge.{0} nat
    (@preorder.to_has_le.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
    j
    i
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x j) (g j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140      simp only [h] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x_1 : nat), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1)) (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B))),
A : set.{u} α,
i : nat,
hgiA : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A,
j : nat,
hj :
  @ge.{0} nat
    (@preorder.to_has_le.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
    j
    i
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x j) (g j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))
⊢ not
    (@filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141    { simp only [tendsto_at_top&#x27;, (∘), not_forall, not_exists],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='filter.tendsto_at_top&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='not_forall'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not_exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1797, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 453, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 447, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : nonempty.{?l_1+1} α] [_inst_2 : lattice.semilattice_sup.{?l_1} α] (f : α → β) (l : filter.{?l_2} β), iff (@filter.tendsto.{?l_1 ?l_2} α β f (@filter.at_top.{?l_1} α (@partial_order.to_preorder.{?l_1} α (@lattice.semilattice_sup.to_partial_order.{?l_1} α _inst_2))) l) (∀ (s : set.{?l_2} β), @has_mem.mem.{?l_2 ?l_2} (set.{?l_2} β) (filter.{?l_2} β) (@filter.has_mem.{?l_2} β) s l → @Exists.{?l_1+1} α (λ (a : α), ∀ (b : α), @ge.{?l_1} α (@preorder.to_has_le.{?l_1} α (@partial_order.to_preorder.{?l_1} α (@lattice.semilattice_sup.to_partial_order.{?l_1} α _inst_2))) b a → @has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) (f b) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1} {β : Sort ?l_2} {φ : Sort ?l_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {p : α → Prop} [_inst_1 : decidable (@Exists.{?l_1} α (λ (x : α), not (p x)))] [_inst_2 : Π (x : α), decidable (p x)], iff (not (∀ (x : α), p x)) (@Exists.{?l_1} α (λ (x : α), not (p x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {p : α → Prop}, iff (not (@Exists.{?l_1} α (λ (x : α), p x))) (∀ (x : α), not (p x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))
⊢ not
    (@filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
       l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))
⊢ @Exists.{(max (v+1) 1)} (set.{v} β)
    (λ (x_1 : set.{v} β),
       @Exists.{0}
         (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) x_1
            (@filter.sets.{v} β l))
         (λ
          (x_2 :
            @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) x_1
              (@filter.sets.{v} β l)),
            ∀ (x_2 : nat),
              @Exists.{1} nat
                (λ (x_3 : nat),
                   @Exists.{0}
                     (@ge.{0} nat
                        (@preorder.to_has_le.{0} nat
                           (@partial_order.to_preorder.{0} nat
                              (@lattice.semilattice_sup.to_partial_order.{0} nat
                                 (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                    lattice.nat.semilattice_sup_bot))))
                        x_3
                        x_2)
                     (λ
                      (x_2 :
                        @ge.{0} nat
                          (@preorder.to_has_le.{0} nat
                             (@partial_order.to_preorder.{0} nat
                                (@lattice.semilattice_sup.to_partial_order.{0} nat
                                   (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                      lattice.nat.semilattice_sup_bot))))
                          x_3
                          x_2), not (@has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f (x x_3)) x_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142      use [B, hBl],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hBl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))
⊢ @Exists.{(max (v+1) 1)} (set.{v} β)
    (λ (x_1 : set.{v} β),
       @Exists.{0}
         (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) x_1
            (@filter.sets.{v} β l))
         (λ
          (x_2 :
            @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) x_1
              (@filter.sets.{v} β l)),
            ∀ (x_2 : nat),
              @Exists.{1} nat
                (λ (x_3 : nat),
                   @Exists.{0}
                     (@ge.{0} nat
                        (@preorder.to_has_le.{0} nat
                           (@partial_order.to_preorder.{0} nat
                              (@lattice.semilattice_sup.to_partial_order.{0} nat
                                 (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                    lattice.nat.semilattice_sup_bot))))
                        x_3
                        x_2)
                     (λ
                      (x_2 :
                        @ge.{0} nat
                          (@preorder.to_has_le.{0} nat
                             (@partial_order.to_preorder.{0} nat
                                (@lattice.semilattice_sup.to_partial_order.{0} nat
                                   (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                      lattice.nat.semilattice_sup_bot))))
                          x_3
                          x_2), not (@has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f (x x_3)) x_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))
⊢ ∀ (x_1 : nat),
    @Exists.{1} nat
      (λ (x_2 : nat),
         @Exists.{0}
           (@ge.{0} nat
              (@preorder.to_has_le.{0} nat
                 (@partial_order.to_preorder.{0} nat
                    (@lattice.semilattice_sup.to_partial_order.{0} nat
                       (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
              x_2
              x_1)
           (λ
            (x_1 :
              @ge.{0} nat
                (@preorder.to_has_le.{0} nat
                   (@partial_order.to_preorder.{0} nat
                      (@lattice.semilattice_sup.to_partial_order.{0} nat
                         (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
                x_2
                x_1), not (@has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f (x x_2)) B)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143      intro i, use [i, (le_refl _)],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : preorder.{?l_1} α] (a : α), @has_le.le.{?l_1} α (@preorder.to_has_le.{?l_1} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))
⊢ ∀ (x_1 : nat),
    @Exists.{1} nat
      (λ (x_2 : nat),
         @Exists.{0}
           (@ge.{0} nat
              (@preorder.to_has_le.{0} nat
                 (@partial_order.to_preorder.{0} nat
                    (@lattice.semilattice_sup.to_partial_order.{0} nat
                       (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
              x_2
              x_1)
           (λ
            (x_1 :
              @ge.{0} nat
                (@preorder.to_has_le.{0} nat
                   (@partial_order.to_preorder.{0} nat
                      (@lattice.semilattice_sup.to_partial_order.{0} nat
                         (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
                x_2
                x_1), not (@has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f (x x_2)) B)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B))),
i : nat
⊢ @Exists.{1} nat
    (λ (x_1 : nat),
       @Exists.{0}
         (@ge.{0} nat
            (@preorder.to_has_le.{0} nat
               (@partial_order.to_preorder.{0} nat
                  (@lattice.semilattice_sup.to_partial_order.{0} nat
                     (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
            x_1
            i)
         (λ
          (x_2 :
            @ge.{0} nat
              (@preorder.to_has_le.{0} nat
                 (@partial_order.to_preorder.{0} nat
                    (@lattice.semilattice_sup.to_partial_order.{0} nat
                       (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
              x_1
              i), not (@has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f (x x_1)) B)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B))),
i : nat
⊢ not (@has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f (x i)) B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144      apply (h i).right },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (x_1 : nat), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1)) (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
k : filter.{u} α,
l : filter.{v} β,
g : nat → set.{u} α,
gmon :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g j) (g i),
gbasis :
  @eq.{u+1} (filter.{u} α) k
    (@lattice.infi.{u 1} (filter.{u} α) nat
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : nat), @filter.principal.{u} α (g i))),
gbasis :
  ∀ (A : set.{u} α),
    iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) A k)
      (@Exists.{1} nat (λ (i : nat), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (g i) A)),
_inst : Π (a : Prop), decidable a,
B : set.{v} β,
hBl : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) B (@filter.sets.{v} β l),
x : nat → α,
h :
  ∀ (x_1 : nat),
    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (g x_1))
      (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (x x_1) (@set.preimage.{u v} α β f B))),
i : nat
⊢ not (@has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f (x i)) B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147  lemma has_countable_basis.tendsto_of_seq_tendsto {f : α → β} {k : filter α} {l : filter β}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148    (hcb : k.has_countable_basis) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.has_countable_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, filter.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A filter has a countable basis iff it is generated by a countable collection
of subsets of α. (A filter is a generated by a collection of sets iff it is
the infimum of the principal filters.)

Note: we do not require the collection to be closed under finite intersections.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149    (∀ x : ℕ → α, tendsto x at_top k → tendsto (f ∘ x) at_top l) → tendsto f k l :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ (x : nat → α), @filter.tendsto.{0 u} nat α x (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) k → @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x) (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {β : Type u} {φ : Type v}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  hcb.tendsto_iff_seq_tendsto.2</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='hcb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.has_countable_basis.tendsto_iff_seq_tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 116, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@filter.has_countable_basis.{u} α k'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {f : α → β} {k : filter.{u} α} {l : filter.{v} β}, @filter.has_countable_basis.{u} α k → iff (@filter.tendsto.{u v} α β f k l) (∀ (x : nat → α), @filter.tendsto.{0 u} nat α x (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) k → @filter.tendsto.{0 v} nat β (@function.comp.{1 u+1 v+1} nat α β f x) (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  end filter</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  namespace topological_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  /- countability axioms</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  For our applications we are interested that there exists a countable basis, but we do not need the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  concrete basis itself. This allows us to declare these type classes as `Prop` to use them as mixins.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  universe u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  variables {α : Type u} [t : topological_space α]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='topological_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  include t</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  /-- A topological basis is one that satisfies the necessary conditions so that</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165    it suffices to take unions of the basis sets to get a topology (without taking</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166    finite intersections as well). -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  def is_topological_basis (s : set (set α)) : Prop :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  (∀t₁∈s, ∀t₂∈s, ∀ x ∈ t₁ ∩ t₂, ∃ t₃∈s, x ∈ t₃ ∧ t₃ ⊆ t₁ ∩ t₂) ∧</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='t₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='t₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  (⋃₀ s) = univ ∧</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.sUnion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 78, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  t = generate_from s</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='topological_space.generate_from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='topological_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → topological_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The smallest topological space containing the collection `g` of basic sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  lemma is_topological_basis_of_subbasis {s : set (set α)} (hs : t = generate_from s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='topological_space.generate_from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='topological_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → topological_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                   </code><font color='orange'><a title='The smallest topological space containing the collection `g` of basic sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173    is_topological_basis ((λf, ⋂₀ f) &#x27;&#x27; {f:set (set α) | finite f ∧ f ⊆ s ∧ (⋂₀ f).nonempty}) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.is_topological_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.sInter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.finite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.sInter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} (set.{u} α) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u}, (α → β) → set.{u} α → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A topological basis is one that satisfies the necessary conditions so that
 it suffices to take unions of the basis sets to get a topology (without taking
 finite intersections as well).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Intersection of a set of sets.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A set is finite if the subtype is a fintype, i.e. there is a
 list that enumerates its members.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Intersection of a set of sets.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' The property `s.nonempty` expresses the fact that the set `s` is not empty. It should be used
in theorem assumptions instead of `∃ x, x ∈ s` or `s ≠ ∅` as it gives access to a nice API thanks
to the dot notation.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174  let b&#x27; := (λf, ⋂₀ f) &#x27;&#x27; {f:set (set α) | finite f ∧ f ⊆ s ∧ (⋂₀ f).nonempty} in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.sInter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.finite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.sInter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u}, (α → β) → set.{u} α → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='Intersection of a set of sets.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A set is finite if the subtype is a fintype, i.e. there is a
 list that enumerates its members.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Intersection of a set of sets.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' The property `s.nonempty` expresses the fact that the set `s` is not empty. It should be used
in theorem assumptions instead of `∃ x, x ∈ s` or `s ≠ ∅` as it gives access to a nice API thanks
to the dot notation.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175  ⟨assume s₁ ⟨t₁, ⟨hft₁, ht₁b, ht₁⟩, eq₁⟩ s₂ ⟨t₂, ⟨hft₂, ht₂b, ht₂⟩, eq₂⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='s₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='t₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hft₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht₁b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='eq₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='t₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hft₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht₂b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='eq₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ (@set.image.{u u} (set.{u} (set.{u} α)) (set.{u} α) (λ (f : set.{u} (set.{u} α)), @set.sInter.{u} α f) (@set_of.{u} (set.{u} (set.{u} α)) (λ (f : set.{u} (set.{u} α)), and (@set.finite.{u} (set.{u} α) f) (and (@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) f s) (@set.nonempty.{u} α (@set.sInter.{u} α f))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@set.finite.{u} (set.{u} α) t₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) t₁ s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@eq.{u+1} (set.{u} α) ((λ (f : set.{u} (set.{u} α)), @set.sInter.{u} α f) t₁) s₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ (@set.image.{u u} (set.{u} (set.{u} α)) (set.{u} α) (λ (f : set.{u} (set.{u} α)), @set.sInter.{u} α f) (@set_of.{u} (set.{u} (set.{u} α)) (λ (f : set.{u} (set.{u} α)), and (@set.finite.{u} (set.{u} α) f) (and (@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) f s) (@set.nonempty.{u} α (@set.sInter.{u} α f))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@set.finite.{u} (set.{u} α) t₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) t₂ s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@eq.{u+1} (set.{u} α) ((λ (f : set.{u} (set.{u} α)), @set.sInter.{u} α f) t₂) s₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176      have ie : ⋂₀(t₁ ∪ t₂) = ⋂₀ t₁ ∩ ⋂₀ t₂, from Inf_union,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='set.sInter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_union.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.sInter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.sInter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='lattice.Inf_union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [c : has_union.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.complete_lattice.{u} α] {s t : set.{u} α}, @eq.{u+1} α (@lattice.Inf.{u} α (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)) (@lattice.has_inf.inf.{u} α (@lattice.semilattice_inf.to_has_inf.{u} α (@lattice.semilattice_inf_bot.to_semilattice_inf.{u} α (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1)))) (@lattice.Inf.{u} α (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) s) (@lattice.Inf.{u} α (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Intersection of a set of sets.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='Intersection of a set of sets.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Intersection of a set of sets.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177      eq₁ ▸ eq₂ ▸ assume x h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) ((λ (f : set.{u} (set.{u} α)), @set.sInter.{u} α f) t₁) ((λ (f : set.{u} (set.{u} α)), @set.sInter.{u} α f) t₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178        ⟨_, ⟨t₁ ∪ t₂, ⟨finite_union hft₁ hft₂, union_subset ht₁b ht₂b,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='has_union.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.finite_union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='set.union_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 183, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π {α : Type u} [c : has_union.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α}, @set.finite.{u} α s → @set.finite.{u} α t → @set.finite.{u} α (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='∀ {α : Type u} {s t r : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s r → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t r → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t) r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179          ie.symm ▸ ⟨_, h⟩⟩, ie⟩, h, subset.refl _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ie'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ie'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@eq.{(max (u+1) 1)} (set.{u} α) (@set.sInter.{u} α (@has_union.union.{u} (set.{u} (set.{u} α)) (@set.has_union.{u} (set.{u} α)) t₁ t₂)) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set.sInter.{u} α t₁) (@set.sInter.{u} α t₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : α}, @eq.{(max (u+1) 1)} α a b → @eq.{(max (u+1) 1)} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{(max (u+1) 1)} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) ((λ (f : set.{u} (set.{u} α)), @set.sInter.{u} α f) t₁) ((λ (f : set.{u} (set.{u} α)), @set.sInter.{u} α f) t₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@eq.{(max (u+1) 1)} (set.{u} α) (@set.sInter.{u} α (@has_union.union.{u} (set.{u} (set.{u} α)) (@set.has_union.{u} (set.{u} α)) t₁ t₂)) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set.sInter.{u} α t₁) (@set.sInter.{u} α t₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) ((λ (f : set.{u} (set.{u} α)), @set.sInter.{u} α f) t₁) ((λ (f : set.{u} (set.{u} α)), @set.sInter.{u} α f) t₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} (a : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180    eq_univ_iff_forall.2 $ assume a, ⟨univ, ⟨∅, ⟨finite_empty, empty_subset _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.eq_univ_iff_forall'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.finite_empty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.empty_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 248, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 77, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 200, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, iff (@eq.{(max (u+1) 1)} (set.{u} α) s (@set.univ.{u} α)) (∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [c : has_emptyc.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u}, @set.finite.{u} α (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} (s : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181      by rw sInter_empty; exact ⟨a, mem_univ a⟩⟩, sInter_empty⟩, mem_univ _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.sInter_empty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='set.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.sInter_empty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 371, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 235, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 371, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 235, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u}, @eq.{(max (u+1) 1)} (set.{u} α) (@set.sInter.{u} α (@has_emptyc.emptyc.{u} (set.{u} (set.{u} α)) (@set.has_emptyc.{u} (set.{u} α)))) (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u}, @eq.{(max (u+1) 1)} (set.{u} α) (@set.sInter.{u} α (@has_emptyc.emptyc.{u} (set.{u} (set.{u} α)) (@set.has_emptyc.{u} (set.{u} α)))) (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
s : set.{u} (set.{u} α),
hs : @eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α s),
b&#x27; : set.{u} (set.{u} α) :=
  @set.image.{u u} (set.{u} (set.{u} α)) (set.{u} α) (λ (f : set.{u} (set.{u} α)), @set.sInter.{u} α f)
    (@set_of.{u} (set.{u} (set.{u} α))
       (λ (f : set.{u} (set.{u} α)),
          and (@set.finite.{u} (set.{u} α) f)
            (and (@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) f s)
               (@set.nonempty.{u} α (@set.sInter.{u} α f))))),
a : α
⊢ @set.nonempty.{u} α
    (@set.sInter.{u} α (@has_emptyc.emptyc.{u} (set.{u} (set.{u} α)) (@set.has_emptyc.{u} (set.{u} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182   have generate_from s = generate_from b&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='topological_space.generate_from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='topological_space.generate_from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → topological_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → topological_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The smallest topological space containing the collection `g` of basic sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The smallest topological space containing the collection `g` of basic sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183      from le_antisymm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : partial_order.{u} α] {a b : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a b → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) b a → @eq.{u+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184        (le_generate_from $ assume u ⟨t, ⟨hft, htb, ne⟩, eq⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='le_generate_from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hft'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='htb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 358, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u} {t : topological_space.{u} α} {g : set.{u} (set.{u} α)}, (∀ (s : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s g → @is_open.{u} α t s) → @has_le.le.{u} (topological_space.{u} α) (@preorder.to_has_le.{u} (topological_space.{u} α) (@partial_order.to_preorder.{u} (topological_space.{u} α) (@topological_space.partial_order.{u} α))) t (@topological_space.generate_from.{u} α g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@set.finite.{u} (set.{u} α) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) t s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@eq.{u+1} (set.{u} α) ((λ (f : set.{u} (set.{u} α)), @set.sInter.{u} α f) t) u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185          eq ▸ @is_open_sInter _ (generate_from s) _ hft (assume s hs, generate_open.basic _ $ htb hs))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open_sInter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='topological_space.generate_from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.generate_open.basic'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} (set.{u} α)}, @set.finite.{u} (set.{u} α) s → (∀ (t : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t s → @is_open.{u} α _inst_1 t) → @is_open.{u} α _inst_1 (@set.sInter.{u} α s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → topological_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {g : set.{u} (set.{u} α)} (s : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s g → @topological_space.generate_open.{u} α g s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='The smallest topological space containing the collection `g` of basic sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186        (le_generate_from $ assume s hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='le_generate_from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 358, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u} {t : topological_space.{u} α} {g : set.{u} (set.{u} α)}, (∀ (s : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s g → @is_open.{u} α t s) → @has_le.le.{u} (topological_space.{u} α) (@preorder.to_has_le.{u} (topological_space.{u} α) (@partial_order.to_preorder.{u} (topological_space.{u} α) (@topological_space.partial_order.{u} α))) t (@topological_space.generate_from.{u} α g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s s_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187          s.eq_empty_or_nonempty.elim</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.eq_empty_or_nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='or.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 215, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 202, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (s : set.{u} α), or (@eq.{(max (u+1) 1)} (set.{u} α) s (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))) (@set.nonempty.{u} α s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b c : Prop}, or a b → (a → c) → (b → c) → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188            (assume : s = ∅, by rw [this]; apply @is_open_empty _ _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='is_open_empty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : has_emptyc.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u+1) 1)} (set.{u} α) s (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α], @is_open.{u} α _inst_1 (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
s : set.{u} (set.{u} α),
hs : @eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α s),
b&#x27; : set.{u} (set.{u} α) :=
  @set.image.{u u} (set.{u} (set.{u} α)) (set.{u} α) (λ (f : set.{u} (set.{u} α)), @set.sInter.{u} α f)
    (@set_of.{u} (set.{u} (set.{u} α))
       (λ (f : set.{u} (set.{u} α)),
          and (@set.finite.{u} (set.{u} α) f)
            (and (@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) f s)
               (@set.nonempty.{u} α (@set.sInter.{u} α f))))),
s : set.{u} α,
hs : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s s,
this : @eq.{(max (u+1) 1)} (set.{u} α) s (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
⊢ @is_open.{u} α (@topological_space.generate_from.{u} α b&#x27;) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
s : set.{u} (set.{u} α),
hs : @eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α s),
b&#x27; : set.{u} (set.{u} α) :=
  @set.image.{u u} (set.{u} (set.{u} α)) (set.{u} α) (λ (f : set.{u} (set.{u} α)), @set.sInter.{u} α f)
    (@set_of.{u} (set.{u} (set.{u} α))
       (λ (f : set.{u} (set.{u} α)),
          and (@set.finite.{u} (set.{u} α) f)
            (and (@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) f s)
               (@set.nonempty.{u} α (@set.sInter.{u} α f))))),
s : set.{u} α,
hs : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s s,
this : @eq.{(max (u+1) 1)} (set.{u} α) s (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
⊢ @is_open.{u} α (@topological_space.generate_from.{u} α b&#x27;)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
s : set.{u} (set.{u} α),
hs : @eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α s),
b&#x27; : set.{u} (set.{u} α) :=
  @set.image.{u u} (set.{u} (set.{u} α)) (set.{u} α) (λ (f : set.{u} (set.{u} α)), @set.sInter.{u} α f)
    (@set_of.{u} (set.{u} (set.{u} α))
       (λ (f : set.{u} (set.{u} α)),
          and (@set.finite.{u} (set.{u} α) f)
            (and (@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) f s)
               (@set.nonempty.{u} α (@set.sInter.{u} α f))))),
s : set.{u} α,
hs : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s s,
this : @eq.{(max (u+1) 1)} (set.{u} α) s (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
⊢ @is_open.{u} α (@topological_space.generate_from.{u} α b&#x27;) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189            (assume : s.nonempty, generate_open.basic _ ⟨{s}, ⟨finite_singleton s, singleton_subset_iff.2 hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.generate_open.basic'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.finite_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.singleton_subset_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 159, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 535, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {g : set.{u} (set.{u} α)} (s : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s g → @topological_space.generate_open.{u} α g s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} (a : α), @set.finite.{u} α (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {a : α} {s : set.{u} α}, iff (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) a) s) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s s_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title=' The property `s.nonempty` expresses the fact that the set `s` is not empty. It should be used
in theorem assumptions instead of `∃ x, x ∈ s` or `s ≠ ∅` as it gives access to a nice API thanks
to the dot notation.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190              by rwa sInter_singleton⟩, sInter_singleton s⟩)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='set.sInter_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.sInter_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 375, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 375, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (s : set.{u} α), @eq.{(max (u+1) 1)} (set.{u} α) (@set.sInter.{u} α (@singleton.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_emptyc.{u} (set.{u} α)) (@set.has_insert.{u} (set.{u} α)) s)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} (s : set.{u} α), @eq.{(max (u+1) 1)} (set.{u} α) (@set.sInter.{u} α (@singleton.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_emptyc.{u} (set.{u} α)) (@set.has_insert.{u} (set.{u} α)) s)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
s : set.{u} (set.{u} α),
hs : @eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α s),
b&#x27; : set.{u} (set.{u} α) :=
  @set.image.{u u} (set.{u} (set.{u} α)) (set.{u} α) (λ (f : set.{u} (set.{u} α)), @set.sInter.{u} α f)
    (@set_of.{u} (set.{u} (set.{u} α))
       (λ (f : set.{u} (set.{u} α)),
          and (@set.finite.{u} (set.{u} α) f)
            (and (@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) f s)
               (@set.nonempty.{u} α (@set.sInter.{u} α f))))),
s : set.{u} α,
hs : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s s,
this : @set.nonempty.{u} α s
⊢ @set.nonempty.{u} α
    (@set.sInter.{u} α
       (@singleton.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_emptyc.{u} (set.{u} α))
          (@set.has_insert.{u} (set.{u} α))
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191    this ▸ hs⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{u+1} (topological_space.{u} α) (@topological_space.generate_from.{u} α s) (@topological_space.generate_from.{u} α b&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193  lemma is_topological_basis_of_open_of_nhds {s : set (set α)}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194    (h_open : ∀ u ∈ s, _root_.is_open u)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195    (h_nhds : ∀(a:α) (u : set α), a ∈ u → _root_.is_open u → ∃v ∈ s, a ∈ v ∧ v ⊆ u) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196    is_topological_basis s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.is_topological_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} (set.{u} α) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A topological basis is one that satisfies the necessary conditions so that
 it suffices to take unions of the basis sets to get a topology (without taking
 finite intersections as well).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  ⟨assume t₁ ht₁ t₂ ht₂ x ⟨xt₁, xt₂⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='t₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='xt₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xt₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198      h_nhds x (t₁ ∩ t₂) ⟨xt₁, xt₂⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ (a : α) (u : set.{u} α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a u → @is_open.{u} α t u → @Exists.{u+1} (set.{u} α) (λ (v : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v s) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v s), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a v) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) v u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199        (is_open_inter _ _ _ (h_open _ ht₁) (h_open _ ht₂)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='topological_space.is_open_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ht₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ht₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u} (c : topological_space.{u} α) (s t : set.{u} α), @topological_space.is_open.{u} α c s → @topological_space.is_open.{u} α c t → @topological_space.is_open.{u} α c (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ (u : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u s → @is_open.{u} α t u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ (u : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u s → @is_open.{u} α t u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200    eq_univ_iff_forall.2 $ assume a,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.eq_univ_iff_forall'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 248, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, iff (@eq.{(max (u+1) 1)} (set.{u} α) s (@set.univ.{u} α)) (∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201      let ⟨u, h₁, h₂, _⟩ := h_nhds a univ trivial (is_open_univ _) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='trivial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.is_open_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@Exists.{u+1} (set.{u} α) (λ (v : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v s) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v s), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a v) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) v (@set.univ.{u} α)))) → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ (a : α) (u : set.{u} α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a u → @is_open.{u} α t u → @Exists.{u+1} (set.{u} α) (λ (v : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v s) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v s), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a v) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) v u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} (c : topological_space.{u} α), @topological_space.is_open.{u} α c (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202      ⟨u, h₁, h₂⟩,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203    le_antisymm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : partial_order.{u} α] {a b : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) a b → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α _inst_1)) b a → @eq.{u+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204      (le_generate_from h_open)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='le_generate_from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 358, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {t : topological_space.{u} α} {g : set.{u} (set.{u} α)}, (∀ (s : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s g → @is_open.{u} α t s) → @has_le.le.{u} (topological_space.{u} α) (@preorder.to_has_le.{u} (topological_space.{u} α) (@partial_order.to_preorder.{u} (topological_space.{u} α) (@topological_space.partial_order.{u} α))) t (@topological_space.generate_from.{u} α g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (u : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u s → @is_open.{u} α t u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205      (assume u hu,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.is_open.{u} α t u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206        (@is_open_iff_nhds α (generate_from _) _).mpr $ assume a hau,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_open_iff_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.generate_from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hau'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 492, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} α}, iff (@is_open.{u} α _inst_1 s) (∀ (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) (@nhds.{u} α _inst_1 a) (@filter.principal.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → topological_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The smallest topological space containing the collection `g` of basic sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207          let ⟨v, hvs, hav, hvu⟩ := h_nhds a u hau hu in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='h_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hau'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@Exists.{u+1} (set.{u} α) (λ (v : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v s) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v s), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a v) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) v u))) → @has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) (@nhds.{u} α (@topological_space.generate_from.{u} α s) a) (@filter.principal.{u} α u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='∀ (a : α) (u : set.{u} α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a u → @is_open.{u} α t u → @Exists.{u+1} (set.{u} α) (λ (v : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v s) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v s), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a v) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) v u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.is_open.{u} α t u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208          by rw nhds_generate_from; exact infi_le_of_le v (infi_le_of_le ⟨hav, hvs⟩ $ le_principal_iff.2 hvu))⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='topological_space.nhds_generate_from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.infi_le_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hav'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hvs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='filter.le_principal_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hvu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 297, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 374, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {g : set.{u} (set.{u} α)} {a : α}, @eq.{u+1} (filter.{u} α) (@nhds.{u} α (@topological_space.generate_from.{u} α g) a) (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α) (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (s : set.{u} α), @lattice.infi.{u 0} (filter.{u} α) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s (@set_of.{u} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s g)))) (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s (@set_of.{u} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s g)))), @filter.principal.{u} α s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {ι : Type u} [_inst_1 : lattice.complete_lattice.{u} α] {s : ι → α} {a : α} (i : ι), @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) (s i) a → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) (@lattice.infi.{u (max (u+1) 1)} α ι (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) s) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α} {f : filter.{u} α}, iff (@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@filter.principal.{u} α s)) (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) v u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
s : set.{u} (set.{u} α),
h_open :
  ∀ (u : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u s → @is_open.{u} α t u,
h_nhds :
  ∀ (a : α) (u : set.{u} α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a u →
    @is_open.{u} α t u →
    @Exists.{u+1} (set.{u} α)
      (λ (v : set.{u} α),
         @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v s)
           (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v s),
              and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a v)
                (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) v u))),
u : set.{u} α,
hu : @topological_space.is_open.{u} α t u,
a : α,
hau : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a u,
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (v : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v s)
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v s),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a v)
              (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) v u))) →
  @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
    (@nhds.{u} α (@topological_space.generate_from.{u} α s) a)
    (@filter.principal.{u} α u),
v : set.{u} α,
hvs : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v s,
hav : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a v,
hvu : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) v u
⊢ @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
    (@nhds.{u} α (@topological_space.generate_from.{u} α s) a)
    (@filter.principal.{u} α u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210  lemma mem_nhds_of_is_topological_basis {a : α} {s : set α} {b : set (set α)}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_fun_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s (@set_of.{u} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))) → ∀ (y : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) y (@set_of.{u} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))) → @Exists.{u+1} (set.{u} α) (λ (z : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) z (@set_of.{u} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) z (@set_of.{u} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))), and (@order.preimage.{u+1 u+1} (set.{u} α) (filter.{u} α) (λ (i : set.{u} α), @filter.principal.{u} α i) (@ge.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))) s z) (@order.preimage.{u+1 u+1} (set.{u} α) (filter.{u} α) (λ (i : set.{u} α), @filter.principal.{u} α i) (@ge.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))) y z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211    (hb : is_topological_basis b) : s ∈ 𝓝 a ↔ ∃t∈b, a ∈ t ∧ t ⊆ s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='topological_space.is_topological_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} (set.{u} α) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A topological basis is one that satisfies the necessary conditions so that
 it suffices to take unions of the basis sets to get a topology (without taking
 finite intersections as well).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α t a))
    (@Exists.{u+1} (set.{u} α)
       (λ (t : set.{u} α),
          @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b)
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t)
                 (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213    change s ∈ (𝓝 a).sets ↔ ∃t∈b, a ∈ t ∧ t ⊆ s,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α t a))
    (@Exists.{u+1} (set.{u} α)
       (λ (t : set.{u} α),
          @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b)
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t)
                 (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ iff
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
       (@filter.sets.{u} α (@nhds.{u} α t a)))
    (@Exists.{u+1} (set.{u} α)
       (λ (t : set.{u} α),
          @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b)
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t)
                 (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214    rw [hb.2.2, nhds_generate_from, binfi_sets_eq],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='topological_space.nhds_generate_from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.binfi_sets_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 453, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_space.is_topological_basis.{u} α t b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {g : set.{u} (set.{u} α)} {a : α}, @eq.{u+1} (filter.{u} α) (@nhds.{u} α (@topological_space.generate_from.{u} α g) a) (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α) (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (s : set.{u} α), @lattice.infi.{u 0} (filter.{u} α) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s (@set_of.{u} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s g)))) (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s (@set_of.{u} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s g)))), @filter.principal.{u} α s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} {f : β → filter.{u} α} {s : set.{u} β}, @directed_on.{u} β (@order.preimage.{u+1 u+1} β (filter.{u} α) f (@ge.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))))) s → @set.nonempty.{u} β s → @eq.{(max (u+1) 1)} (set.{u} (set.{u} α)) (@filter.sets.{u} α (@lattice.infi.{u u+1} (filter.{u} α) β (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (i : β), @lattice.infi.{u 0} (filter.{u} α) (@has_mem.mem.{u u} β (set.{u} β) (@set.has_mem.{u} β) i s) (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (H : @has_mem.mem.{u u} β (set.{u} β) (@set.has_mem.{u} β) i s), f i)))) (@set.Union.{u u+1} (set.{u} α) β (λ (i : β), @set.Union.{u 0} (set.{u} α) (@has_mem.mem.{u u} β (set.{u} β) (@set.has_mem.{u} β) i s) (λ (H : @has_mem.mem.{u u} β (set.{u} β) (@set.has_mem.{u} β) i s), @filter.sets.{u} α (f i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ iff
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
       (@filter.sets.{u} α (@nhds.{u} α t a)))
    (@Exists.{u+1} (set.{u} α)
       (λ (t : set.{u} α),
          @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b)
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t)
                 (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ iff
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
       (@filter.sets.{u} α (@nhds.{u} α (@topological_space.generate_from.{u} α b) a)))
    (@Exists.{u+1} (set.{u} α)
       (λ (t : set.{u} α),
          @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b)
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t)
                 (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ iff
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
       (@filter.sets.{u} α
          (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
             (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
             (λ (s : set.{u} α),
                @lattice.infi.{u 0} (filter.{u} α)
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                     (@set_of.{u} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))))
                  (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
                  (λ
                   (H :
                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                       (@set_of.{u} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)))), @filter.principal.{u} α s)))))
    (@Exists.{u+1} (set.{u} α)
       (λ (t : set.{u} α),
          @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b)
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t)
                 (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ iff
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
       (@set.Union.{u u+1} (set.{u} α) (set.{u} α)
          (λ (i : set.{u} α),
             @set.Union.{u 0} (set.{u} α)
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i
                  (@set_of.{u} (set.{u} α)
                     (λ (s : set.{u} α),
                        and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                          (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                             b))))
               (λ
                (H :
                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i
                    (@set_of.{u} (set.{u} α)
                       (λ (s : set.{u} α),
                          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                               b)))), @filter.sets.{u} α (@filter.principal.{u} α i)))))
    (@Exists.{u+1} (set.{u} α)
       (λ (t : set.{u} α),
          @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b)
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t)
                 (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s))))

α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ @directed_on.{u} (set.{u} α)
    (@order.preimage.{u+1 u+1} (set.{u} α) (filter.{u} α) (λ (i : set.{u} α), @filter.principal.{u} α i)
       (@ge.{u} (filter.{u} α)
          (@preorder.to_has_le.{u} (filter.{u} α)
             (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))))
    (@set_of.{u} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))

α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ @set.nonempty.{u} (set.{u} α)
    (@set_of.{u} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215    { simp only [mem_bUnion_iff, exists_prop, mem_set_of_eq, and_assoc, and.left_comm], refl },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set.mem_bUnion_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='exists_prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_set_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and.left_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 194, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 544, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 390, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 392, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {s : set.{?l_1} α} {t : α → set.{?l_2} β} {y : β}, iff (@has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) y (@set.Union.{?l_2 ?l_1+1} β α (λ (x : α), @set.Union.{?l_2 0} β (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x s) (λ (H : @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x s), t x)))) (@Exists.{?l_1+1} α (λ (x : α), @Exists.{0} (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x s) (λ (H : @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x s), @has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) y (t x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p q : Prop}, iff (@Exists.{0} p (λ (h : p), q)) (and p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {a : α} {p : α → Prop}, @eq.{1} Prop (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@set_of.{?l_1} α (λ (a : α), p a))) (p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} (a b : Prop), iff (and (and a b) c) (and a (and b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b c : Prop}, iff (and a (and b c)) (and b (and a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ iff
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
       (@set.Union.{u u+1} (set.{u} α) (set.{u} α)
          (λ (i : set.{u} α),
             @set.Union.{u 0} (set.{u} α)
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i
                  (@set_of.{u} (set.{u} α)
                     (λ (s : set.{u} α),
                        and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                          (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                             b))))
               (λ
                (H :
                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i
                    (@set_of.{u} (set.{u} α)
                       (λ (s : set.{u} α),
                          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                               b)))), @filter.sets.{u} α (@filter.principal.{u} α i)))))
    (@Exists.{u+1} (set.{u} α)
       (λ (t : set.{u} α),
          @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b)
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t)
                 (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s))))

α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ @directed_on.{u} (set.{u} α)
    (@order.preimage.{u+1 u+1} (set.{u} α) (filter.{u} α) (λ (i : set.{u} α), @filter.principal.{u} α i)
       (@ge.{u} (filter.{u} α)
          (@preorder.to_has_le.{u} (filter.{u} α)
             (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))))
    (@set_of.{u} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))

α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ @set.nonempty.{u} (set.{u} α)
    (@set_of.{u} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ iff
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
       (@set.Union.{u u+1} (set.{u} α) (set.{u} α)
          (λ (i : set.{u} α),
             @set.Union.{u 0} (set.{u} α)
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i
                  (@set_of.{u} (set.{u} α)
                     (λ (s : set.{u} α),
                        and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                          (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                             b))))
               (λ
                (H :
                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i
                    (@set_of.{u} (set.{u} α)
                       (λ (s : set.{u} α),
                          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                               b)))), @filter.sets.{u} α (@filter.principal.{u} α i)))))
    (@Exists.{u+1} (set.{u} α)
       (λ (t : set.{u} α),
          @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b)
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t)
                 (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ iff
    (@Exists.{u+1} (set.{u} α)
       (λ (x : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a x)
            (and (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x b)
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                  (@filter.sets.{u} α (@filter.principal.{u} α x))))))
    (@Exists.{u+1} (set.{u} α)
       (λ (t : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t)
            (and (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b)
               (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ @directed_on.{u} (set.{u} α)
    (@order.preimage.{u+1 u+1} (set.{u} α) (filter.{u} α) (λ (i : set.{u} α), @filter.principal.{u} α i)
       (@ge.{u} (filter.{u} α)
          (@preorder.to_has_le.{u} (filter.{u} α)
             (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))))
    (@set_of.{u} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))

α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ @set.nonempty.{u} (set.{u} α)
    (@set_of.{u} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216    { exact assume s ⟨hs₁, hs₂⟩ t ⟨ht₁, ht₂⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='hs₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ht₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ @directed_on.{u} (set.{u} α)
    (@order.preimage.{u+1 u+1} (set.{u} α) (filter.{u} α) (λ (i : set.{u} α), @filter.principal.{u} α i)
       (@ge.{u} (filter.{u} α)
          (@preorder.to_has_le.{u} (filter.{u} α)
             (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))))
    (@set_of.{u} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))

α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ @set.nonempty.{u} (set.{u} α)
    (@set_of.{u} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ @directed_on.{u} (set.{u} α)
    (@order.preimage.{u+1 u+1} (set.{u} α) (filter.{u} α) (λ (i : set.{u} α), @filter.principal.{u} α i)
       (@ge.{u} (filter.{u} α)
          (@preorder.to_has_le.{u} (filter.{u} α)
             (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))))
    (@set_of.{u} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217        have a ∈ s ∩ t, from ⟨hs₁, ht₁⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ @directed_on.{u} (set.{u} α)
    (@order.preimage.{u+1 u+1} (set.{u} α) (filter.{u} α) (λ (i : set.{u} α), @filter.principal.{u} α i)
       (@ge.{u} (filter.{u} α)
          (@preorder.to_has_le.{u} (filter.{u} α)
             (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))))
    (@set_of.{u} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218        let ⟨u, hu₁, hu₂, hu₃⟩ := hb.1 _ hs₂ _ ht₂ _ this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hu₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hu₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hu₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) u (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_space.is_topological_basis.{u} α t b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ @directed_on.{u} (set.{u} α)
    (@order.preimage.{u+1 u+1} (set.{u} α) (filter.{u} α) (λ (i : set.{u} α), @filter.principal.{u} α i)
       (@ge.{u} (filter.{u} α)
          (@preorder.to_has_le.{u} (filter.{u} α)
             (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))))
    (@set_of.{u} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219        ⟨u, ⟨hu₂, hu₁⟩, le_principal_iff.2 (subset.trans hu₃ (inter_subset_left _ _)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='blue'><a title='set.inter_subset_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} (s t : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ @directed_on.{u} (set.{u} α)
    (@order.preimage.{u+1 u+1} (set.{u} α) (filter.{u} α) (λ (i : set.{u} α), @filter.principal.{u} α i)
       (@ge.{u} (filter.{u} α)
          (@preorder.to_has_le.{u} (filter.{u} α)
             (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))))
    (@set_of.{u} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220          le_principal_iff.2 (subset.trans hu₃ (inter_subset_right _ _))⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='filter.le_principal_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.subset.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.inter_subset_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 374, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 387, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α} {f : filter.{u} α}, iff (@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@filter.principal.{u} α s)) (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {a b c : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a b → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b c → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} (s t : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ @directed_on.{u} (set.{u} α)
    (@order.preimage.{u+1 u+1} (set.{u} α) (filter.{u} α) (λ (i : set.{u} α), @filter.principal.{u} α i)
       (@ge.{u} (filter.{u} α)
          (@preorder.to_has_le.{u} (filter.{u} α)
             (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))))
    (@set_of.{u} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ @set.nonempty.{u} (set.{u} α)
    (@set_of.{u} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221    { rcases eq_univ_iff_forall.1 hb.2.1 a with ⟨i, h1, h2⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='set.eq_univ_iff_forall'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 248, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, iff (@eq.{(max (u+1) 1)} (set.{u} α) s (@set.univ.{u} α)) (∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_space.is_topological_basis.{u} α t b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b
⊢ @set.nonempty.{u} (set.{u} α)
    (@set_of.{u} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b,
i : set.{u} α,
h1 : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i b,
h2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a i
⊢ @set.nonempty.{u} (set.{u} α)
    (@set_of.{u} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222      exact ⟨i, h2, h1⟩ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
a : α,
s : set.{u} α,
b : set.{u} (set.{u} α),
hb : @topological_space.is_topological_basis.{u} α t b,
i : set.{u} α,
h1 : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i b,
h2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a i
⊢ @set.nonempty.{u} (set.{u} α)
    (@set_of.{u} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225  lemma is_open_of_is_topological_basis {s : set α} {b : set (set α)}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226    (hb : is_topological_basis b) (hs : s ∈ b) : _root_.is_open s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='topological_space.is_topological_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} (set.{u} α) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A topological basis is one that satisfies the necessary conditions so that
 it suffices to take unions of the basis sets to get a topology (without taking
 finite intersections as well).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  is_open_iff_mem_nhds.2 $ λ a as,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_open_iff_mem_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='as'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 496, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} α}, iff (@is_open.{u} α _inst_1 s) (∀ (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228  (mem_nhds_of_is_topological_basis hb).2 ⟨s, hs, as, subset.refl _⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='topological_space.mem_nhds_of_is_topological_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='as'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 210, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [t : topological_space.{u} α] {a : α} {s : set.{u} α} {b : set.{u} (set.{u} α)}, @topological_space.is_topological_basis.{u} α t b → iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α t a)) (@Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.is_topological_basis.{u} α t b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} (a : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230  lemma mem_basis_subset_of_mem_open {b : set (set α)}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231    (hb : is_topological_basis b) {a:α} {u : set α} (au : a ∈ u)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='topological_space.is_topological_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} (set.{u} α) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A topological basis is one that satisfies the necessary conditions so that
 it suffices to take unions of the basis sets to get a topology (without taking
 finite intersections as well).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232    (ou : _root_.is_open u) : ∃v ∈ b, a ∈ v ∧ v ⊆ u :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233  (mem_nhds_of_is_topological_basis hb).1 $ mem_nhds_sets ou au</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='topological_space.mem_nhds_of_is_topological_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='mem_nhds_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ou'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='au'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 210, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [t : topological_space.{u} α] {a : α} {s : set.{u} α} {b : set.{u} (set.{u} α)}, @topological_space.is_topological_basis.{u} α t b → iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α t a)) (@Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.is_topological_basis.{u} α t b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α} {s : set.{u} α}, @is_open.{u} α _inst_1 s → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_open.{u} α t u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235  lemma sUnion_basis_of_is_open {B : set (set α)}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236    (hB : is_topological_basis B) {u : set α} (ou : _root_.is_open u) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='topological_space.is_topological_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} (set.{u} α) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A topological basis is one that satisfies the necessary conditions so that
 it suffices to take unions of the basis sets to get a topology (without taking
 finite intersections as well).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237    ∃ S ⊆ B, u = ⋃₀ S :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.sUnion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 78, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238  ⟨{s ∈ B | s ⊆ u}, λ s h, h.1, set.ext $ λ a,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sep.sep'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='and.left'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_sep.{u u} α γ], (α → Prop) → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s (@has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α)) (λ (s : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u) B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s (@has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α)) (λ (s : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u) B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, and a b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {a b : set.{u} α}, (∀ (x : α), iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x a) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x b)) → @eq.{(max (u+1) 1)} (set.{u} α) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239    ⟨λ ha, let ⟨b, hb, ab, bu⟩ := mem_basis_subset_of_mem_open hB ha ou in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='bu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_space.mem_basis_subset_of_mem_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hB'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ou'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 230, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{u+1} (set.{u} α) (λ (v : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v B) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v B), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a v) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) v u))) → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α (@has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α)) (λ (s : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u) B))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) b B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} [t : topological_space.{u} α] {b : set.{u} (set.{u} α)}, @topological_space.is_topological_basis.{u} α t b → ∀ {a : α} {u : set.{u} α}, @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a u → @is_open.{u} α t u → @Exists.{u+1} (set.{u} α) (λ (v : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v b) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v b), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a v) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) v u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.is_topological_basis.{u} α t B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_open.{u} α t u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240           ⟨b, ⟨hb, bu⟩, ab⟩,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241     λ ⟨b, ⟨hb, bu⟩, ab⟩, bu ab⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='bu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α (@has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α)) (λ (s : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u) B))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='(λ (s : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243  lemma Union_basis_of_is_open {B : set (set α)}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244    (hB : is_topological_basis B) {u : set α} (ou : _root_.is_open u) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='topological_space.is_topological_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} (set.{u} α) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A topological basis is one that satisfies the necessary conditions so that
 it suffices to take unions of the basis sets to get a topology (without taking
 finite intersections as well).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245    ∃ (β : Type u) (f : β → set α), u = (⋃ i, f i) ∧ ∀ i, f i ∈ B :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (u+1)}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u+1)}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β ι : Type u}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {β ι : Type u}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246  let ⟨S, sb, su⟩ := sUnion_basis_of_is_open hB ou in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='su'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_space.sUnion_basis_of_is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hB'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ou'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;line&#x27;: 235, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u+1} (set.{u} (set.{u} α)) (λ (S : set.{u} (set.{u} α)), @Exists.{0} (@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) S B) (λ (H : @has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) S B), @eq.{(max (u+1) 1)} (set.{u} α) u (@set.sUnion.{u} α S))) → @Exists.{u+2} (Type u) (λ (β : Type u), @Exists.{(max (u+1) 1)} (β → set.{u} α) (λ (f : β → set.{u} α), and (@eq.{(max (u+1) 1)} (set.{u} α) u (@set.Union.{u u+1} α β (λ (i : β), f i))) (∀ (i : β), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) (f i) B)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) S B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{(max (u+1) 1)} (set.{u} α) u (@set.sUnion.{u} α S)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} [t : topological_space.{u} α] {B : set.{u} (set.{u} α)}, @topological_space.is_topological_basis.{u} α t B → ∀ {u : set.{u} α}, @is_open.{u} α t u → @Exists.{u+1} (set.{u} (set.{u} α)) (λ (S : set.{u} (set.{u} α)), @Exists.{0} (@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) S B) (λ (H : @has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) S B), @eq.{(max (u+1) 1)} (set.{u} α) u (@set.sUnion.{u} α S)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_space.is_topological_basis.{u} α t B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_open.{u} α t u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247  ⟨S, subtype.val, su.trans set.sUnion_eq_Union, λ ⟨b, h⟩, sb h⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='eq.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.sUnion_eq_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 478, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {p : α → Prop}, @subtype.{u+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {a b c : α}, @eq.{(max (u+1) 1)} α a b → @eq.{(max (u+1) 1)} α b c → @eq.{(max (u+1) 1)} α a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {s : set.{u} (set.{u} α)}, @eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α s) (@set.Union.{u (max 1 (u+1))} α (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) s) (λ (i : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) s), @subtype.val.{u+1} (set.{u} α) (λ (x : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x s) i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) b S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249  variables (α)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251  /-- A separable space is one with a countable dense subset. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252  class separable_space : Prop :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253  (exists_countable_closure_eq_univ : ∃s:set α, countable s ∧ closure s = univ)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.countable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title=' Countable sets

A set is countable if there exists an encoding of the set into the natural numbers.
An encoding is an injection with a partial inverse, which can be viewed as a
constructive analogue of countability. (For the most part, theorems about
`countable` will be classical and `encodable` will be constructive.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255  /-- A first-countable space is one in which every point has a</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256    countable neighborhood basis. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  class first_countable_topology : Prop :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  (nhds_generated_countable : ∀a:α, (𝓝 a).has_countable_basis)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='nhds_generated_countable'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.has_countable_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='∀ (a : α), @filter.has_countable_basis.{u} α (@nhds.{u} α t a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, filter.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A filter has a countable basis iff it is generated by a countable collection
of subsets of α. (A filter is a generated by a collection of sets iff it is
the infimum of the principal filters.)

Note: we do not require the collection to be closed under finite intersections.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260  /-- A second-countable space is one with a countable basis. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261  class second_countable_topology : Prop :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262  (is_open_generated_countable : ∃b:set (set α), countable b ∧ t = topological_space.generate_from b)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.countable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='topological_space.generate_from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='topological_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → topological_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='orange'><a title=' Countable sets

A set is countable if there exists an encoding of the set into the natural numbers.
An encoding is an injection with a partial inverse, which can be viewed as a
constructive analogue of countability. (For the most part, theorems about
`countable` will be classical and `encodable` will be constructive.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The smallest topological space containing the collection `g` of basic sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264  @[priority 100] -- see Note [lower instance priority]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265  instance second_countable_topology.to_first_countable_topology</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266    [second_countable_topology α] : first_countable_topology α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space.second_countable_topology'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='topological_space.first_countable_topology'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 257, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [t : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [t : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A second-countable space is one with a countable basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A first-countable space is one in which every point has a
 countable neighborhood basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267  let ⟨b, hb, eq⟩ := second_countable_topology.is_open_generated_countable α in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='topological_space.second_countable_topology.is_open_generated_countable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} (set.{u} α)) (λ (b : set.{u} (set.{u} α)), and (@set.countable.{u} (set.{u} α) b) (@eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b))) → @topological_space.first_countable_topology.{u} α t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@set.countable.{u} (set.{u} α) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ (α : Type u) [t : topological_space.{u} α] [c : @topological_space.second_countable_topology.{u} α t], @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α)) (λ (b : set.{u} (set.{u} α)), and (@set.countable.{u} (set.{u} α) b) (@eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  ⟨assume a, ⟨{s | a ∈ s ∧ s ∈ b},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269    countable_subset (assume x ⟨_, hx⟩, hx) hb, by rw [eq, nhds_generate_from]⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.countable_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.nhds_generate_from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {s₁ s₂ : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s₁ s₂ → @set.countable.{u} α s₂ → @set.countable.{u} α s₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x (@set_of.{u} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {g : set.{u} (set.{u} α)} {a : α}, @eq.{u+1} (filter.{u} α) (@nhds.{u} α (@topological_space.generate_from.{u} α g) a) (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α) (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (s : set.{u} α), @lattice.infi.{u 0} (filter.{u} α) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s (@set_of.{u} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s g)))) (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s (@set_of.{u} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s g)))), @filter.principal.{u} α s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (@_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b))) →
  @topological_space.first_countable_topology.{u} α t,
b : set.{u} (set.{u} α),
hb : @set.countable.{u} (set.{u} α) b,
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
a : α
⊢ @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α t a)
    (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (t : set.{u} α),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
               (@set_of.{u} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))))
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
                 (@set_of.{u} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                            b)))), @filter.principal.{u} α t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (@_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b))) →
  @topological_space.first_countable_topology.{u} α t,
b : set.{u} (set.{u} α),
hb : @set.countable.{u} (set.{u} α) b,
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
a : α
⊢ @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α (@topological_space.generate_from.{u} α b) a)
    (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (t : set.{u} α),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
               (@set_of.{u} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))))
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t
                 (@set_of.{u} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                            b)))), @filter.principal.{u} α t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  lemma second_countable_topology_induced (β)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272    [t : topological_space β] [second_countable_topology β] (f : α → β) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space.second_countable_topology'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [t : topological_space.{u_1} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A second-countable space is one with a countable basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273    @second_countable_topology α (t.induced f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space.second_countable_topology'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_space.induced'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 236, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [t : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='topological_space.{u_1} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type u_1}, (α → β) → topological_space.{u_1} β → topological_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A second-countable space is one with a countable basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Given `f : α → β` and a topology on `β`, the induced topology on `α` is the collection of
 sets that are preimages of some open set in `β`. This is the coarsest topology that
 makes `f` continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type u_1,
t : topological_space.{u_1} β,
_inst_1 : @topological_space.second_countable_topology.{u_1} β t,
f : α → β
⊢ @topological_space.second_countable_topology.{u} α (@topological_space.induced.{u u_1} α β f t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275    rcases second_countable_topology.is_open_generated_countable β with ⟨b, hb, eq⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='topological_space.second_countable_topology.is_open_generated_countable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (α : Type u_1) [t : topological_space.{u_1} α] [c : @topological_space.second_countable_topology.{u_1} α t], @Exists.{(max (u_1+1) 1)} (set.{u_1} (set.{u_1} α)) (λ (b : set.{u_1} (set.{u_1} α)), and (@set.countable.{u_1} (set.{u_1} α) b) (@eq.{u_1+1} (topological_space.{u_1} α) t (@topological_space.generate_from.{u_1} α b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type u_1,
t : topological_space.{u_1} β,
_inst_1 : @topological_space.second_countable_topology.{u_1} β t,
f : α → β
⊢ @topological_space.second_countable_topology.{u} α (@topological_space.induced.{u u_1} α β f t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type u_1,
t : topological_space.{u_1} β,
_inst_1 : @topological_space.second_countable_topology.{u_1} β t,
f : α → β,
b : set.{u_1} (set.{u_1} β),
hb : @set.countable.{u_1} (set.{u_1} β) b,
eq : @_root_.eq.{u_1+1} (topological_space.{u_1} β) t (@topological_space.generate_from.{u_1} β b)
⊢ @topological_space.second_countable_topology.{u} α (@topological_space.induced.{u u_1} α β f t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276    refine { is_open_generated_countable := ⟨preimage f &#x27;&#x27; b, countable_image _ hb, _⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.countable_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type u_1}, (α → β) → set.{u_1} β → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u}, (α → β) → set.{u_1} α → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_1} (set.{u_1} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u} {s : set.{u_1} α} (f : α → β), @set.countable.{u_1} α s → @set.countable.{u} β (@set.image.{u_1 u} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@set.countable.{u_1} (set.{u_1} β) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type u_1,
t : topological_space.{u_1} β,
_inst_1 : @topological_space.second_countable_topology.{u_1} β t,
f : α → β,
b : set.{u_1} (set.{u_1} β),
hb : @set.countable.{u_1} (set.{u_1} β) b,
eq : @_root_.eq.{u_1+1} (topological_space.{u_1} β) t (@topological_space.generate_from.{u_1} β b)
⊢ @topological_space.second_countable_topology.{u} α (@topological_space.induced.{u u_1} α β f t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type u_1,
t : topological_space.{u_1} β,
_inst_1 : @topological_space.second_countable_topology.{u_1} β t,
f : α → β,
b : set.{u_1} (set.{u_1} β),
hb : @set.countable.{u_1} (set.{u_1} β) b,
eq : @_root_.eq.{u_1+1} (topological_space.{u_1} β) t (@topological_space.generate_from.{u_1} β b)
⊢ @_root_.eq.{u+1} (topological_space.{u} α) (@topological_space.induced.{u u_1} α β f t)
    (@topological_space.generate_from.{u} α
       (@set.image.{u_1 u} (set.{u_1} β) (set.{u} α) (@set.preimage.{u u_1} α β f) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277    rw [eq, induced_generate_from_eq]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='induced_generate_from_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 362, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (topological_space.{u_1} β) t (@topological_space.generate_from.{u_1} β b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type u_1} {b : set.{u_1} (set.{u_1} β)} {f : α → β}, @eq.{u+1} (topological_space.{u} α) (@topological_space.induced.{u u_1} α β f (@topological_space.generate_from.{u_1} β b)) (@topological_space.generate_from.{u} α (@set.image.{u_1 u} (set.{u_1} β) (set.{u} α) (@set.preimage.{u u_1} α β f) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type u_1,
t : topological_space.{u_1} β,
_inst_1 : @topological_space.second_countable_topology.{u_1} β t,
f : α → β,
b : set.{u_1} (set.{u_1} β),
hb : @set.countable.{u_1} (set.{u_1} β) b,
eq : @_root_.eq.{u_1+1} (topological_space.{u_1} β) t (@topological_space.generate_from.{u_1} β b)
⊢ @_root_.eq.{u+1} (topological_space.{u} α) (@topological_space.induced.{u u_1} α β f t)
    (@topological_space.generate_from.{u} α
       (@set.image.{u_1 u} (set.{u_1} β) (set.{u} α) (@set.preimage.{u u_1} α β f) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type u_1,
t : topological_space.{u_1} β,
_inst_1 : @topological_space.second_countable_topology.{u_1} β t,
f : α → β,
b : set.{u_1} (set.{u_1} β),
hb : @set.countable.{u_1} (set.{u_1} β) b,
eq : @_root_.eq.{u_1+1} (topological_space.{u_1} β) t (@topological_space.generate_from.{u_1} β b)
⊢ @_root_.eq.{u+1} (topological_space.{u} α)
    (@topological_space.induced.{u u_1} α β f (@topological_space.generate_from.{u_1} β b))
    (@topological_space.generate_from.{u} α
       (@set.image.{u_1 u} (set.{u_1} β) (set.{u} α) (@set.preimage.{u u_1} α β f) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type u_1,
t : topological_space.{u_1} β,
_inst_1 : @topological_space.second_countable_topology.{u_1} β t,
f : α → β,
b : set.{u_1} (set.{u_1} β),
hb : @set.countable.{u_1} (set.{u_1} β) b,
eq : @_root_.eq.{u_1+1} (topological_space.{u_1} β) t (@topological_space.generate_from.{u_1} β b)
⊢ @_root_.eq.{u+1} (topological_space.{u} α) (@topological_space.induced.{u u_1} α β f t)
    (@topological_space.generate_from.{u} α
       (@set.image.{u_1 u} (set.{u_1} β) (set.{u} α) (@set.preimage.{u u_1} α β f) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280  instance subtype.second_countable_topology</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281    (s : set α) [second_countable_topology α] : second_countable_topology s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space.second_countable_topology'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='topological_space.second_countable_topology'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [t : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [t : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='A second-countable space is one with a countable basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A second-countable space is one with a countable basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282  second_countable_topology_induced s α coe</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_space.second_countable_topology_induced'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 271, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (α : Type u) (β : Type u_1) [t : topological_space.{u_1} β] [_inst_1 : @topological_space.second_countable_topology.{u_1} β t] (f : α → β), @topological_space.second_countable_topology.{u} α (@topological_space.induced.{u u_1} α β f t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a : Sort u} {b : Sort v} [_inst_1 : has_lift_t.{u v} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284  lemma is_open_generated_countable_inter [second_countable_topology α] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='topological_space.second_countable_topology'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Π (α : Type u) [t : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='A second-countable space is one with a countable basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285    ∃b:set (set α), countable b ∧ ∅ ∉ b ∧ is_topological_basis b :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.countable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='topological_space.is_topological_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : has_emptyc.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} (set.{u} α) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title=' Countable sets

A set is countable if there exists an encoding of the set into the natural numbers.
An encoding is an injection with a partial inverse, which can be viewed as a
constructive analogue of countability. (For the most part, theorems about
`countable` will be classical and `encodable` will be constructive.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='A topological basis is one that satisfies the necessary conditions so that
 it suffices to take unions of the basis sets to get a topology (without taking
 finite intersections as well).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286  let ⟨b, hb₁, hb₂⟩ := second_countable_topology.is_open_generated_countable α in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hb₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hb₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_space.second_countable_topology.is_open_generated_countable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} (set.{u} α)) (λ (b : set.{u} (set.{u} α)), and (@set.countable.{u} (set.{u} α) b) (@eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b))) → @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α)) (λ (b : set.{u} (set.{u} α)), and (@set.countable.{u} (set.{u} α) b) (and (not (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) b)) (@topological_space.is_topological_basis.{u} α t b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@set.countable.{u} (set.{u} α) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ (α : Type u) [t : topological_space.{u} α] [c : @topological_space.second_countable_topology.{u} α t], @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α)) (λ (b : set.{u} (set.{u} α)), and (@set.countable.{u} (set.{u} α) b) (@eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287  let b&#x27; := (λs, ⋂₀ s) &#x27;&#x27; {s:set (set α) | finite s ∧ s ⊆ b ∧ (⋂₀ s).nonempty} in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.sInter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.finite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.sInter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u}, (α → β) → set.{u} α → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='Intersection of a set of sets.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A set is finite if the subtype is a fintype, i.e. there is a
 list that enumerates its members.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Intersection of a set of sets.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' The property `s.nonempty` expresses the fact that the set `s` is not empty. It should be used
in theorem assumptions instead of `∃ x, x ∈ s` or `s ≠ ∅` as it gives access to a nice API thanks
to the dot notation.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288  ⟨b&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289    countable_image _ $ countable_subset</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.countable_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.countable_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α β : Type u} {s : set.{u} α} (f : α → β), @set.countable.{u} α s → @set.countable.{u} β (@set.image.{u u} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {s₁ s₂ : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s₁ s₂ → @set.countable.{u} α s₂ → @set.countable.{u} α s₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290      (by simp only [(and_assoc _ _).symm]; exact inter_subset_left _ _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='and_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='set.inter_subset_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 390, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {c : Prop} (a b : Prop), iff (and (and a b) c) (and a (and b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (s t : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (@eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b))) →
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))),
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ : @eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
b&#x27; : set.{u} (set.{u} α) :=
  @set.image.{u u} (set.{u} (set.{u} α)) (set.{u} α) (λ (s : set.{u} (set.{u} α)), @set.sInter.{u} α s)
    (@set_of.{u} (set.{u} (set.{u} α))
       (λ (s : set.{u} (set.{u} α)),
          and (@set.finite.{u} (set.{u} α) s)
            (and (@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) s b)
               (@set.nonempty.{u} α (@set.sInter.{u} α s)))))
⊢ @has_subset.subset.{u} (set.{u} (set.{u} (set.{u} α))) (@set.has_subset.{u} (set.{u} (set.{u} α)))
    (@set_of.{u} (set.{u} (set.{u} α))
       (λ (s : set.{u} (set.{u} α)),
          and (@set.finite.{u} (set.{u} α) s)
            (and (@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) s b)
               (@set.nonempty.{u} α (@set.sInter.{u} α s)))))
    (@set_of.{u} (set.{u} (set.{u} α))
       (λ (t : set.{u} (set.{u} α)),
          and (@set.finite.{u} (set.{u} α) t)
            (@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) t b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291      (countable_set_of_finite_subset hb₁),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.countable_set_of_finite_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, @set.countable.{u} α s → @set.countable.{u} (set.{u} α) (@set_of.{u} (set.{u} α) (λ (t : set.{u} α), and (@set.finite.{u} α t) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292    assume ⟨s, ⟨_, _, hn⟩, hp⟩, absurd hn (not_nonempty_iff_eq_empty.2 hp),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='absurd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.not_nonempty_iff_eq_empty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@set.nonempty.{u} α (@set.sInter.{u} α s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@eq.{u+1} (set.{u} α) ((λ (s : set.{u} (set.{u} α)), @set.sInter.{u} α s) s) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {a b : Prop}, a → not a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, iff (not (@set.nonempty.{u} α s)) (@eq.{(max (u+1) 1)} (set.{u} α) s (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293    is_topological_basis_of_subbasis hb₂⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.is_topological_basis_of_subbasis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 172, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [t : topological_space.{u} α] {s : set.{u} (set.{u} α)}, @eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α s) → @topological_space.is_topological_basis.{u} α t (@set.image.{u u} (set.{u} (set.{u} α)) (set.{u} α) (λ (f : set.{u} (set.{u} α)), @set.sInter.{u} α f) (@set_of.{u} (set.{u} (set.{u} α)) (λ (f : set.{u} (set.{u} α)), and (@set.finite.{u} (set.{u} α) f) (and (@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) f s) (@set.nonempty.{u} α (@set.sInter.{u} α f))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295  /- TODO: more fine grained instances for first_countable_topology, separable_space, t2_space, ... -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296  instance {β : Type*} [topological_space β]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>297    [second_countable_topology α] [second_countable_topology β] : second_countable_topology (α × β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space.second_countable_topology'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space.second_countable_topology'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='topological_space.second_countable_topology'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [t : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [t : topological_space.{u_1} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [t : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u_1 → Type (max u u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A second-countable space is one with a countable basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A second-countable space is one with a countable basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A second-countable space is one with a countable basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>298  ⟨let ⟨a, ha₁, ha₂, ha₃, ha₄, ha₅⟩ := is_open_generated_countable_inter α in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='topological_space.is_open_generated_countable_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;line&#x27;: 284, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} (set.{u} α)) (λ (b : set.{u} (set.{u} α)), and (@set.countable.{u} (set.{u} α) b) (and (not (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) b)) (@topological_space.is_topological_basis.{u} α t b))) → @Exists.{(max ((max u u_1)+1) 1)} (set.{(max u u_1)} (set.{(max u u_1)} (prod.{u u_1} α β))) (λ (b : set.{(max u u_1)} (set.{(max u u_1)} (prod.{u u_1} α β))), and (@set.countable.{(max u u_1)} (set.{(max u u_1)} (prod.{u u_1} α β)) b) (@eq.{(max u u_1)+1} (topological_space.{(max u u_1)} (prod.{u u_1} α β)) (@prod.topological_space.{u u_1} α β t _inst_1) (@topological_space.generate_from.{(max u u_1)} (prod.{u u_1} α β) b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='∀ (α : Type u) [t : topological_space.{u} α] [_inst_1 : @topological_space.second_countable_topology.{u} α t], @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α)) (λ (b : set.{u} (set.{u} α)), and (@set.countable.{u} (set.{u} α) b) (and (not (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) b)) (@topological_space.is_topological_basis.{u} α t b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>299    let ⟨b, hb₁, hb₂, hb₃, hb₄, hb₅⟩ := is_open_generated_countable_inter β in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='topological_space.is_open_generated_countable_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;line&#x27;: 284, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{(max (u_1+1) 1)} (set.{u_1} (set.{u_1} β)) (λ (b : set.{u_1} (set.{u_1} β)), and (@set.countable.{u_1} (set.{u_1} β) b) (and (not (@has_mem.mem.{u_1 u_1} (set.{u_1} β) (set.{u_1} (set.{u_1} β)) (@set.has_mem.{u_1} (set.{u_1} β)) (@has_emptyc.emptyc.{u_1} (set.{u_1} β) (@set.has_emptyc.{u_1} β)) b)) (@topological_space.is_topological_basis.{u_1} β _inst_1 b))) → @Exists.{(max ((max u u_1)+1) 1)} (set.{(max u u_1)} (set.{(max u u_1)} (prod.{u u_1} α β))) (λ (b : set.{(max u u_1)} (set.{(max u u_1)} (prod.{u u_1} α β))), and (@set.countable.{(max u u_1)} (set.{(max u u_1)} (prod.{u u_1} α β)) b) (@eq.{(max u u_1)+1} (topological_space.{(max u u_1)} (prod.{u u_1} α β)) (@prod.topological_space.{u u_1} α β t _inst_1) (@topological_space.generate_from.{(max u u_1)} (prod.{u u_1} α β) b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_1} (set.{u_1} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='∀ (α : Type u) [t : topological_space.{u} α] [_inst_1 : @topological_space.second_countable_topology.{u} α t], @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α)) (λ (b : set.{u} (set.{u} α)), and (@set.countable.{u} (set.{u} α) b) (and (not (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) b)) (@topological_space.is_topological_basis.{u} α t b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>300    ⟨{g | ∃u∈a, ∃v∈b, g = set.prod u v},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type (max u u_1)}, (α → Prop) → set.{(max u u_1)} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{(max u u_1)} (prod.{u u_1} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_1} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{(max u u_1)} (prod.{u u_1} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u u_1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, set.{u_1} α → set.{u_2} β → set.{(max u_1 u_2)} (prod.{u_1 u_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>301      have {g | ∃u∈a, ∃v∈b, g = set.prod u v} = (⋃u∈a, ⋃v∈b, {set.prod u v}),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type (max u u_1)}, (α → Prop) → set.{(max u u_1)} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{(max u u_1)} (prod.{u u_1} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_1} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{(max u u_1)} (prod.{u u_1} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u u_1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, set.{u_1} α → set.{u_2} β → set.{(max u_1 u_2)} (prod.{u_1 u_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u u_1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type (max u u_1)} {ι : Type u}, (ι → set.{(max u u_1)} β) → set.{(max u u_1)} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type (max u u_1)} {ι : Type u}, (ι → set.{(max u u_1)} β) → set.{(max u u_1)} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {β : Type (max u u_1)} {ι : Type u_1}, (ι → set.{(max u u_1)} β) → set.{(max u u_1)} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_1} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type (max u u_1)} {ι : Type u_1}, (ι → set.{(max u u_1)} β) → set.{(max u u_1)} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type (max u u_1)} [_inst_1 : has_emptyc.{(max u u_1)} γ] [_inst_2 : has_insert.{(max u u_1) (max u u_1)} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type u_1}, set.{u} α → set.{u_1} β → set.{(max u u_1)} (prod.{u u_1} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>302        by apply set.ext; simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u u_1)} {a b : set.{(max u u_1)} α}, (∀ (x : α), iff (@has_mem.mem.{(max u u_1) (max u u_1)} α (set.{(max u u_1)} α) (@set.has_mem.{(max u u_1)} α) x a) (@has_mem.mem.{(max u u_1) (max u u_1)} α (set.{(max u u_1)} α) (@set.has_mem.{(max u u_1)} α) x b)) → @eq.{(max ((max u u_1)+1) 1)} (set.{(max u u_1)} α) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
β : Type ?l_1,
_inst_1 : topological_space.{?l_1} β,
_inst_2 : @topological_space.second_countable_topology.{u} α t,
_inst_3 : @topological_space.second_countable_topology.{?l_1} β _inst_1,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
a : set.{u} (set.{u} α),
ha₁ : @set.countable.{u} (set.{u} α) a,
ha₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       a),
ha₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ a →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ a →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
ha₄ : @eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α a) (@set.univ.{u} α),
ha₅ : @eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α a),
_let_match :
  @Exists.{(max (?l_1+1) 1)} (set.{?l_1} (set.{?l_1} β))
    (λ (b : set.{?l_1} (set.{?l_1} β)),
       and (@set.countable.{?l_1} (set.{?l_1} β) b)
         (and
            (not
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
                  b))
            (@topological_space.is_topological_basis.{?l_1} β _inst_1 b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
b : set.{?l_1} (set.{?l_1} β),
hb₁ : @set.countable.{?l_1} (set.{?l_1} β) b,
hb₂ :
  not
    (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β))
       (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
       b),
hb₃ :
  ∀ (t₁ : set.{?l_1} β),
    @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₁
      b →
    ∀ (t₂ : set.{?l_1} β),
      @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₂
        b →
      ∀ (x : β),
        @has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x
          (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂) →
        @Exists.{?l_1+1} (set.{?l_1} β)
          (λ (t₃ : set.{?l_1} β),
             @Exists.{0}
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  t₃
                  b)
               (λ
                (H :
                  @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                    (@set.has_mem.{?l_1} (set.{?l_1} β))
                    t₃
                    b),
                  and (@has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x t₃)
                    (@has_subset.subset.{?l_1} (set.{?l_1} β) (@set.has_subset.{?l_1} β) t₃
                       (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂)))),
hb₄ : @eq.{(max (?l_1+1) 1)} (set.{?l_1} β) (@set.sUnion.{?l_1} β b) (@set.univ.{?l_1} β),
hb₅ : @eq.{?l_1+1} (topological_space.{?l_1} β) _inst_1 (@topological_space.generate_from.{?l_1} β b)
⊢ @eq.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (@set_of.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
       (λ (g : set.{(max u ?l_1)} (prod.{u ?l_1} α β)),
          @Exists.{u+1} (set.{u} α)
            (λ (u : set.{u} α),
               @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
                    @Exists.{?l_1+1} (set.{?l_1} β)
                      (λ (v : set.{?l_1} β),
                         @Exists.{0}
                           (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                              (@set.has_mem.{?l_1} (set.{?l_1} β))
                              v
                              b)
                           (λ
                            (H :
                              @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                                (@set.has_mem.{?l_1} (set.{?l_1} β))
                                v
                                b),
                              @eq.{(max u ?l_1)+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) g
                                (@set.prod.{u ?l_1} α β u v)))))))
    (@set.Union.{(max u ?l_1) u+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) (set.{u} α)
       (λ (u : set.{u} α),
          @set.Union.{(max u ?l_1) 0} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
               @set.Union.{(max u ?l_1) ?l_1+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) (set.{?l_1} β)
                 (λ (v : set.{?l_1} β),
                    @set.Union.{(max u ?l_1) 0} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
                      (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                         (@set.has_mem.{?l_1} (set.{?l_1} β))
                         v
                         b)
                      (λ
                       (H :
                         @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                           (@set.has_mem.{?l_1} (set.{?l_1} β))
                           v
                           b),
                         @singleton.{(max u ?l_1) (max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
                           (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.has_emptyc.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.has_insert.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.prod.{u ?l_1} α β u v))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>303      by rw [this]; exact (countable_bUnion ha₁ $ assume u hu, countable_bUnion hb₁ $ by simp),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='ha₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='set.countable_bUnion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max ((max u u_1)+1) 1)} (set.{(max u u_1)} (set.{(max u u_1)} (prod.{u u_1} α β))) (@set_of.{(max u u_1)} (set.{(max u u_1)} (prod.{u u_1} α β)) (λ (g : set.{(max u u_1)} (prod.{u u_1} α β)), @Exists.{u+1} (set.{u} α) (λ (u : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a), @Exists.{u_1+1} (set.{u_1} β) (λ (v : set.{u_1} β), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} β) (set.{u_1} (set.{u_1} β)) (@set.has_mem.{u_1} (set.{u_1} β)) v b) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} β) (set.{u_1} (set.{u_1} β)) (@set.has_mem.{u_1} (set.{u_1} β)) v b), @eq.{(max u u_1)+1} (set.{(max u u_1)} (prod.{u u_1} α β)) g (@set.prod.{u u_1} α β u v))))))) (@set.Union.{(max u u_1) u+1} (set.{(max u u_1)} (prod.{u u_1} α β)) (set.{u} α) (λ (u : set.{u} α), @set.Union.{(max u u_1) 0} (set.{(max u u_1)} (prod.{u u_1} α β)) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a), @set.Union.{(max u u_1) u_1+1} (set.{(max u u_1)} (prod.{u u_1} α β)) (set.{u_1} β) (λ (v : set.{u_1} β), @set.Union.{(max u u_1) 0} (set.{(max u u_1)} (prod.{u u_1} α β)) (@has_mem.mem.{u_1 u_1} (set.{u_1} β) (set.{u_1} (set.{u_1} β)) (@set.has_mem.{u_1} (set.{u_1} β)) v b) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} β) (set.{u_1} (set.{u_1} β)) (@set.has_mem.{u_1} (set.{u_1} β)) v b), @singleton.{(max u u_1) (max u u_1)} (set.{(max u u_1)} (prod.{u u_1} α β)) (set.{(max u u_1)} (set.{(max u u_1)} (prod.{u u_1} α β))) (@set.has_emptyc.{(max u u_1)} (set.{(max u u_1)} (prod.{u u_1} α β))) (@set.has_insert.{(max u u_1)} (set.{(max u u_1)} (prod.{u u_1} α β))) (@set.prod.{u u_1} α β u v))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@set.countable.{u} (set.{u} α) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type (max u u_1)} {s : set.{u} α} {t : α → set.{(max u u_1)} β}, @set.countable.{u} α s → (∀ (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @set.countable.{(max u u_1)} β (t a)) → @set.countable.{(max u u_1)} β (@set.Union.{(max u u_1) u+1} β α (λ (a : α), @set.Union.{(max u u_1) 0} β (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (λ (H : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s), t a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@set.countable.{u_1} (set.{u_1} β) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
β : Type ?l_1,
_inst_1 : topological_space.{?l_1} β,
_inst_2 : @topological_space.second_countable_topology.{u} α t,
_inst_3 : @topological_space.second_countable_topology.{?l_1} β _inst_1,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
a : set.{u} (set.{u} α),
ha₁ : @set.countable.{u} (set.{u} α) a,
ha₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       a),
ha₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ a →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ a →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
ha₄ : @eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α a) (@set.univ.{u} α),
ha₅ : @eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α a),
_let_match :
  @Exists.{(max (?l_1+1) 1)} (set.{?l_1} (set.{?l_1} β))
    (λ (b : set.{?l_1} (set.{?l_1} β)),
       and (@set.countable.{?l_1} (set.{?l_1} β) b)
         (and
            (not
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
                  b))
            (@topological_space.is_topological_basis.{?l_1} β _inst_1 b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
b : set.{?l_1} (set.{?l_1} β),
hb₁ : @set.countable.{?l_1} (set.{?l_1} β) b,
hb₂ :
  not
    (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β))
       (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
       b),
hb₃ :
  ∀ (t₁ : set.{?l_1} β),
    @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₁
      b →
    ∀ (t₂ : set.{?l_1} β),
      @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₂
        b →
      ∀ (x : β),
        @has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x
          (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂) →
        @Exists.{?l_1+1} (set.{?l_1} β)
          (λ (t₃ : set.{?l_1} β),
             @Exists.{0}
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  t₃
                  b)
               (λ
                (H :
                  @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                    (@set.has_mem.{?l_1} (set.{?l_1} β))
                    t₃
                    b),
                  and (@has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x t₃)
                    (@has_subset.subset.{?l_1} (set.{?l_1} β) (@set.has_subset.{?l_1} β) t₃
                       (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂)))),
hb₄ : @eq.{(max (?l_1+1) 1)} (set.{?l_1} β) (@set.sUnion.{?l_1} β b) (@set.univ.{?l_1} β),
hb₅ : @eq.{?l_1+1} (topological_space.{?l_1} β) _inst_1 (@topological_space.generate_from.{?l_1} β b),
this :
  @eq.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (@set_of.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
       (λ (g : set.{(max u ?l_1)} (prod.{u ?l_1} α β)),
          @Exists.{u+1} (set.{u} α)
            (λ (u : set.{u} α),
               @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
                    @Exists.{?l_1+1} (set.{?l_1} β)
                      (λ (v : set.{?l_1} β),
                         @Exists.{0}
                           (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                              (@set.has_mem.{?l_1} (set.{?l_1} β))
                              v
                              b)
                           (λ
                            (H :
                              @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                                (@set.has_mem.{?l_1} (set.{?l_1} β))
                                v
                                b),
                              @eq.{(max u ?l_1)+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) g
                                (@set.prod.{u ?l_1} α β u v)))))))
    (@set.Union.{(max u ?l_1) u+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) (set.{u} α)
       (λ (u : set.{u} α),
          @set.Union.{(max u ?l_1) 0} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
               @set.Union.{(max u ?l_1) ?l_1+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) (set.{?l_1} β)
                 (λ (v : set.{?l_1} β),
                    @set.Union.{(max u ?l_1) 0} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
                      (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                         (@set.has_mem.{?l_1} (set.{?l_1} β))
                         v
                         b)
                      (λ
                       (H :
                         @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                           (@set.has_mem.{?l_1} (set.{?l_1} β))
                           v
                           b),
                         @singleton.{(max u ?l_1) (max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
                           (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.has_emptyc.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.has_insert.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.prod.{u ?l_1} α β u v))))))
⊢ @set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
    (@set_of.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
       (λ (g : set.{(max u ?l_1)} (prod.{u ?l_1} α β)),
          @Exists.{u+1} (set.{u} α)
            (λ (u : set.{u} α),
               @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
                    @Exists.{?l_1+1} (set.{?l_1} β)
                      (λ (v : set.{?l_1} β),
                         @Exists.{0}
                           (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                              (@set.has_mem.{?l_1} (set.{?l_1} β))
                              v
                              b)
                           (λ
                            (H :
                              @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                                (@set.has_mem.{?l_1} (set.{?l_1} β))
                                v
                                b),
                              @eq.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) g
                                (@set.prod.{u ?l_1} α β u v)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
β : Type ?l_1,
_inst_1 : topological_space.{?l_1} β,
_inst_2 : @topological_space.second_countable_topology.{u} α t,
_inst_3 : @topological_space.second_countable_topology.{?l_1} β _inst_1,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
a : set.{u} (set.{u} α),
ha₁ : @set.countable.{u} (set.{u} α) a,
ha₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       a),
ha₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ a →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ a →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
ha₄ : @eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α a) (@set.univ.{u} α),
ha₅ : @eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α a),
_let_match :
  @Exists.{(max (?l_1+1) 1)} (set.{?l_1} (set.{?l_1} β))
    (λ (b : set.{?l_1} (set.{?l_1} β)),
       and (@set.countable.{?l_1} (set.{?l_1} β) b)
         (and
            (not
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
                  b))
            (@topological_space.is_topological_basis.{?l_1} β _inst_1 b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
b : set.{?l_1} (set.{?l_1} β),
hb₁ : @set.countable.{?l_1} (set.{?l_1} β) b,
hb₂ :
  not
    (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β))
       (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
       b),
hb₃ :
  ∀ (t₁ : set.{?l_1} β),
    @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₁
      b →
    ∀ (t₂ : set.{?l_1} β),
      @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₂
        b →
      ∀ (x : β),
        @has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x
          (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂) →
        @Exists.{?l_1+1} (set.{?l_1} β)
          (λ (t₃ : set.{?l_1} β),
             @Exists.{0}
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  t₃
                  b)
               (λ
                (H :
                  @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                    (@set.has_mem.{?l_1} (set.{?l_1} β))
                    t₃
                    b),
                  and (@has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x t₃)
                    (@has_subset.subset.{?l_1} (set.{?l_1} β) (@set.has_subset.{?l_1} β) t₃
                       (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂)))),
hb₄ : @eq.{(max (?l_1+1) 1)} (set.{?l_1} β) (@set.sUnion.{?l_1} β b) (@set.univ.{?l_1} β),
hb₅ : @eq.{?l_1+1} (topological_space.{?l_1} β) _inst_1 (@topological_space.generate_from.{?l_1} β b),
this :
  @eq.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (@set_of.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
       (λ (g : set.{(max u ?l_1)} (prod.{u ?l_1} α β)),
          @Exists.{u+1} (set.{u} α)
            (λ (u : set.{u} α),
               @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
                    @Exists.{?l_1+1} (set.{?l_1} β)
                      (λ (v : set.{?l_1} β),
                         @Exists.{0}
                           (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                              (@set.has_mem.{?l_1} (set.{?l_1} β))
                              v
                              b)
                           (λ
                            (H :
                              @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                                (@set.has_mem.{?l_1} (set.{?l_1} β))
                                v
                                b),
                              @eq.{(max u ?l_1)+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) g
                                (@set.prod.{u ?l_1} α β u v)))))))
    (@set.Union.{(max u ?l_1) u+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) (set.{u} α)
       (λ (u : set.{u} α),
          @set.Union.{(max u ?l_1) 0} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
               @set.Union.{(max u ?l_1) ?l_1+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) (set.{?l_1} β)
                 (λ (v : set.{?l_1} β),
                    @set.Union.{(max u ?l_1) 0} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
                      (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                         (@set.has_mem.{?l_1} (set.{?l_1} β))
                         v
                         b)
                      (λ
                       (H :
                         @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                           (@set.has_mem.{?l_1} (set.{?l_1} β))
                           v
                           b),
                         @singleton.{(max u ?l_1) (max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
                           (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.has_emptyc.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.has_insert.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.prod.{u ?l_1} α β u v))))))
⊢ @set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
    (@set.Union.{(max u ?l_1) u+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) (set.{u} α)
       (λ (u : set.{u} α),
          @set.Union.{(max u ?l_1) 0} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
               @set.Union.{(max u ?l_1) ?l_1+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) (set.{?l_1} β)
                 (λ (v : set.{?l_1} β),
                    @set.Union.{(max u ?l_1) 0} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
                      (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                         (@set.has_mem.{?l_1} (set.{?l_1} β))
                         v
                         b)
                      (λ
                       (H :
                         @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                           (@set.has_mem.{?l_1} (set.{?l_1} β))
                           v
                           b),
                         @singleton.{(max u ?l_1) (max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
                           (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.has_emptyc.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.has_insert.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.prod.{u ?l_1} α β u v))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
β : Type ?l_1,
_inst_1 : topological_space.{?l_1} β,
_inst_2 : @topological_space.second_countable_topology.{u} α t,
_inst_3 : @topological_space.second_countable_topology.{?l_1} β _inst_1,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
a : set.{u} (set.{u} α),
ha₁ : @set.countable.{u} (set.{u} α) a,
ha₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       a),
ha₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ a →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ a →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
ha₄ : @eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α a) (@set.univ.{u} α),
ha₅ : @eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α a),
_let_match :
  @Exists.{(max (?l_1+1) 1)} (set.{?l_1} (set.{?l_1} β))
    (λ (b : set.{?l_1} (set.{?l_1} β)),
       and (@set.countable.{?l_1} (set.{?l_1} β) b)
         (and
            (not
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
                  b))
            (@topological_space.is_topological_basis.{?l_1} β _inst_1 b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
b : set.{?l_1} (set.{?l_1} β),
hb₁ : @set.countable.{?l_1} (set.{?l_1} β) b,
hb₂ :
  not
    (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β))
       (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
       b),
hb₃ :
  ∀ (t₁ : set.{?l_1} β),
    @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₁
      b →
    ∀ (t₂ : set.{?l_1} β),
      @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₂
        b →
      ∀ (x : β),
        @has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x
          (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂) →
        @Exists.{?l_1+1} (set.{?l_1} β)
          (λ (t₃ : set.{?l_1} β),
             @Exists.{0}
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  t₃
                  b)
               (λ
                (H :
                  @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                    (@set.has_mem.{?l_1} (set.{?l_1} β))
                    t₃
                    b),
                  and (@has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x t₃)
                    (@has_subset.subset.{?l_1} (set.{?l_1} β) (@set.has_subset.{?l_1} β) t₃
                       (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂)))),
hb₄ : @eq.{(max (?l_1+1) 1)} (set.{?l_1} β) (@set.sUnion.{?l_1} β b) (@set.univ.{?l_1} β),
hb₅ : @eq.{?l_1+1} (topological_space.{?l_1} β) _inst_1 (@topological_space.generate_from.{?l_1} β b),
this :
  @eq.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (@set_of.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
       (λ (g : set.{(max u ?l_1)} (prod.{u ?l_1} α β)),
          @Exists.{u+1} (set.{u} α)
            (λ (u : set.{u} α),
               @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
                    @Exists.{?l_1+1} (set.{?l_1} β)
                      (λ (v : set.{?l_1} β),
                         @Exists.{0}
                           (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                              (@set.has_mem.{?l_1} (set.{?l_1} β))
                              v
                              b)
                           (λ
                            (H :
                              @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                                (@set.has_mem.{?l_1} (set.{?l_1} β))
                                v
                                b),
                              @eq.{(max u ?l_1)+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) g
                                (@set.prod.{u ?l_1} α β u v)))))))
    (@set.Union.{(max u ?l_1) u+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) (set.{u} α)
       (λ (u : set.{u} α),
          @set.Union.{(max u ?l_1) 0} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
               @set.Union.{(max u ?l_1) ?l_1+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) (set.{?l_1} β)
                 (λ (v : set.{?l_1} β),
                    @set.Union.{(max u ?l_1) 0} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
                      (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                         (@set.has_mem.{?l_1} (set.{?l_1} β))
                         v
                         b)
                      (λ
                       (H :
                         @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                           (@set.has_mem.{?l_1} (set.{?l_1} β))
                           v
                           b),
                         @singleton.{(max u ?l_1) (max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
                           (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.has_emptyc.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.has_insert.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.prod.{u ?l_1} α β u v))))))
⊢ @set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
    (@set_of.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
       (λ (g : set.{(max u ?l_1)} (prod.{u ?l_1} α β)),
          @Exists.{u+1} (set.{u} α)
            (λ (u : set.{u} α),
               @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
                    @Exists.{?l_1+1} (set.{?l_1} β)
                      (λ (v : set.{?l_1} β),
                         @Exists.{0}
                           (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                              (@set.has_mem.{?l_1} (set.{?l_1} β))
                              v
                              b)
                           (λ
                            (H :
                              @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                                (@set.has_mem.{?l_1} (set.{?l_1} β))
                                v
                                b),
                              @eq.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) g
                                (@set.prod.{u ?l_1} α β u v)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
β : Type ?l_1,
_inst_1 : topological_space.{?l_1} β,
_inst_2 : @topological_space.second_countable_topology.{u} α t,
_inst_3 : @topological_space.second_countable_topology.{?l_1} β _inst_1,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
a : set.{u} (set.{u} α),
ha₁ : @set.countable.{u} (set.{u} α) a,
ha₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       a),
ha₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ a →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ a →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
ha₄ : @eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α a) (@set.univ.{u} α),
ha₅ : @eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α a),
_let_match :
  @Exists.{(max (?l_1+1) 1)} (set.{?l_1} (set.{?l_1} β))
    (λ (b : set.{?l_1} (set.{?l_1} β)),
       and (@set.countable.{?l_1} (set.{?l_1} β) b)
         (and
            (not
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
                  b))
            (@topological_space.is_topological_basis.{?l_1} β _inst_1 b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
b : set.{?l_1} (set.{?l_1} β),
hb₁ : @set.countable.{?l_1} (set.{?l_1} β) b,
hb₂ :
  not
    (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β))
       (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
       b),
hb₃ :
  ∀ (t₁ : set.{?l_1} β),
    @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₁
      b →
    ∀ (t₂ : set.{?l_1} β),
      @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₂
        b →
      ∀ (x : β),
        @has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x
          (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂) →
        @Exists.{?l_1+1} (set.{?l_1} β)
          (λ (t₃ : set.{?l_1} β),
             @Exists.{0}
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  t₃
                  b)
               (λ
                (H :
                  @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                    (@set.has_mem.{?l_1} (set.{?l_1} β))
                    t₃
                    b),
                  and (@has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x t₃)
                    (@has_subset.subset.{?l_1} (set.{?l_1} β) (@set.has_subset.{?l_1} β) t₃
                       (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂)))),
hb₄ : @eq.{(max (?l_1+1) 1)} (set.{?l_1} β) (@set.sUnion.{?l_1} β b) (@set.univ.{?l_1} β),
hb₅ : @eq.{?l_1+1} (topological_space.{?l_1} β) _inst_1 (@topological_space.generate_from.{?l_1} β b),
this :
  @eq.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (@set_of.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
       (λ (g : set.{(max u ?l_1)} (prod.{u ?l_1} α β)),
          @Exists.{u+1} (set.{u} α)
            (λ (u : set.{u} α),
               @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
                    @Exists.{?l_1+1} (set.{?l_1} β)
                      (λ (v : set.{?l_1} β),
                         @Exists.{0}
                           (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                              (@set.has_mem.{?l_1} (set.{?l_1} β))
                              v
                              b)
                           (λ
                            (H :
                              @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                                (@set.has_mem.{?l_1} (set.{?l_1} β))
                                v
                                b),
                              @eq.{(max u ?l_1)+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) g
                                (@set.prod.{u ?l_1} α β u v)))))))
    (@set.Union.{(max u ?l_1) u+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) (set.{u} α)
       (λ (u : set.{u} α),
          @set.Union.{(max u ?l_1) 0} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
               @set.Union.{(max u ?l_1) ?l_1+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) (set.{?l_1} β)
                 (λ (v : set.{?l_1} β),
                    @set.Union.{(max u ?l_1) 0} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
                      (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                         (@set.has_mem.{?l_1} (set.{?l_1} β))
                         v
                         b)
                      (λ
                       (H :
                         @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                           (@set.has_mem.{?l_1} (set.{?l_1} β))
                           v
                           b),
                         @singleton.{(max u ?l_1) (max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
                           (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.has_emptyc.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.has_insert.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.prod.{u ?l_1} α β u v)))))),
u : set.{u} α,
hu : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a
⊢ ∀ (a : set.{?l_1} β),
    @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) a b →
    @set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
      (@singleton.{(max u ?l_1) (max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
         (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
         (@set.has_emptyc.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
         (@set.has_insert.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
         (@set.prod.{u ?l_1} α β u a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
β : Type ?l_1,
_inst_1 : topological_space.{?l_1} β,
_inst_2 : @topological_space.second_countable_topology.{u} α t,
_inst_3 : @topological_space.second_countable_topology.{?l_1} β _inst_1,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
a : set.{u} (set.{u} α),
ha₁ : @set.countable.{u} (set.{u} α) a,
ha₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       a),
ha₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ a →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ a →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
ha₄ : @eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α a) (@set.univ.{u} α),
ha₅ : @eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α a),
_let_match :
  @Exists.{(max (?l_1+1) 1)} (set.{?l_1} (set.{?l_1} β))
    (λ (b : set.{?l_1} (set.{?l_1} β)),
       and (@set.countable.{?l_1} (set.{?l_1} β) b)
         (and
            (not
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
                  b))
            (@topological_space.is_topological_basis.{?l_1} β _inst_1 b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
b : set.{?l_1} (set.{?l_1} β),
hb₁ : @set.countable.{?l_1} (set.{?l_1} β) b,
hb₂ :
  not
    (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β))
       (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
       b),
hb₃ :
  ∀ (t₁ : set.{?l_1} β),
    @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₁
      b →
    ∀ (t₂ : set.{?l_1} β),
      @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₂
        b →
      ∀ (x : β),
        @has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x
          (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂) →
        @Exists.{?l_1+1} (set.{?l_1} β)
          (λ (t₃ : set.{?l_1} β),
             @Exists.{0}
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  t₃
                  b)
               (λ
                (H :
                  @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                    (@set.has_mem.{?l_1} (set.{?l_1} β))
                    t₃
                    b),
                  and (@has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x t₃)
                    (@has_subset.subset.{?l_1} (set.{?l_1} β) (@set.has_subset.{?l_1} β) t₃
                       (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂)))),
hb₄ : @eq.{(max (?l_1+1) 1)} (set.{?l_1} β) (@set.sUnion.{?l_1} β b) (@set.univ.{?l_1} β),
hb₅ : @eq.{?l_1+1} (topological_space.{?l_1} β) _inst_1 (@topological_space.generate_from.{?l_1} β b),
this :
  @eq.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (@set_of.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
       (λ (g : set.{(max u ?l_1)} (prod.{u ?l_1} α β)),
          @Exists.{u+1} (set.{u} α)
            (λ (u : set.{u} α),
               @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
                    @Exists.{?l_1+1} (set.{?l_1} β)
                      (λ (v : set.{?l_1} β),
                         @Exists.{0}
                           (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                              (@set.has_mem.{?l_1} (set.{?l_1} β))
                              v
                              b)
                           (λ
                            (H :
                              @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                                (@set.has_mem.{?l_1} (set.{?l_1} β))
                                v
                                b),
                              @eq.{(max u ?l_1)+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) g
                                (@set.prod.{u ?l_1} α β u v)))))))
    (@set.Union.{(max u ?l_1) u+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) (set.{u} α)
       (λ (u : set.{u} α),
          @set.Union.{(max u ?l_1) 0} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
            (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
               @set.Union.{(max u ?l_1) ?l_1+1} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) (set.{?l_1} β)
                 (λ (v : set.{?l_1} β),
                    @set.Union.{(max u ?l_1) 0} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
                      (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                         (@set.has_mem.{?l_1} (set.{?l_1} β))
                         v
                         b)
                      (λ
                       (H :
                         @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                           (@set.has_mem.{?l_1} (set.{?l_1} β))
                           v
                           b),
                         @singleton.{(max u ?l_1) (max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
                           (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.has_emptyc.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.has_insert.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
                           (@set.prod.{u ?l_1} α β u v))))))
⊢ @set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
    (@set_of.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
       (λ (g : set.{(max u ?l_1)} (prod.{u ?l_1} α β)),
          @Exists.{u+1} (set.{u} α)
            (λ (u : set.{u} α),
               @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
                 (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
                    @Exists.{?l_1+1} (set.{?l_1} β)
                      (λ (v : set.{?l_1} β),
                         @Exists.{0}
                           (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                              (@set.has_mem.{?l_1} (set.{?l_1} β))
                              v
                              b)
                           (λ
                            (H :
                              @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                                (@set.has_mem.{?l_1} (set.{?l_1} β))
                                v
                                b),
                              @eq.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) g
                                (@set.prod.{u ?l_1} α β u v)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>304      by rw [ha₅, hb₅, prod_generate_from_generate_from_eq ha₄ hb₄]⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='ha₅'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hb₅'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod_generate_from_generate_from_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha₄'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb₄'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (topological_space.{u_1} β) _inst_1 (@topological_space.generate_from.{u_1} β b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type u_1} {s : set.{u} (set.{u} α)} {t : set.{u_1} (set.{u_1} β)}, @eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α s) (@set.univ.{u} α) → @eq.{(max (u_1+1) 1)} (set.{u_1} β) (@set.sUnion.{u_1} β t) (@set.univ.{u_1} β) → @eq.{(max u u_1)+1} (topological_space.{(max u u_1)} (prod.{u u_1} α β)) (@prod.topological_space.{u u_1} α β (@topological_space.generate_from.{u} α s) (@topological_space.generate_from.{u_1} β t)) (@topological_space.generate_from.{(max u u_1)} (prod.{u u_1} α β) (@set_of.{(max u u_1)} (set.{(max u u_1)} (prod.{u u_1} α β)) (λ (g : set.{(max u u_1)} (prod.{u u_1} α β)), @Exists.{u+1} (set.{u} α) (λ (u : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u s) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u s), @Exists.{u_1+1} (set.{u_1} β) (λ (v : set.{u_1} β), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} β) (set.{u_1} (set.{u_1} β)) (@set.has_mem.{u_1} (set.{u_1} β)) v t) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} β) (set.{u_1} (set.{u_1} β)) (@set.has_mem.{u_1} (set.{u_1} β)) v t), @eq.{(max ((max u u_1)+1) 1)} (set.{(max u u_1)} (prod.{u u_1} α β)) g (@set.prod.{u u_1} α β u v))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α a) (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u_1+1) 1)} (set.{u_1} β) (@set.sUnion.{u_1} β b) (@set.univ.{u_1} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
β : Type ?l_1,
_inst_1 : topological_space.{?l_1} β,
_inst_2 : @topological_space.second_countable_topology.{u} α t,
_inst_3 : @topological_space.second_countable_topology.{?l_1} β _inst_1,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
a : set.{u} (set.{u} α),
ha₁ : @set.countable.{u} (set.{u} α) a,
ha₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       a),
ha₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ a →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ a →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
ha₄ : @eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α a) (@set.univ.{u} α),
ha₅ : @eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α a),
_let_match :
  @Exists.{(max (?l_1+1) 1)} (set.{?l_1} (set.{?l_1} β))
    (λ (b : set.{?l_1} (set.{?l_1} β)),
       and (@set.countable.{?l_1} (set.{?l_1} β) b)
         (and
            (not
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
                  b))
            (@topological_space.is_topological_basis.{?l_1} β _inst_1 b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
b : set.{?l_1} (set.{?l_1} β),
hb₁ : @set.countable.{?l_1} (set.{?l_1} β) b,
hb₂ :
  not
    (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β))
       (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
       b),
hb₃ :
  ∀ (t₁ : set.{?l_1} β),
    @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₁
      b →
    ∀ (t₂ : set.{?l_1} β),
      @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₂
        b →
      ∀ (x : β),
        @has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x
          (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂) →
        @Exists.{?l_1+1} (set.{?l_1} β)
          (λ (t₃ : set.{?l_1} β),
             @Exists.{0}
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  t₃
                  b)
               (λ
                (H :
                  @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                    (@set.has_mem.{?l_1} (set.{?l_1} β))
                    t₃
                    b),
                  and (@has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x t₃)
                    (@has_subset.subset.{?l_1} (set.{?l_1} β) (@set.has_subset.{?l_1} β) t₃
                       (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂)))),
hb₄ : @eq.{(max (?l_1+1) 1)} (set.{?l_1} β) (@set.sUnion.{?l_1} β b) (@set.univ.{?l_1} β),
hb₅ : @eq.{?l_1+1} (topological_space.{?l_1} β) _inst_1 (@topological_space.generate_from.{?l_1} β b)
⊢ @eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
    (@prod.topological_space.{u ?l_1} α β t _inst_1)
    (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β)
       (@set_of.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
          (λ (g : set.{(max u ?l_1)} (prod.{u ?l_1} α β)),
             @Exists.{u+1} (set.{u} α)
               (λ (u : set.{u} α),
                  @Exists.{0}
                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
                    (λ
                     (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
                       @Exists.{?l_1+1} (set.{?l_1} β)
                         (λ (v : set.{?l_1} β),
                            @Exists.{0}
                              (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                                 (@set.has_mem.{?l_1} (set.{?l_1} β))
                                 v
                                 b)
                              (λ
                               (H :
                                 @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                                   (@set.has_mem.{?l_1} (set.{?l_1} β))
                                   v
                                   b),
                                 @eq.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) g
                                   (@set.prod.{u ?l_1} α β u v))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
β : Type ?l_1,
_inst_1 : topological_space.{?l_1} β,
_inst_2 : @topological_space.second_countable_topology.{u} α t,
_inst_3 : @topological_space.second_countable_topology.{?l_1} β _inst_1,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
a : set.{u} (set.{u} α),
ha₁ : @set.countable.{u} (set.{u} α) a,
ha₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       a),
ha₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ a →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ a →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
ha₄ : @eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α a) (@set.univ.{u} α),
ha₅ : @eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α a),
_let_match :
  @Exists.{(max (?l_1+1) 1)} (set.{?l_1} (set.{?l_1} β))
    (λ (b : set.{?l_1} (set.{?l_1} β)),
       and (@set.countable.{?l_1} (set.{?l_1} β) b)
         (and
            (not
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
                  b))
            (@topological_space.is_topological_basis.{?l_1} β _inst_1 b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
b : set.{?l_1} (set.{?l_1} β),
hb₁ : @set.countable.{?l_1} (set.{?l_1} β) b,
hb₂ :
  not
    (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β))
       (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
       b),
hb₃ :
  ∀ (t₁ : set.{?l_1} β),
    @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₁
      b →
    ∀ (t₂ : set.{?l_1} β),
      @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₂
        b →
      ∀ (x : β),
        @has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x
          (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂) →
        @Exists.{?l_1+1} (set.{?l_1} β)
          (λ (t₃ : set.{?l_1} β),
             @Exists.{0}
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  t₃
                  b)
               (λ
                (H :
                  @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                    (@set.has_mem.{?l_1} (set.{?l_1} β))
                    t₃
                    b),
                  and (@has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x t₃)
                    (@has_subset.subset.{?l_1} (set.{?l_1} β) (@set.has_subset.{?l_1} β) t₃
                       (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂)))),
hb₄ : @eq.{(max (?l_1+1) 1)} (set.{?l_1} β) (@set.sUnion.{?l_1} β b) (@set.univ.{?l_1} β),
hb₅ : @eq.{?l_1+1} (topological_space.{?l_1} β) _inst_1 (@topological_space.generate_from.{?l_1} β b)
⊢ @eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
    (@prod.topological_space.{u ?l_1} α β (@topological_space.generate_from.{u} α a) _inst_1)
    (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β)
       (@set_of.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
          (λ (g : set.{(max u ?l_1)} (prod.{u ?l_1} α β)),
             @Exists.{u+1} (set.{u} α)
               (λ (u : set.{u} α),
                  @Exists.{0}
                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
                    (λ
                     (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
                       @Exists.{?l_1+1} (set.{?l_1} β)
                         (λ (v : set.{?l_1} β),
                            @Exists.{0}
                              (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                                 (@set.has_mem.{?l_1} (set.{?l_1} β))
                                 v
                                 b)
                              (λ
                               (H :
                                 @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                                   (@set.has_mem.{?l_1} (set.{?l_1} β))
                                   v
                                   b),
                                 @eq.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) g
                                   (@set.prod.{u ?l_1} α β u v))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
β : Type ?l_1,
_inst_1 : topological_space.{?l_1} β,
_inst_2 : @topological_space.second_countable_topology.{u} α t,
_inst_3 : @topological_space.second_countable_topology.{?l_1} β _inst_1,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
a : set.{u} (set.{u} α),
ha₁ : @set.countable.{u} (set.{u} α) a,
ha₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       a),
ha₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ a →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ a →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ a),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
ha₄ : @eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α a) (@set.univ.{u} α),
ha₅ : @eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α a),
_let_match :
  @Exists.{(max (?l_1+1) 1)} (set.{?l_1} (set.{?l_1} β))
    (λ (b : set.{?l_1} (set.{?l_1} β)),
       and (@set.countable.{?l_1} (set.{?l_1} β) b)
         (and
            (not
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
                  b))
            (@topological_space.is_topological_basis.{?l_1} β _inst_1 b))) →
  @Exists.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)))
    (λ (b : set.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))),
       and (@set.countable.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) b)
         (@eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
            (@prod.topological_space.{u ?l_1} α β t _inst_1)
            (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β) b))),
b : set.{?l_1} (set.{?l_1} β),
hb₁ : @set.countable.{?l_1} (set.{?l_1} β) b,
hb₂ :
  not
    (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β))
       (@has_emptyc.emptyc.{?l_1} (set.{?l_1} β) (@set.has_emptyc.{?l_1} β))
       b),
hb₃ :
  ∀ (t₁ : set.{?l_1} β),
    @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₁
      b →
    ∀ (t₂ : set.{?l_1} β),
      @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β)) (@set.has_mem.{?l_1} (set.{?l_1} β)) t₂
        b →
      ∀ (x : β),
        @has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x
          (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂) →
        @Exists.{?l_1+1} (set.{?l_1} β)
          (λ (t₃ : set.{?l_1} β),
             @Exists.{0}
               (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                  (@set.has_mem.{?l_1} (set.{?l_1} β))
                  t₃
                  b)
               (λ
                (H :
                  @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                    (@set.has_mem.{?l_1} (set.{?l_1} β))
                    t₃
                    b),
                  and (@has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x t₃)
                    (@has_subset.subset.{?l_1} (set.{?l_1} β) (@set.has_subset.{?l_1} β) t₃
                       (@has_inter.inter.{?l_1} (set.{?l_1} β) (@set.has_inter.{?l_1} β) t₁ t₂)))),
hb₄ : @eq.{(max (?l_1+1) 1)} (set.{?l_1} β) (@set.sUnion.{?l_1} β b) (@set.univ.{?l_1} β),
hb₅ : @eq.{?l_1+1} (topological_space.{?l_1} β) _inst_1 (@topological_space.generate_from.{?l_1} β b)
⊢ @eq.{(max u ?l_1)+1} (topological_space.{(max u ?l_1)} (prod.{u ?l_1} α β))
    (@prod.topological_space.{u ?l_1} α β (@topological_space.generate_from.{u} α a)
       (@topological_space.generate_from.{?l_1} β b))
    (@topological_space.generate_from.{(max u ?l_1)} (prod.{u ?l_1} α β)
       (@set_of.{(max u ?l_1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β))
          (λ (g : set.{(max u ?l_1)} (prod.{u ?l_1} α β)),
             @Exists.{u+1} (set.{u} α)
               (λ (u : set.{u} α),
                  @Exists.{0}
                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a)
                    (λ
                     (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) u a),
                       @Exists.{?l_1+1} (set.{?l_1} β)
                         (λ (v : set.{?l_1} β),
                            @Exists.{0}
                              (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                                 (@set.has_mem.{?l_1} (set.{?l_1} β))
                                 v
                                 b)
                              (λ
                               (H :
                                 @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} β) (set.{?l_1} (set.{?l_1} β))
                                   (@set.has_mem.{?l_1} (set.{?l_1} β))
                                   v
                                   b),
                                 @eq.{(max ((max u ?l_1)+1) 1)} (set.{(max u ?l_1)} (prod.{u ?l_1} α β)) g
                                   (@set.prod.{u ?l_1} α β u v))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>305  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>306  instance second_countable_topology_fintype {ι : Type*} {π : ι → Type*}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>307    [fintype ι] [t : ∀a, topological_space (π a)] [sc : ∀a, second_countable_topology (π a)] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='π'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.second_countable_topology'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='π'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [t : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`fintype α` means that `α` is finite, i.e. there are only
 finitely many distinct elements of type `α`. The evidence of this
 is a finset `elems` (a list up to permutation without duplicates),
 together with a proof that everything of type `α` is in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='A second-countable space is one with a countable basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>308    second_countable_topology (∀a, π a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.second_countable_topology'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='π'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [t : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A second-countable space is one with a countable basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>309  have ∀i, ∃b : set (set (π i)), countable b ∧ ∅ ∉ b ∧ is_topological_basis b, from</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='π'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.countable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='topological_space.is_topological_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} (set.{u_2} (π i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_2) [c : has_emptyc.{u_2} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} (set.{u_2} (π i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} (set.{u} α) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} (set.{u_2} (π i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title=' Countable sets

A set is countable if there exists an encoding of the set into the natural numbers.
An encoding is an injection with a partial inverse, which can be viewed as a
constructive analogue of countability. (For the most part, theorems about
`countable` will be classical and `encodable` will be constructive.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='A topological basis is one that satisfies the necessary conditions so that
 it suffices to take unions of the basis sets to get a topology (without taking
 finite intersections as well).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>310    assume a, @is_open_generated_countable_inter (π a) _ (sc a),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space.is_open_generated_countable_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='π'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='sc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 284, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ (α : Type u) [t : topological_space.{u} α] [_inst_1 : @topological_space.second_countable_topology.{u} α t], @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α)) (λ (b : set.{u} (set.{u} α)), and (@set.countable.{u} (set.{u} α) b) (and (not (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) b)) (@topological_space.is_topological_basis.{u} α t b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ (a : ι), @topological_space.second_countable_topology.{u_2} (π a) (t a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>311  let ⟨g, hg⟩ := classical.axiom_of_choice this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='classical.axiom_of_choice'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 130, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max (u_1+1) (u_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{u_2} (set.{u_2} (π i))) x) (λ (f : Π (x : ι), (λ (i : ι), set.{u_2} (set.{u_2} (π i))) x), ∀ (x : ι), (λ (i : ι) (b : set.{u_2} (set.{u_2} (π i))), and (@set.countable.{u_2} (set.{u_2} (π i)) b) (and (not (@has_mem.mem.{u_2 u_2} (set.{u_2} (π i)) (set.{u_2} (set.{u_2} (π i))) (@set.has_mem.{u_2} (set.{u_2} (π i))) (@has_emptyc.emptyc.{u_2} (set.{u_2} (π i)) (@set.has_emptyc.{u_2} (π i))) b)) (@topological_space.is_topological_basis.{u_2} (π i) (t i) b))) x (f x)) → @topological_space.second_countable_topology.{(max u_1 u_2)} (Π (a : ι), π a) (@Pi.topological_space.{u_1 u_2} ι (λ (a : ι), π a) (λ (a : ι), t a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (x : ι), (λ (i : ι), set.{u_2} (set.{u_2} (π i))) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (x : ι), (λ (i : ι) (b : set.{u_2} (set.{u_2} (π i))), and (@set.countable.{u_2} (set.{u_2} (π i)) b) (and (not (@has_mem.mem.{u_2 u_2} (set.{u_2} (π i)) (set.{u_2} (set.{u_2} (π i))) (@set.has_mem.{u_2} (set.{u_2} (π i))) (@has_emptyc.emptyc.{u_2} (set.{u_2} (π i)) (@set.has_emptyc.{u_2} (π i))) b)) (@topological_space.is_topological_basis.{u_2} (π i) (t i) b))) x (g x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Sort u} {β : α → Sort v} {r : Π (x : α), β x → Prop}, (∀ (x : α), @Exists.{v} (β x) (λ (y : β x), r x y)) → @Exists.{(imax u v)} (Π (x : α), β x) (λ (f : Π (x : α), β x), ∀ (x : α), r x (f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : ι), @Exists.{(max (u_2+1) 1)} (set.{u_2} (set.{u_2} (π i))) (λ (b : set.{u_2} (set.{u_2} (π i))), and (@set.countable.{u_2} (set.{u_2} (π i)) b) (and (not (@has_mem.mem.{u_2 u_2} (set.{u_2} (π i)) (set.{u_2} (set.{u_2} (π i))) (@set.has_mem.{u_2} (set.{u_2} (π i))) (@has_emptyc.emptyc.{u_2} (set.{u_2} (π i)) (@set.has_emptyc.{u_2} (π i))) b)) (@topological_space.is_topological_basis.{u_2} (π i) (t i) b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>312  have t = (λa, generate_from (g a)), from funext $ assume a, (hg a).2.2.2.2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.generate_from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/funext.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (a : ι), topological_space.{u_2} (π a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_1 u_2)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → topological_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Sort u} {β : α → Sort v} {f₁ f₂ : Π (x : α), β x}, (∀ (x : α), @eq.{v} (β x) (f₁ x) (f₂ x)) → @eq.{(imax u v)} (Π (x : α), β x) f₁ f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, and a b → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, and a b → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, and a b → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, and a b → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The smallest topological space containing the collection `g` of basic sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>313  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>314    constructor,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 988, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic applies to a goal such that its conclusion is an inductive type (say `I`). It tries to apply each constructor of `I` until it succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='constructor'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @Exists.{(max ((max ?l_1 ?l_2)+1) 1)} (set.{(max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)))
    (λ (b : set.{(max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))),
       and (@set.countable.{(max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)) b)
         (@eq.{(max ?l_1 ?l_2)+1} (topological_space.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
            (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a))
            (@topological_space.generate_from.{(max ?l_1 ?l_2)} (Π (a : ι), π a) b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>315    refine ⟨pi univ &#x27;&#x27; pi univ g, countable_image _ _, _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.pi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.countable_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1566, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type (max u_1 u_2)}, (α → β) → set.{(max u_1 u_2)} α → set.{(max u_1 u_2)} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {π : α → Type u_2}, set.{u_1} α → (Π (a : α), set.{u_2} (π a)) → set.{(max u_1 u_2)} (Π (a : α), π a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (x : ι), (λ (i : ι), set.{u_2} (set.{u_2} (π i))) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type (max u_1 u_2)} {s : set.{(max u_1 u_2)} α} (f : α → β), @set.countable.{(max u_1 u_2)} α s → @set.countable.{(max u_1 u_2)} β (@set.image.{(max u_1 u_2) (max u_1 u_2)} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Given an index set `i` and a family of sets `s : Πa, set (π a)`, `pi i s`
is the set of dependent functions `f : Πa, π a` such that `f a` belongs to `π a`
whenever `a ∈ i`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @Exists.{(max ((max ?l_1 ?l_2)+1) 1)} (set.{(max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)))
    (λ (b : set.{(max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))),
       and (@set.countable.{(max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)) b)
         (@eq.{(max ?l_1 ?l_2)+1} (topological_space.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
            (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a))
            (@topological_space.generate_from.{(max ?l_1 ?l_2)} (Π (a : ι), π a) b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @set.countable.{(max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
    (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), set.{?l_2} (π a)) (@set.univ.{?l_1} ι) g)

ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @eq.{(max ?l_1 ?l_2)+1} (topological_space.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a))
    (@topological_space.generate_from.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
       (@set.image.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
          (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), π a) (@set.univ.{?l_1} ι))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), set.{?l_2} (π a)) (@set.univ.{?l_1} ι) g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>316    { suffices : countable {f : Πa, set (π a) | ∀a, f a ∈ g a}, { simpa [pi] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set.countable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='π'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='set.pi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1566, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u_1 u_2)}, set.{(max u_1 u_2)} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u_1 u_2)}, (α → Prop) → set.{(max u_1 u_2)} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (x : ι), (λ (i : ι), set.{u_2} (set.{u_2} (π i))) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {π : α → Type ?l_2}, set.{?l_1} α → (Π (a : α), set.{?l_2} (π a)) → set.{(max ?l_1 ?l_2)} (Π (a : α), π a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Countable sets

A set is countable if there exists an encoding of the set into the natural numbers.
An encoding is an injection with a partial inverse, which can be viewed as a
constructive analogue of countability. (For the most part, theorems about
`countable` will be classical and `encodable` will be constructive.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Given an index set `i` and a family of sets `s : Πa, set (π a)`, `pi i s`
is the set of dependent functions `f : Πa, π a` such that `f a` belongs to `π a`
whenever `a ∈ i`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @set.countable.{(max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
    (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), set.{?l_2} (π a)) (@set.univ.{?l_1} ι) g)

ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @eq.{(max ?l_1 ?l_2)+1} (topological_space.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a))
    (@topological_space.generate_from.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
       (@set.image.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
          (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), π a) (@set.univ.{?l_1} ι))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), set.{?l_2} (π a)) (@set.univ.{?l_1} ι) g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @set.countable.{(max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
    (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), set.{?l_2} (π a)) (@set.univ.{?l_1} ι) g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a)),
this :
  @set.countable.{(max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
    (@set_of.{(max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
       (λ (f : Π (a : ι), set.{?l_2} (π a)),
          ∀ (a : ι),
            @has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π a)) ((λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) a)
              (@set.has_mem.{?l_2} (set.{?l_2} (π a)))
              (f a)
              (g a)))
⊢ @set.countable.{(max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
    (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), set.{?l_2} (π a)) (@set.univ.{?l_1} ι) g)

ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @set.countable.{(max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
    (@set_of.{(max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
       (λ (f : Π (a : ι), set.{?l_2} (π a)),
          ∀ (a : ι),
            @has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π a)) ((λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) a)
              (@set.has_mem.{?l_2} (set.{?l_2} (π a)))
              (f a)
              (g a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a)),
this :
  @set.countable.{(max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
    (@set_of.{(max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
       (λ (f : Π (a : ι), set.{?l_2} (π a)),
          ∀ (a : ι),
            @has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π a)) ((λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) a)
              (@set.has_mem.{?l_2} (set.{?l_2} (π a)))
              (f a)
              (g a)))
⊢ @set.countable.{(max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
    (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), set.{?l_2} (π a)) (@set.univ.{?l_1} ι) g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @set.countable.{(max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
    (@set_of.{(max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
       (λ (f : Π (a : ι), set.{?l_2} (π a)),
          ∀ (a : ι),
            @has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π a)) ((λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) a)
              (@set.has_mem.{?l_2} (set.{?l_2} (π a)))
              (f a)
              (g a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>317      exact countable_pi (assume i, (hg i).1), },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.countable_pi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 160, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {π : α → Type u_2} [_inst_1 : fintype.{u_1} α] {s : Π (a : α), set.{u_2} (π a)}, (∀ (a : α), @set.countable.{u_2} (π a) (s a)) → @set.countable.{(max u_1 u_2)} (Π (a : α), π a) (@set_of.{(max u_1 u_2)} (Π (a : α), π a) (λ (f : Π (a : α), π a), ∀ (a : α), @has_mem.mem.{u_2 u_2} (π a) (set.{u_2} (π a)) (@set.has_mem.{u_2} (π a)) (f a) (s a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (x : ι), (λ (i : ι) (b : set.{u_2} (set.{u_2} (π i))), and (@set.countable.{u_2} (set.{u_2} (π i)) b) (and (not (@has_mem.mem.{u_2 u_2} (set.{u_2} (π i)) (set.{u_2} (set.{u_2} (π i))) (@set.has_mem.{u_2} (set.{u_2} (π i))) (@has_emptyc.emptyc.{u_2} (set.{u_2} (π i)) (@set.has_emptyc.{u_2} (π i))) b)) (@topological_space.is_topological_basis.{u_2} (π i) (t i) b))) x (g x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @set.countable.{(max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
    (@set_of.{(max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
       (λ (f : Π (a : ι), set.{?l_2} (π a)),
          ∀ (a : ι),
            @has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π a)) ((λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) a)
              (@set.has_mem.{?l_2} (set.{?l_2} (π a)))
              (f a)
              (g a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @eq.{(max ?l_1 ?l_2)+1} (topological_space.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a))
    (@topological_space.generate_from.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
       (@set.image.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
          (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), π a) (@set.univ.{?l_1} ι))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), set.{?l_2} (π a)) (@set.univ.{?l_1} ι) g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>318    rw [this, pi_generate_from_eq_fintype],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pi_generate_from_eq_fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 543, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u_1+1) (u_2+1))} (Π (a : ι), topological_space.{u_2} (π a)) t (λ (a : ι), @topological_space.generate_from.{u_2} (π a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type u_1} {π : ι → Type u_2} {g : Π (a : ι), set.{u_2} (set.{u_2} (π a))} [_inst_1 : fintype.{u_1} ι], (∀ (a : ι), @eq.{(max (u_2+1) 1)} (set.{u_2} (π a)) (@set.sUnion.{u_2} (π a) (g a)) (@set.univ.{u_2} (π a))) → @eq.{(max u_1 u_2)+1} (topological_space.{(max u_1 u_2)} (Π (a : ι), π a)) (@Pi.topological_space.{u_1 u_2} ι π (λ (a : ι), @topological_space.generate_from.{u_2} (π a) (g a))) (@topological_space.generate_from.{(max u_1 u_2)} (Π (a : ι), π a) (@set_of.{(max u_1 u_2)} (set.{(max u_1 u_2)} (Π (a : ι), π a)) (λ (t : set.{(max u_1 u_2)} (Π (a : ι), π a)), @Exists.{(max (u_1+1) (u_2+1) 1)} (Π (a : ι), set.{u_2} (π a)) (λ (s : Π (a : ι), set.{u_2} (π a)), and (∀ (a : ι), @has_mem.mem.{u_2 u_2} (set.{u_2} (π a)) (set.{u_2} (set.{u_2} (π a))) (@set.has_mem.{u_2} (set.{u_2} (π a))) (s a) (g a)) (@eq.{(max ((max u_1 u_2)+1) 1)} (set.{(max u_1 u_2)} (Π (a : ι), π a)) t (@set.pi.{u_1 u_2} ι (λ (a : ι), π a) (@set.univ.{u_1} ι) s))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @eq.{(max ?l_1 ?l_2)+1} (topological_space.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a))
    (@topological_space.generate_from.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
       (@set.image.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
          (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), π a) (@set.univ.{?l_1} ι))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), set.{?l_2} (π a)) (@set.univ.{?l_1} ι) g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @eq.{(max ?l_1 ?l_2)+1} (topological_space.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a)
       (λ (a : ι), (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a)) a))
    (@topological_space.generate_from.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
       (@set.image.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
          (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), π a) (@set.univ.{?l_1} ι))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), set.{?l_2} (π a)) (@set.univ.{?l_1} ι) g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @eq.{(max ?l_1 ?l_2)+1} (topological_space.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
    (@topological_space.generate_from.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
       (@set_of.{(max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
          (λ (t : set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)),
             @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (a : ι), set.{?l_2} (π a))
               (λ (s : Π (a : ι), set.{?l_2} (π a)),
                  and
                    (∀ (a : ι),
                       @has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π a)) (set.{?l_2} (set.{?l_2} (π a)))
                         (@set.has_mem.{?l_2} (set.{?l_2} (π a)))
                         (s a)
                         (g a))
                    (@eq.{(max ((max ?l_1 ?l_2)+1) 1)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)) t
                       (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), π a) (@set.univ.{?l_1} ι) s))))))
    (@topological_space.generate_from.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
       (@set.image.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
          (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), π a) (@set.univ.{?l_1} ι))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), set.{?l_2} (π a)) (@set.univ.{?l_1} ι) g)))

ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ ∀ (a : ι), @eq.{(max (?l_2+1) 1)} (set.{?l_2} (π a)) (@set.sUnion.{?l_2} (π a) (g a)) (@set.univ.{?l_2} (π a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>319    { congr&#x27; 1, ext f, simp [pi, eq_comm] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='set.pi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1566, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@interactive.with_desc nat (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {π : α → Type ?l_2}, set.{?l_1} α → (Π (a : α), set.{?l_2} (π a)) → set.{(max ?l_1 ?l_2)} (Π (a : α), π a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {a b : α}, iff (@eq.{?l_1} α a b) (@eq.{?l_1} α b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Same as the `congr` tactic, but takes an optional argument which gives
the depth of recursive applications. This is useful when `congr`
is too aggressive in breaking down the goal. For example, given
`⊢ f (g (x + y)) = f (g (y + x))`, `congr&#x27;` produces the goals `⊢ x = y`
and `⊢ y = x`, while `congr&#x27; 2` produces the intended `⊢ x + y = y + x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Given an index set `i` and a family of sets `s : Πa, set (π a)`, `pi i s`
is the set of dependent functions `f : Πa, π a` such that `f a` belongs to `π a`
whenever `a ∈ i`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='congr&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;n?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @eq.{(max ?l_1 ?l_2)+1} (topological_space.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
    (@topological_space.generate_from.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
       (@set_of.{(max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
          (λ (t : set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)),
             @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (a : ι), set.{?l_2} (π a))
               (λ (s : Π (a : ι), set.{?l_2} (π a)),
                  and
                    (∀ (a : ι),
                       @has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π a)) (set.{?l_2} (set.{?l_2} (π a)))
                         (@set.has_mem.{?l_2} (set.{?l_2} (π a)))
                         (s a)
                         (g a))
                    (@eq.{(max ((max ?l_1 ?l_2)+1) 1)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)) t
                       (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), π a) (@set.univ.{?l_1} ι) s))))))
    (@topological_space.generate_from.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
       (@set.image.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
          (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), π a) (@set.univ.{?l_1} ι))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), set.{?l_2} (π a)) (@set.univ.{?l_1} ι) g)))

ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ ∀ (a : ι), @eq.{(max (?l_2+1) 1)} (set.{?l_2} (π a)) (@set.sUnion.{?l_2} (π a) (g a)) (@set.univ.{?l_2} (π a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @eq.{(max ?l_1 ?l_2)+1} (topological_space.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
    (@topological_space.generate_from.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
       (@set_of.{(max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
          (λ (t : set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)),
             @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (a : ι), set.{?l_2} (π a))
               (λ (s : Π (a : ι), set.{?l_2} (π a)),
                  and
                    (∀ (a : ι),
                       @has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π a)) (set.{?l_2} (set.{?l_2} (π a)))
                         (@set.has_mem.{?l_2} (set.{?l_2} (π a)))
                         (s a)
                         (g a))
                    (@eq.{(max ((max ?l_1 ?l_2)+1) 1)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)) t
                       (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), π a) (@set.univ.{?l_1} ι) s))))))
    (@topological_space.generate_from.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
       (@set.image.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
          (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), π a) (@set.univ.{?l_1} ι))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), set.{?l_2} (π a)) (@set.univ.{?l_1} ι) g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ @eq.{(max ((max ?l_1 ?l_2)+1) 1)} (set.{(max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)))
    (@set_of.{(max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
       (λ (t : set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)),
          @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (a : ι), set.{?l_2} (π a))
            (λ (s : Π (a : ι), set.{?l_2} (π a)),
               and
                 (∀ (a : ι),
                    @has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π a)) (set.{?l_2} (set.{?l_2} (π a)))
                      (@set.has_mem.{?l_2} (set.{?l_2} (π a)))
                      (s a)
                      (g a))
                 (@eq.{(max ((max ?l_1 ?l_2)+1) 1)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)) t
                    (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), π a) (@set.univ.{?l_1} ι) s)))))
    (@set.image.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
       (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
       (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), π a) (@set.univ.{?l_1} ι))
       (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), set.{?l_2} (π a)) (@set.univ.{?l_1} ι) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a)),
f : set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
⊢ iff
    (@has_mem.mem.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
       (set.{(max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)))
       (@set.has_mem.{(max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)))
       f
       (@set_of.{(max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
          (λ (t : set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)),
             @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (a : ι), set.{?l_2} (π a))
               (λ (s : Π (a : ι), set.{?l_2} (π a)),
                  and
                    (∀ (a : ι),
                       @has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π a)) (set.{?l_2} (set.{?l_2} (π a)))
                         (@set.has_mem.{?l_2} (set.{?l_2} (π a)))
                         (s a)
                         (g a))
                    (@eq.{(max ((max ?l_1 ?l_2)+1) 1)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)) t
                       (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), π a) (@set.univ.{?l_1} ι) s))))))
    (@has_mem.mem.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
       (set.{(max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)))
       (@set.has_mem.{(max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a)))
       f
       (@set.image.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (Π (a : ι), set.{?l_2} (π a))
          (set.{(max ?l_1 ?l_2)} (Π (a : ι), π a))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), π a) (@set.univ.{?l_1} ι))
          (@set.pi.{?l_1 ?l_2} ι (λ (a : ι), set.{?l_2} (π a)) (@set.univ.{?l_1} ι) g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ ∀ (a : ι), @eq.{(max (?l_2+1) 1)} (set.{?l_2} (π a)) (@set.sUnion.{?l_2} (π a) (g a)) (@set.univ.{?l_2} (π a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>320    exact assume a, (hg a).2.2.2.1</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (x : ι), (λ (i : ι) (b : set.{u_2} (set.{u_2} (π i))), and (@set.countable.{u_2} (set.{u_2} (π i)) b) (and (not (@has_mem.mem.{u_2 u_2} (set.{u_2} (π i)) (set.{u_2} (set.{u_2} (π i))) (@set.has_mem.{u_2} (set.{u_2} (π i))) (@has_emptyc.emptyc.{u_2} (set.{u_2} (π i)) (@set.has_emptyc.{u_2} (π i))) b)) (@topological_space.is_topological_basis.{u_2} (π i) (t i) b))) x (g x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type ?l_1,
π : ι → Type ?l_2,
_inst_1 : fintype.{?l_1} ι,
t : Π (a : ι), topological_space.{?l_2} (π a),
sc : ∀ (a : ι), @topological_space.second_countable_topology.{?l_2} (π a) (t a),
this :
  ∀ (i : ι),
    @Exists.{(max (?l_2+1) 1)} (set.{?l_2} (set.{?l_2} (π i)))
      (λ (b : set.{?l_2} (set.{?l_2} (π i))),
         and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
           (and
              (not
                 (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                    (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                    (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                    b))
              (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b))),
_let_match :
  @Exists.{(max (?l_1+1) (?l_2+1) 1)} (Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x)
    (λ (f : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x),
       ∀ (x : ι),
         (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
            and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
              (and
                 (not
                    (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                       (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                       (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                       b))
                 (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
           x
           (f x)) →
  @topological_space.second_countable_topology.{(max ?l_1 ?l_2)} (Π (a : ι), π a)
    (@Pi.topological_space.{?l_1 ?l_2} ι (λ (a : ι), π a) (λ (a : ι), t a)),
g : Π (x : ι), (λ (i : ι), set.{?l_2} (set.{?l_2} (π i))) x,
hg :
  ∀ (x : ι),
    (λ (i : ι) (b : set.{?l_2} (set.{?l_2} (π i))),
       and (@set.countable.{?l_2} (set.{?l_2} (π i)) b)
         (and
            (not
               (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (π i)) (set.{?l_2} (set.{?l_2} (π i)))
                  (@set.has_mem.{?l_2} (set.{?l_2} (π i)))
                  (@has_emptyc.emptyc.{?l_2} (set.{?l_2} (π i)) (@set.has_emptyc.{?l_2} (π i)))
                  b))
            (@topological_space.is_topological_basis.{?l_2} (π i) (t i) b)))
      x
      (g x),
this :
  @eq.{(max (?l_1+1) (?l_2+1))} (Π (a : ι), topological_space.{?l_2} (π a)) t
    (λ (a : ι), @topological_space.generate_from.{?l_2} (π a) (g a))
⊢ ∀ (a : ι), @eq.{(max (?l_2+1) 1)} (set.{?l_2} (π a)) (@set.sUnion.{?l_2} (π a) (g a)) (@set.univ.{?l_2} (π a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>321  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>322  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>323  @[priority 100] -- see Note [lower instance priority]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>324  instance second_countable_topology.to_separable_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>325    [second_countable_topology α] : separable_space α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space.second_countable_topology'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='topological_space.separable_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 252, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [t : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [t : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A second-countable space is one with a countable basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A separable space is one with a countable dense subset.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>326  let ⟨b, hb₁, hb₂, hb₃, hb₄, eq⟩ := is_open_generated_countable_inter α in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hb₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hb₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hb₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='topological_space.is_open_generated_countable_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;line&#x27;: 284, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} (set.{u} α)) (λ (b : set.{u} (set.{u} α)), and (@set.countable.{u} (set.{u} α) b) (and (not (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) b)) (@topological_space.is_topological_basis.{u} α t b))) → @topological_space.separable_space.{u} α t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@set.countable.{u} (set.{u} α) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='not (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (t₁ : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b → ∀ (t₂ : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b → ∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) → @Exists.{u+1} (set.{u} α) (λ (t₃ : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃ (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ (α : Type u) [t : topological_space.{u} α] [_inst_1 : @topological_space.second_countable_topology.{u} α t], @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α)) (λ (b : set.{u} (set.{u} α)), and (@set.countable.{u} (set.{u} α) b) (and (not (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) b)) (@topological_space.is_topological_basis.{u} α t b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>327  have nhds_eq : ∀a, 𝓝 a = (⨅ s : {s : set α // a ∈ s ∧ s ∈ b}, principal s.val),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {ι : Type u} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {ι : Type u} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{(max (u+1) 1)} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {p : α → Prop}, @subtype.{(max (u+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>328    by intro a; rw [eq, nhds_generate_from, infi_subtype]; refl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space.nhds_generate_from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.infi_subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 657, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {g : set.{u} (set.{u} α)} {a : α}, @eq.{u+1} (filter.{u} α) (@nhds.{u} α (@topological_space.generate_from.{u} α g) a) (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α) (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (s : set.{u} α), @lattice.infi.{u 0} (filter.{u} α) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s (@set_of.{u} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s g)))) (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s (@set_of.{u} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s g)))), @filter.principal.{u} α s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {ι : Type u} [_inst_1 : lattice.complete_lattice.{u} α] {p : ι → Prop} {f : @subtype.{(max (u+1) 1)} ι p → α}, @eq.{u+1} α (@lattice.infi.{u (max (u+1) 1)} α (@subtype.{(max (u+1) 1)} ι p) (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (λ (x : @subtype.{(max (u+1) 1)} ι p), f x)) (@lattice.infi.{u (max (u+1) 1)} α ι (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (λ (i : ι), @lattice.infi.{u 0} α (p i) (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) (λ (h : p i), f (@subtype.mk.{(max (u+1) 1)} ι p i h))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b)
⊢ ∀ (a : α),
    @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α t a)
      (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α)
         (@subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ
          (s :
            @subtype.{(max (u+1) 1)} (set.{u} α)
              (λ (s : set.{u} α),
                 and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
            @filter.principal.{u} α
              (@subtype.val.{(max (u+1) 1)} (set.{u} α)
                 (λ (s : set.{u} α),
                    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                      (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                 s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
a : α
⊢ @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α t a)
    (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α)
       (@subtype.{(max (u+1) 1)} (set.{u} α)
          (λ (s : set.{u} α),
             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ
        (s :
          @subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
          @filter.principal.{u} α
            (@subtype.val.{(max (u+1) 1)} (set.{u} α)
               (λ (s : set.{u} α),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
               s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
a : α
⊢ @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α (@topological_space.generate_from.{u} α b) a)
    (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α)
       (@subtype.{(max (u+1) 1)} (set.{u} α)
          (λ (s : set.{u} α),
             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ
        (s :
          @subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
          @filter.principal.{u} α
            (@subtype.val.{(max (u+1) 1)} (set.{u} α)
               (λ (s : set.{u} α),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
               s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
a : α
⊢ @_root_.eq.{u+1} (filter.{u} α)
    (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (s : set.{u} α),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
               (@set_of.{u} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))))
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                 (@set_of.{u} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                            b)))), @filter.principal.{u} α s)))
    (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α)
       (@subtype.{(max (u+1) 1)} (set.{u} α)
          (λ (s : set.{u} α),
             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ
        (s :
          @subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
          @filter.principal.{u} α
            (@subtype.val.{(max (u+1) 1)} (set.{u} α)
               (λ (s : set.{u} α),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
               s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
a : α
⊢ @_root_.eq.{u+1} (filter.{u} α)
    (@lattice.infi.{u u+1} (filter.{u} α) (set.{u} α)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (s : set.{u} α),
          @lattice.infi.{u 0} (filter.{u} α)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
               (@set_of.{u} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))))
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ
             (H :
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                 (@set_of.{u} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                            b)))), @filter.principal.{u} α s)))
    (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α) (set.{u} α)
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ (i : set.{u} α),
          @lattice.infi.{u 0} (filter.{u} α)
            (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a i)
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i b))
            (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
            (λ
             (h :
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a i)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) i b)),
               @filter.principal.{u} α
                 (@subtype.val.{(max (u+1) 1)} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                    (@subtype.mk.{(max (u+1) 1)} (set.{u} α)
                       (λ (s : set.{u} α),
                          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                               b))
                       i
                       h)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b)
⊢ ∀ (a : α),
    @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α t a)
      (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α)
         (@subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ
          (s :
            @subtype.{(max (u+1) 1)} (set.{u} α)
              (λ (s : set.{u} α),
                 and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
            @filter.principal.{u} α
              (@subtype.val.{(max (u+1) 1)} (set.{u} α)
                 (λ (s : set.{u} α),
                    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                      (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                 s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>329  have ∀s∈b, set.nonempty s,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title=' The property `s.nonempty` expresses the fact that the set `s` is not empty. It should be used
in theorem assumptions instead of `∃ x, x ∈ s` or `s ≠ ∅` as it gives access to a nice API thanks
to the dot notation.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>330    from assume s hs, ne_empty_iff_nonempty.1 $ λ eq, absurd hs (eq.symm ▸ hb₂),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.ne_empty_iff_nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='absurd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 218, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, iff (@ne.{(max (u+1) 1)} (set.{u} α) s (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))) (@set.nonempty.{u} α s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@eq.{(max (u+1) 1)} (set.{u} α) s (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {a : Prop} {b : Sort v}, a → not a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{(max (u+1) 1)} (set.{u} α) s (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : α}, @eq.{(max (u+1) 1)} α a b → @eq.{(max (u+1) 1)} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{(max (u+1) 1)} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>331  have ∃f:∀s∈b, α, ∀s h, f s h ∈ s, by simpa only [skolem, set.nonempty] using this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='classical.skolem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 134, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (s : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {b : α → Sort ?l_2} {p : Π (x : α), b x → Prop}, iff (∀ (x : α), @Exists.{?l_2} (b x) (λ (y : b x), p x y)) (@Exists.{(imax ?l_1 ?l_2)} (Π (x : α), b x) (λ (f : Π (x : α), b x), ∀ (x : α), p x (f x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, set.{?l_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (s : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → @set.nonempty.{u} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' The property `s.nonempty` expresses the fact that the set `s` is not empty. It should be used
in theorem assumptions instead of `∃ x, x ∈ s` or `s ≠ ∅` as it gives access to a nice API thanks
to the dot notation.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
nhds_eq :
  ∀ (a : α),
    @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α t a)
      (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α)
         (@subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ
          (s :
            @subtype.{(max (u+1) 1)} (set.{u} α)
              (λ (s : set.{u} α),
                 and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
            @filter.principal.{u} α
              (@subtype.val.{(max (u+1) 1)} (set.{u} α)
                 (λ (s : set.{u} α),
                    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                      (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                 s))),
this :
  ∀ (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b →
    @set.nonempty.{u} α s
⊢ @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>332  let ⟨f, hf⟩ := this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max (u+1) 1)} (∀ (s : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α) (λ (f : ∀ (s : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α), ∀ (s : set.{u} α) (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s) → @topological_space.separable_space.{u} α t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (s : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (s : set.{u} α) (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@Exists.{(max (u+1) 1)} (∀ (s : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α) (λ (f : ∀ (s : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α), ∀ (s : set.{u} α) (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>333  ⟨⟨(⋃s∈b, ⋃h:s∈b, {f s h}),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {β ι : Type u}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β ι : Type u}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {β : Type u} {ι : Prop}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {β : Type u} {ι : Prop}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>334    countable_bUnion hb₁ (λ _ _, countable_Union_Prop $ λ _, countable_singleton _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.countable_bUnion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.countable_Union_Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.countable_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 95, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {s : set.{u} α} {t : α → set.{v} β}, @set.countable.{u} α s → (∀ (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @set.countable.{v} β (t a)) → @set.countable.{v} β (@set.Union.{v u+1} β α (λ (a : α), @set.Union.{v 0} β (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (λ (H : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s), t a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) _x b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {β : Type v} {p : Prop} {t : p → set.{v} β}, (∀ (h : p), @set.countable.{v} β (t h)) → @set.countable.{v} β (@set.Union.{v 0} β p (λ (h : p), t h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) _x b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} (a : α), @set.countable.{u} α (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>335    set.ext $ assume a,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {a b : set.{u} α}, (∀ (x : α), iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x a) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x b)) → @eq.{(max (u+1) 1)} (set.{u} α) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>336    have a ∈ (⋃₀ b), by rw [hb₄]; exact trivial,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.sUnion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hb₄'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='trivial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 78, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
nhds_eq :
  ∀ (a : α),
    @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α t a)
      (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α)
         (@subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ
          (s :
            @subtype.{(max (u+1) 1)} (set.{u} α)
              (λ (s : set.{u} α),
                 and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
            @filter.principal.{u} α
              (@subtype.val.{(max (u+1) 1)} (set.{u} α)
                 (λ (s : set.{u} α),
                    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                      (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                 s))),
this :
  ∀ (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b →
    @set.nonempty.{u} α s,
this :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s),
_let_match :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s) →
  @topological_space.separable_space.{u} α t,
f :
  Π (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α,
hf :
  ∀ (s : set.{u} α) (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s,
a : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
nhds_eq :
  ∀ (a : α),
    @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α t a)
      (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α)
         (@subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ
          (s :
            @subtype.{(max (u+1) 1)} (set.{u} α)
              (λ (s : set.{u} α),
                 and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
            @filter.principal.{u} α
              (@subtype.val.{(max (u+1) 1)} (set.{u} α)
                 (λ (s : set.{u} α),
                    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                      (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                 s))),
this :
  ∀ (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b →
    @set.nonempty.{u} α s,
this :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s),
_let_match :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s) →
  @topological_space.separable_space.{u} α t,
f :
  Π (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α,
hf :
  ∀ (s : set.{u} α) (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s,
a : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
nhds_eq :
  ∀ (a : α),
    @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α t a)
      (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α)
         (@subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ
          (s :
            @subtype.{(max (u+1) 1)} (set.{u} α)
              (λ (s : set.{u} α),
                 and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
            @filter.principal.{u} α
              (@subtype.val.{(max (u+1) 1)} (set.{u} α)
                 (λ (s : set.{u} α),
                    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                      (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                 s))),
this :
  ∀ (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b →
    @set.nonempty.{u} α s,
this :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s),
_let_match :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s) →
  @topological_space.separable_space.{u} α t,
f :
  Π (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α,
hf :
  ∀ (s : set.{u} α) (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s,
a : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>337    let ⟨t, ht₁, ht₂⟩ := this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b) → iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@closure.{u} α t (@set.Union.{u u+1} α (set.{u} α) (λ (s : set.{u} α), @set.Union.{u 0} α (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b), @set.Union.{u 0} α (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b) (λ (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b), @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) (f s h))))))) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.univ.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>338    have w : {s : set α // a ∈ s ∧ s ∈ b}, from ⟨t, ht₂, ht₁⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>339    suffices (⨅ (x : {s // a ∈ s ∧ s ∈ b}), principal (x.val ∩ ⋃s (h₁ h₂ : s ∈ b), {f s h₂})) ≠ ⊥,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {α : Type u} {ι : Type u} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {ι : Type u} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@subtype.{u+1} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {p : α → Prop}, @subtype.{u+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {β ι : Type u}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {β ι : Type u}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : lattice.has_bot.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>340      by simpa only [closure_eq_nhds, nhds_eq, infi_inf w, inf_principal, mem_set_of_eq, mem_univ, iff_true],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='closure_eq_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.infi_inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.inf_principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_set_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff_true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 499, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 701, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 235, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 492, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : topological_space.{?l_1} α] {s : set.{?l_1} α}, @eq.{(max (?l_1+1) 1)} (set.{?l_1} α) (@closure.{?l_1} α _inst_1 s) (@set_of.{?l_1} α (λ (a : α), @ne.{?l_1+1} (filter.{?l_1} α) (@lattice.has_inf.inf.{?l_1} (filter.{?l_1} α) (@filter.lattice.has_inf.{?l_1} α) (@nhds.{?l_1} α _inst_1 a) (@filter.principal.{?l_1} α s)) (@lattice.has_bot.bot.{?l_1} (filter.{?l_1} α) (@lattice.order_bot.to_has_bot.{?l_1} (filter.{?l_1} α) (@lattice.bounded_lattice.to_order_bot.{?l_1} (filter.{?l_1} α) (@lattice.complete_lattice.to_bounded_lattice.{?l_1} (filter.{?l_1} α) (@filter.lattice.complete_lattice.{?l_1} α)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : α), @eq.{u+1} (filter.{u} α) (@nhds.{u} α t a) (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α) (@subtype.{(max (u+1) 1)} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))) (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) (λ (s : @subtype.{(max (u+1) 1)} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))), @filter.principal.{u} α (@subtype.val.{(max (u+1) 1)} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {ι : Type u} [_inst_1 : lattice.complete_lattice.{?l_1} α] {f : ι → α} {a : α}, ι → @eq.{?l_1+1} α (@lattice.has_inf.inf.{?l_1} α (@lattice.semilattice_inf.to_has_inf.{?l_1} α (@lattice.semilattice_inf_bot.to_semilattice_inf.{?l_1} α (@lattice.semilattice_inf_bot_of_bounded_lattice.{?l_1} α (@lattice.complete_lattice.to_bounded_lattice.{?l_1} α _inst_1)))) (@lattice.infi.{?l_1 (max (u+1) 1)} α ι (@lattice.complete_lattice.to_has_Inf.{?l_1} α _inst_1) (λ (x : ι), f x)) a) (@lattice.infi.{?l_1 (max (u+1) 1)} α ι (@lattice.complete_lattice.to_has_Inf.{?l_1} α _inst_1) (λ (x : ι), @lattice.has_inf.inf.{?l_1} α (@lattice.semilattice_inf.to_has_inf.{?l_1} α (@lattice.semilattice_inf_bot.to_semilattice_inf.{?l_1} α (@lattice.semilattice_inf_bot_of_bounded_lattice.{?l_1} α (@lattice.complete_lattice.to_bounded_lattice.{?l_1} α _inst_1)))) (f x) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@subtype.{(max (u+1) 1)} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {s t : set.{?l_1} α}, @eq.{?l_1+1} (filter.{?l_1} α) (@lattice.has_inf.inf.{?l_1} (filter.{?l_1} α) (@filter.lattice.has_inf.{?l_1} α) (@filter.principal.{?l_1} α s) (@filter.principal.{?l_1} α t)) (@filter.principal.{?l_1} α (@has_inter.inter.{?l_1} (set.{?l_1} α) (@set.has_inter.{?l_1} α) s t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {a : α} {p : α → Prop}, @eq.{1} Prop (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@set_of.{?l_1} α (λ (a : α), p a))) (p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (x : α), @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x (@set.univ.{?l_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : Prop), iff (iff a true) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
nhds_eq :
  ∀ (a : α),
    @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α t a)
      (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α)
         (@subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ
          (s :
            @subtype.{(max (u+1) 1)} (set.{u} α)
              (λ (s : set.{u} α),
                 and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
            @filter.principal.{u} α
              (@subtype.val.{(max (u+1) 1)} (set.{u} α)
                 (λ (s : set.{u} α),
                    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                      (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                 s))),
this :
  ∀ (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b →
    @set.nonempty.{u} α s,
this :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s),
_let_match :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s) →
  @topological_space.separable_space.{u} α t,
f :
  Π (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α,
hf :
  ∀ (s : set.{u} α) (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s,
a : α,
this : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b) →
  iff
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@closure.{u} α t
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h)))))))
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.univ.{u} α)),
t : set.{u} α,
ht₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b,
ht₂ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t,
w :
  @subtype.{(max (u+1) 1)} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
this :
  @ne.{u+1} (filter.{u} α)
    (@lattice.infi.{u (max 1 (u+1))} (filter.{u} α)
       (@subtype.{u+1} (set.{u} α)
          (λ (s : set.{u} α),
             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
       (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
       (λ
        (x :
          @subtype.{u+1} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
          @filter.principal.{u} α
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
               (@subtype.val.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                  x)
               (@set.Union.{u u+1} α (set.{u} α)
                  (λ (s : set.{u} α),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₁ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @set.Union.{u 0} α
                            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                            (λ
                             (h₂ :
                               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                 b),
                               @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                 (f s h₂))))))))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))
⊢ iff
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@closure.{u} α t
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h)))))))
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.univ.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>341    infi_ne_bot_of_directed ⟨a⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.infi_ne_bot_of_directed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {ι : Sort x} {f : ι → filter.{u} α}, nonempty.{u+1} α → @directed.{u x} (filter.{u} α) (@ge.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))) ι f → (∀ (i : ι), @ne.{u+1} (filter.{u} α) (f i) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)))))) → @ne.{u+1} (filter.{u} α) (@lattice.infi.{u x} (filter.{u} α) ι (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) f) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' If `f : ι → filter α` is derected, `α` is not empty, and `∀ i, f i ≠ ⊥`, then `infi f ≠ ⊥`.
See also `infi_ne_bot_of_directed&#x27;` for a version assuming `nonempty ι` instead of `nonempty α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>342      (assume ⟨s₁, has₁, hs₁⟩ ⟨s₂, has₂, hs₂⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@subtype.{u+1} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@subtype.{u+1} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>343        have a ∈ s₁ ∩ s₂, from ⟨has₁, has₂⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>344        let ⟨s₃, hs₃, has₃, hs⟩ := hb₃ _ hs₁ _ hs₂ _ this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@Exists.{u+1} (set.{u} α) (λ (t₃ : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t₃) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃ (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂)))) → @Exists.{(max 1 (u+1))} (@subtype.{u+1} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))) (λ (z : @subtype.{u+1} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))), and (@ge.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) ((λ (x : @subtype.{u+1} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))), @filter.principal.{u} α (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@subtype.val.{u+1} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)) x) (@set.Union.{u u+1} α (set.{u} α) (λ (s : set.{u} α), @set.Union.{u 0} α (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b) (λ (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b), @set.Union.{u 0} α (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b) (λ (h₂ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b), @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) (f s h₂))))))) (@subtype.mk.{u+1} . (set.{u} α) . (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)) s₁ (@and.intro . (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁) . (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b) has₁ hs₁))) ((λ (x : @subtype.{u+1} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))), @filter.principal.{u} α (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@subtype.val.{u+1} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)) x) (@set.Union.{u u+1} α (set.{u} α) (λ (s : set.{u} α), @set.Union.{u 0} α (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b) (λ (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b), @set.Union.{u 0} α (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b) (λ (h₂ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b), @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) (f s h₂))))))) z)) (@ge.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) ((λ (x : @subtype.{u+1} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))), @filter.principal.{u} α (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@subtype.val.{u+1} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)) x) (@set.Union.{u u+1} α (set.{u} α) (λ (s : set.{u} α), @set.Union.{u 0} α (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b) (λ (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b), @set.Union.{u 0} α (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b) (λ (h₂ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b), @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) (f s h₂))))))) (@subtype.mk.{u+1} . (set.{u} α) . (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)) s₂ (@and.intro . (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂) . (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b) has₂ hs₂))) ((λ (x : @subtype.{u+1} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))), @filter.principal.{u} α (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@subtype.val.{u+1} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)) x) (@set.Union.{u u+1} α (set.{u} α) (λ (s : set.{u} α), @set.Union.{u 0} α (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b) (λ (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b), @set.Union.{u 0} α (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b) (λ (h₂ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b), @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) (f s h₂))))))) z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₃ b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>345        ⟨⟨s₃, has₃, hs₃⟩, begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
nhds_eq :
  ∀ (a : α),
    @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α t a)
      (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α)
         (@subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ
          (s :
            @subtype.{(max (u+1) 1)} (set.{u} α)
              (λ (s : set.{u} α),
                 and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
            @filter.principal.{u} α
              (@subtype.val.{(max (u+1) 1)} (set.{u} α)
                 (λ (s : set.{u} α),
                    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                      (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                 s))),
this :
  ∀ (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b →
    @set.nonempty.{u} α s,
this :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s),
_let_match :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s) →
  @topological_space.separable_space.{u} α t,
f :
  Π (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α,
hf :
  ∀ (s : set.{u} α) (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s,
a : α,
this : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b) →
  iff
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@closure.{u} α t
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h)))))))
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.univ.{u} α)),
t : set.{u} α,
ht₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b,
ht₂ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t,
w :
  @subtype.{(max (u+1) 1)} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_x :
  @subtype.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_fun_match :
  ∀
  (_a y :
    @subtype.{u+1} (set.{u} α)
      (λ (s : set.{u} α),
         and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
           (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
    @Exists.{(max 1 (u+1))}
      (@subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
      (λ
       (z :
         @subtype.{u+1} (set.{u} α)
           (λ (s : set.{u} α),
              and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
         and
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 _a)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 y)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))),
s₁ : set.{u} α,
has₁ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁,
hs₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b,
_x :
  @subtype.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_fun_match :
  ∀
  (_a :
    @subtype.{u+1} (set.{u} α)
      (λ (s : set.{u} α),
         and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
           (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
    @Exists.{(max 1 (u+1))}
      (@subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
      (λ
       (z :
         @subtype.{u+1} (set.{u} α)
           (λ (s : set.{u} α),
              and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
         and
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 (@subtype.mk.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                    s₁
                    (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b)
                       has₁
                       hs₁)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 _a)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))),
s₂ : set.{u} α,
has₂ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂,
hs₂ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b,
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₃ : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t₃)
              (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                 (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂)))) →
  @Exists.{(max 1 (u+1))}
    (@subtype.{u+1} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
    (λ
     (z :
       @subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
       and
         (@ge.{u} (filter.{u} α)
            (@preorder.to_has_le.{u} (filter.{u} α)
               (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               (@subtype.mk.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                  s₁
                  (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁)
                     (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b)
                     has₁
                     hs₁)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               z))
         (@ge.{u} (filter.{u} α)
            (@preorder.to_has_le.{u} (filter.{u} α)
               (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               (@subtype.mk.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                  s₂
                  (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂)
                     (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b)
                     has₂
                     hs₂)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               z))),
s₃ : set.{u} α,
hs₃ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₃ b,
has₃ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₃,
hs :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s₃
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂)
⊢ and
    (@ge.{u} (filter.{u} α)
       (@preorder.to_has_le.{u} (filter.{u} α)
          (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
       ((λ
         (x :
           @subtype.{u+1} (set.{u} α)
             (λ (s : set.{u} α),
                and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
           @filter.principal.{u} α
             (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                (@subtype.val.{u+1} (set.{u} α)
                   (λ (s : set.{u} α),
                      and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                        (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                   x)
                (@set.Union.{u u+1} α (set.{u} α)
                   (λ (s : set.{u} α),
                      @set.Union.{u 0} α
                        (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                        (λ
                         (h₁ :
                           @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₂ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                  (f s h₂)))))))
          (@subtype.mk.{u+1} (set.{u} α)
             (λ (s : set.{u} α),
                and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
             s₁
             (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b)
                has₁
                hs₁)))
       ((λ
         (x :
           @subtype.{u+1} (set.{u} α)
             (λ (s : set.{u} α),
                and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
           @filter.principal.{u} α
             (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                (@subtype.val.{u+1} (set.{u} α)
                   (λ (s : set.{u} α),
                      and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                        (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                   x)
                (@set.Union.{u u+1} α (set.{u} α)
                   (λ (s : set.{u} α),
                      @set.Union.{u 0} α
                        (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                        (λ
                         (h₁ :
                           @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₂ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                  (f s h₂)))))))
          (@subtype.mk.{u+1} (set.{u} α)
             (λ (s : set.{u} α),
                and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
             s₃
             (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₃)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₃ b)
                has₃
                hs₃))))
    (@ge.{u} (filter.{u} α)
       (@preorder.to_has_le.{u} (filter.{u} α)
          (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
       ((λ
         (x :
           @subtype.{u+1} (set.{u} α)
             (λ (s : set.{u} α),
                and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
           @filter.principal.{u} α
             (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                (@subtype.val.{u+1} (set.{u} α)
                   (λ (s : set.{u} α),
                      and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                        (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                   x)
                (@set.Union.{u u+1} α (set.{u} α)
                   (λ (s : set.{u} α),
                      @set.Union.{u 0} α
                        (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                        (λ
                         (h₁ :
                           @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₂ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                  (f s h₂)))))))
          (@subtype.mk.{u+1} (set.{u} α)
             (λ (s : set.{u} α),
                and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
             s₂
             (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b)
                has₂
                hs₂)))
       ((λ
         (x :
           @subtype.{u+1} (set.{u} α)
             (λ (s : set.{u} α),
                and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
           @filter.principal.{u} α
             (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                (@subtype.val.{u+1} (set.{u} α)
                   (λ (s : set.{u} α),
                      and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                        (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                   x)
                (@set.Union.{u u+1} α (set.{u} α)
                   (λ (s : set.{u} α),
                      @set.Union.{u 0} α
                        (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                        (λ
                         (h₁ :
                           @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₂ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                  (f s h₂)))))))
          (@subtype.mk.{u+1} (set.{u} α)
             (λ (s : set.{u} α),
                and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
             s₃
             (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₃)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₃ b)
                has₃
                hs₃))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>346          simp only [le_principal_iff, mem_principal_sets, (≥)],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='filter.le_principal_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.mem_principal_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ge'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 374, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 194, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 371, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {s : set.{?l_1} α} {f : filter.{?l_1} α}, iff (@has_le.le.{?l_1} (filter.{?l_1} α) (@preorder.to_has_le.{?l_1} (filter.{?l_1} α) (@partial_order.to_preorder.{?l_1} (filter.{?l_1} α) (@filter.partial_order.{?l_1} α))) f (@filter.principal.{?l_1} α s)) (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} α) (filter.{?l_1} α) (@filter.has_mem.{?l_1} α) s f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {s t : set.{?l_1} α}, iff (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} α) (filter.{?l_1} α) (@filter.has_mem.{?l_1} α) s (@filter.principal.{?l_1} α t)) (@has_subset.subset.{?l_1} (set.{?l_1} α) (@set.has_subset.{?l_1} α) t s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} [_inst_1 : has_le.{?l_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
nhds_eq :
  ∀ (a : α),
    @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α t a)
      (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α)
         (@subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ
          (s :
            @subtype.{(max (u+1) 1)} (set.{u} α)
              (λ (s : set.{u} α),
                 and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
            @filter.principal.{u} α
              (@subtype.val.{(max (u+1) 1)} (set.{u} α)
                 (λ (s : set.{u} α),
                    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                      (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                 s))),
this :
  ∀ (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b →
    @set.nonempty.{u} α s,
this :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s),
_let_match :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s) →
  @topological_space.separable_space.{u} α t,
f :
  Π (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α,
hf :
  ∀ (s : set.{u} α) (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s,
a : α,
this : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b) →
  iff
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@closure.{u} α t
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h)))))))
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.univ.{u} α)),
t : set.{u} α,
ht₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b,
ht₂ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t,
w :
  @subtype.{(max (u+1) 1)} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_x :
  @subtype.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_fun_match :
  ∀
  (_a y :
    @subtype.{u+1} (set.{u} α)
      (λ (s : set.{u} α),
         and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
           (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
    @Exists.{(max 1 (u+1))}
      (@subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
      (λ
       (z :
         @subtype.{u+1} (set.{u} α)
           (λ (s : set.{u} α),
              and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
         and
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 _a)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 y)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))),
s₁ : set.{u} α,
has₁ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁,
hs₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b,
_x :
  @subtype.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_fun_match :
  ∀
  (_a :
    @subtype.{u+1} (set.{u} α)
      (λ (s : set.{u} α),
         and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
           (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
    @Exists.{(max 1 (u+1))}
      (@subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
      (λ
       (z :
         @subtype.{u+1} (set.{u} α)
           (λ (s : set.{u} α),
              and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
         and
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 (@subtype.mk.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                    s₁
                    (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b)
                       has₁
                       hs₁)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 _a)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))),
s₂ : set.{u} α,
has₂ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂,
hs₂ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b,
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₃ : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t₃)
              (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                 (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂)))) →
  @Exists.{(max 1 (u+1))}
    (@subtype.{u+1} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
    (λ
     (z :
       @subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
       and
         (@ge.{u} (filter.{u} α)
            (@preorder.to_has_le.{u} (filter.{u} α)
               (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               (@subtype.mk.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                  s₁
                  (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁)
                     (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b)
                     has₁
                     hs₁)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               z))
         (@ge.{u} (filter.{u} α)
            (@preorder.to_has_le.{u} (filter.{u} α)
               (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               (@subtype.mk.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                  s₂
                  (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂)
                     (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b)
                     has₂
                     hs₂)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               z))),
s₃ : set.{u} α,
hs₃ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₃ b,
has₃ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₃,
hs :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s₃
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂)
⊢ and
    (@ge.{u} (filter.{u} α)
       (@preorder.to_has_le.{u} (filter.{u} α)
          (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
       ((λ
         (x :
           @subtype.{u+1} (set.{u} α)
             (λ (s : set.{u} α),
                and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
           @filter.principal.{u} α
             (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                (@subtype.val.{u+1} (set.{u} α)
                   (λ (s : set.{u} α),
                      and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                        (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                   x)
                (@set.Union.{u u+1} α (set.{u} α)
                   (λ (s : set.{u} α),
                      @set.Union.{u 0} α
                        (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                        (λ
                         (h₁ :
                           @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₂ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                  (f s h₂)))))))
          (@subtype.mk.{u+1} (set.{u} α)
             (λ (s : set.{u} α),
                and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
             s₁
             (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b)
                has₁
                hs₁)))
       ((λ
         (x :
           @subtype.{u+1} (set.{u} α)
             (λ (s : set.{u} α),
                and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
           @filter.principal.{u} α
             (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                (@subtype.val.{u+1} (set.{u} α)
                   (λ (s : set.{u} α),
                      and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                        (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                   x)
                (@set.Union.{u u+1} α (set.{u} α)
                   (λ (s : set.{u} α),
                      @set.Union.{u 0} α
                        (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                        (λ
                         (h₁ :
                           @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₂ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                  (f s h₂)))))))
          (@subtype.mk.{u+1} (set.{u} α)
             (λ (s : set.{u} α),
                and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
             s₃
             (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₃)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₃ b)
                has₃
                hs₃))))
    (@ge.{u} (filter.{u} α)
       (@preorder.to_has_le.{u} (filter.{u} α)
          (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
       ((λ
         (x :
           @subtype.{u+1} (set.{u} α)
             (λ (s : set.{u} α),
                and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
           @filter.principal.{u} α
             (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                (@subtype.val.{u+1} (set.{u} α)
                   (λ (s : set.{u} α),
                      and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                        (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                   x)
                (@set.Union.{u u+1} α (set.{u} α)
                   (λ (s : set.{u} α),
                      @set.Union.{u 0} α
                        (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                        (λ
                         (h₁ :
                           @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₂ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                  (f s h₂)))))))
          (@subtype.mk.{u+1} (set.{u} α)
             (λ (s : set.{u} α),
                and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
             s₂
             (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b)
                has₂
                hs₂)))
       ((λ
         (x :
           @subtype.{u+1} (set.{u} α)
             (λ (s : set.{u} α),
                and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
           @filter.principal.{u} α
             (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                (@subtype.val.{u+1} (set.{u} α)
                   (λ (s : set.{u} α),
                      and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                        (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                   x)
                (@set.Union.{u u+1} α (set.{u} α)
                   (λ (s : set.{u} α),
                      @set.Union.{u 0} α
                        (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                        (λ
                         (h₁ :
                           @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₂ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                  (f s h₂)))))))
          (@subtype.mk.{u+1} (set.{u} α)
             (λ (s : set.{u} α),
                and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
             s₃
             (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₃)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₃ b)
                has₃
                hs₃))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
nhds_eq :
  ∀ (a : α),
    @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α t a)
      (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α)
         (@subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ
          (s :
            @subtype.{(max (u+1) 1)} (set.{u} α)
              (λ (s : set.{u} α),
                 and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
            @filter.principal.{u} α
              (@subtype.val.{(max (u+1) 1)} (set.{u} α)
                 (λ (s : set.{u} α),
                    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                      (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                 s))),
this :
  ∀ (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b →
    @set.nonempty.{u} α s,
this :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s),
_let_match :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s) →
  @topological_space.separable_space.{u} α t,
f :
  Π (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α,
hf :
  ∀ (s : set.{u} α) (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s,
a : α,
this : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b) →
  iff
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@closure.{u} α t
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h)))))))
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.univ.{u} α)),
t : set.{u} α,
ht₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b,
ht₂ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t,
w :
  @subtype.{(max (u+1) 1)} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_x :
  @subtype.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_fun_match :
  ∀
  (_a y :
    @subtype.{u+1} (set.{u} α)
      (λ (s : set.{u} α),
         and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
           (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
    @Exists.{(max 1 (u+1))}
      (@subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
      (λ
       (z :
         @subtype.{u+1} (set.{u} α)
           (λ (s : set.{u} α),
              and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
         and
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 _a)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 y)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))),
s₁ : set.{u} α,
has₁ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁,
hs₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b,
_x :
  @subtype.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_fun_match :
  ∀
  (_a :
    @subtype.{u+1} (set.{u} α)
      (λ (s : set.{u} α),
         and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
           (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
    @Exists.{(max 1 (u+1))}
      (@subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
      (λ
       (z :
         @subtype.{u+1} (set.{u} α)
           (λ (s : set.{u} α),
              and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
         and
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 (@subtype.mk.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                    s₁
                    (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b)
                       has₁
                       hs₁)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 _a)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))),
s₂ : set.{u} α,
has₂ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂,
hs₂ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b,
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₃ : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t₃)
              (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                 (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂)))) →
  @Exists.{(max 1 (u+1))}
    (@subtype.{u+1} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
    (λ
     (z :
       @subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
       and
         (@ge.{u} (filter.{u} α)
            (@preorder.to_has_le.{u} (filter.{u} α)
               (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               (@subtype.mk.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                  s₁
                  (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁)
                     (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b)
                     has₁
                     hs₁)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               z))
         (@ge.{u} (filter.{u} α)
            (@preorder.to_has_le.{u} (filter.{u} α)
               (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               (@subtype.mk.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                  s₂
                  (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂)
                     (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b)
                     has₂
                     hs₂)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               z))),
s₃ : set.{u} α,
hs₃ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₃ b,
has₃ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₃,
hs :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s₃
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂)
⊢ and
    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₃
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂))))))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂)))))))
    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₃
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂))))))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₂
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>347          simp only [subset_inter_iff] at hs, split;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='set.subset_inter_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 392, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {s t r : set.{?l_1} α}, iff (@has_subset.subset.{?l_1} (set.{?l_1} α) (@set.has_subset.{?l_1} α) r (@has_inter.inter.{?l_1} (set.{?l_1} α) (@set.has_inter.{?l_1} α) s t)) (and (@has_subset.subset.{?l_1} (set.{?l_1} α) (@set.has_subset.{?l_1} α) r s) (@has_subset.subset.{?l_1} (set.{?l_1} α) (@set.has_subset.{?l_1} α) r t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
nhds_eq :
  ∀ (a : α),
    @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α t a)
      (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α)
         (@subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ
          (s :
            @subtype.{(max (u+1) 1)} (set.{u} α)
              (λ (s : set.{u} α),
                 and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
            @filter.principal.{u} α
              (@subtype.val.{(max (u+1) 1)} (set.{u} α)
                 (λ (s : set.{u} α),
                    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                      (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                 s))),
this :
  ∀ (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b →
    @set.nonempty.{u} α s,
this :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s),
_let_match :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s) →
  @topological_space.separable_space.{u} α t,
f :
  Π (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α,
hf :
  ∀ (s : set.{u} α) (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s,
a : α,
this : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b) →
  iff
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@closure.{u} α t
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h)))))))
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.univ.{u} α)),
t : set.{u} α,
ht₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b,
ht₂ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t,
w :
  @subtype.{(max (u+1) 1)} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_x :
  @subtype.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_fun_match :
  ∀
  (_a y :
    @subtype.{u+1} (set.{u} α)
      (λ (s : set.{u} α),
         and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
           (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
    @Exists.{(max 1 (u+1))}
      (@subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
      (λ
       (z :
         @subtype.{u+1} (set.{u} α)
           (λ (s : set.{u} α),
              and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
         and
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 _a)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 y)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))),
s₁ : set.{u} α,
has₁ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁,
hs₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b,
_x :
  @subtype.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_fun_match :
  ∀
  (_a :
    @subtype.{u+1} (set.{u} α)
      (λ (s : set.{u} α),
         and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
           (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
    @Exists.{(max 1 (u+1))}
      (@subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
      (λ
       (z :
         @subtype.{u+1} (set.{u} α)
           (λ (s : set.{u} α),
              and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
         and
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 (@subtype.mk.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                    s₁
                    (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b)
                       has₁
                       hs₁)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 _a)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))),
s₂ : set.{u} α,
has₂ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂,
hs₂ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b,
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₃ : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t₃)
              (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                 (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂)))) →
  @Exists.{(max 1 (u+1))}
    (@subtype.{u+1} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
    (λ
     (z :
       @subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
       and
         (@ge.{u} (filter.{u} α)
            (@preorder.to_has_le.{u} (filter.{u} α)
               (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               (@subtype.mk.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                  s₁
                  (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁)
                     (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b)
                     has₁
                     hs₁)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               z))
         (@ge.{u} (filter.{u} α)
            (@preorder.to_has_le.{u} (filter.{u} α)
               (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               (@subtype.mk.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                  s₂
                  (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂)
                     (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b)
                     has₂
                     hs₂)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               z))),
s₃ : set.{u} α,
hs₃ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₃ b,
has₃ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₃,
hs :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s₃
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂)
⊢ and
    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₃
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂))))))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂)))))))
    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₃
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂))))))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₂
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
nhds_eq :
  ∀ (a : α),
    @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α t a)
      (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α)
         (@subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ
          (s :
            @subtype.{(max (u+1) 1)} (set.{u} α)
              (λ (s : set.{u} α),
                 and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
            @filter.principal.{u} α
              (@subtype.val.{(max (u+1) 1)} (set.{u} α)
                 (λ (s : set.{u} α),
                    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                      (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                 s))),
this :
  ∀ (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b →
    @set.nonempty.{u} α s,
this :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s),
_let_match :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s) →
  @topological_space.separable_space.{u} α t,
f :
  Π (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α,
hf :
  ∀ (s : set.{u} α) (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s,
a : α,
this : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b) →
  iff
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@closure.{u} α t
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h)))))))
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.univ.{u} α)),
t : set.{u} α,
ht₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b,
ht₂ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t,
w :
  @subtype.{(max (u+1) 1)} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_x :
  @subtype.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_fun_match :
  ∀
  (_a y :
    @subtype.{u+1} (set.{u} α)
      (λ (s : set.{u} α),
         and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
           (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
    @Exists.{(max 1 (u+1))}
      (@subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
      (λ
       (z :
         @subtype.{u+1} (set.{u} α)
           (λ (s : set.{u} α),
              and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
         and
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 _a)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 y)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))),
s₁ : set.{u} α,
has₁ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁,
hs₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b,
_x :
  @subtype.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_fun_match :
  ∀
  (_a :
    @subtype.{u+1} (set.{u} α)
      (λ (s : set.{u} α),
         and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
           (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
    @Exists.{(max 1 (u+1))}
      (@subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
      (λ
       (z :
         @subtype.{u+1} (set.{u} α)
           (λ (s : set.{u} α),
              and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
         and
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 (@subtype.mk.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                    s₁
                    (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b)
                       has₁
                       hs₁)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 _a)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))),
s₂ : set.{u} α,
has₂ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂,
hs₂ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b,
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₃ : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t₃)
              (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                 (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂)))) →
  @Exists.{(max 1 (u+1))}
    (@subtype.{u+1} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
    (λ
     (z :
       @subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
       and
         (@ge.{u} (filter.{u} α)
            (@preorder.to_has_le.{u} (filter.{u} α)
               (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               (@subtype.mk.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                  s₁
                  (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁)
                     (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b)
                     has₁
                     hs₁)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               z))
         (@ge.{u} (filter.{u} α)
            (@preorder.to_has_le.{u} (filter.{u} α)
               (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               (@subtype.mk.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                  s₂
                  (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂)
                     (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b)
                     has₂
                     hs₂)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               z))),
s₃ : set.{u} α,
hs₃ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₃ b,
has₃ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₃,
hs :
  and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s₃ s₁)
    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s₃ s₂)
⊢ and
    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₃
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂))))))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂)))))))
    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₃
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂))))))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₂
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>348            apply inter_subset_inter_left; simp only [hs]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='set.inter_subset_inter_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 402, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α} (u : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s u) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s₃ s₁) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s₃ s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
nhds_eq :
  ∀ (a : α),
    @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α t a)
      (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α)
         (@subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ
          (s :
            @subtype.{(max (u+1) 1)} (set.{u} α)
              (λ (s : set.{u} α),
                 and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
            @filter.principal.{u} α
              (@subtype.val.{(max (u+1) 1)} (set.{u} α)
                 (λ (s : set.{u} α),
                    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                      (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                 s))),
this :
  ∀ (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b →
    @set.nonempty.{u} α s,
this :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s),
_let_match :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s) →
  @topological_space.separable_space.{u} α t,
f :
  Π (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α,
hf :
  ∀ (s : set.{u} α) (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s,
a : α,
this : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b) →
  iff
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@closure.{u} α t
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h)))))))
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.univ.{u} α)),
t : set.{u} α,
ht₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b,
ht₂ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t,
w :
  @subtype.{(max (u+1) 1)} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_x :
  @subtype.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_fun_match :
  ∀
  (_a y :
    @subtype.{u+1} (set.{u} α)
      (λ (s : set.{u} α),
         and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
           (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
    @Exists.{(max 1 (u+1))}
      (@subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
      (λ
       (z :
         @subtype.{u+1} (set.{u} α)
           (λ (s : set.{u} α),
              and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
         and
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 _a)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 y)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))),
s₁ : set.{u} α,
has₁ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁,
hs₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b,
_x :
  @subtype.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_fun_match :
  ∀
  (_a :
    @subtype.{u+1} (set.{u} α)
      (λ (s : set.{u} α),
         and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
           (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
    @Exists.{(max 1 (u+1))}
      (@subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
      (λ
       (z :
         @subtype.{u+1} (set.{u} α)
           (λ (s : set.{u} α),
              and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
         and
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 (@subtype.mk.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                    s₁
                    (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b)
                       has₁
                       hs₁)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 _a)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))),
s₂ : set.{u} α,
has₂ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂,
hs₂ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b,
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₃ : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t₃)
              (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                 (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂)))) →
  @Exists.{(max 1 (u+1))}
    (@subtype.{u+1} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
    (λ
     (z :
       @subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
       and
         (@ge.{u} (filter.{u} α)
            (@preorder.to_has_le.{u} (filter.{u} α)
               (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               (@subtype.mk.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                  s₁
                  (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁)
                     (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b)
                     has₁
                     hs₁)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               z))
         (@ge.{u} (filter.{u} α)
            (@preorder.to_has_le.{u} (filter.{u} α)
               (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               (@subtype.mk.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                  s₂
                  (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂)
                     (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b)
                     has₂
                     hs₂)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               z))),
s₃ : set.{u} α,
hs₃ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₃ b,
has₃ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₃,
hs :
  and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s₃ s₁)
    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s₃ s₂)
⊢ and
    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₃
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂))))))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂)))))))
    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₃
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂))))))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₂
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>349        end⟩)</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @topological_space.separable_space.{u} α t,
b : set.{u} (set.{u} α),
hb₁ : @set.countable.{u} (set.{u} α) b,
hb₂ :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       b),
hb₃ :
  ∀ (t₁ : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₁ b →
    ∀ (t₂ : set.{u} α),
      @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₂ b →
      ∀ (x : α),
        @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) →
        @Exists.{u+1} (set.{u} α)
          (λ (t₃ : set.{u} α),
             @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
               (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
                  and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t₃)
                    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)))),
hb₄ : @_root_.eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α b) (@set.univ.{u} α),
eq : @_root_.eq.{u+1} (topological_space.{u} α) t (@topological_space.generate_from.{u} α b),
nhds_eq :
  ∀ (a : α),
    @_root_.eq.{u+1} (filter.{u} α) (@nhds.{u} α t a)
      (@lattice.infi.{u (max (u+1) 1)} (filter.{u} α)
         (@subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (s : set.{u} α),
               and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
         (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))
         (λ
          (s :
            @subtype.{(max (u+1) 1)} (set.{u} α)
              (λ (s : set.{u} α),
                 and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
            @filter.principal.{u} α
              (@subtype.val.{(max (u+1) 1)} (set.{u} α)
                 (λ (s : set.{u} α),
                    and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                      (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                 s))),
this :
  ∀ (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b →
    @set.nonempty.{u} α s,
this :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s),
_let_match :
  @Exists.{(max (u+1) 1)}
    (Π (s : set.{u} α),
       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α)
    (λ
     (f :
       Π (s : set.{u} α),
         @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α),
       ∀ (s : set.{u} α)
       (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
         @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s) →
  @topological_space.separable_space.{u} α t,
f :
  Π (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b → α,
hf :
  ∀ (s : set.{u} α) (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (f s h) s,
a : α,
this : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.sUnion.{u} α b) →
  iff
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@closure.{u} α t
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h)))))))
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.univ.{u} α)),
t : set.{u} α,
ht₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t b,
ht₂ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t,
w :
  @subtype.{(max (u+1) 1)} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_x :
  @subtype.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_fun_match :
  ∀
  (_a y :
    @subtype.{u+1} (set.{u} α)
      (λ (s : set.{u} α),
         and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
           (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
    @Exists.{(max 1 (u+1))}
      (@subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
      (λ
       (z :
         @subtype.{u+1} (set.{u} α)
           (λ (s : set.{u} α),
              and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
         and
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 _a)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 y)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))),
s₁ : set.{u} α,
has₁ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁,
hs₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b,
_x :
  @subtype.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)),
_fun_match :
  ∀
  (_a :
    @subtype.{u+1} (set.{u} α)
      (λ (s : set.{u} α),
         and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
           (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
    @Exists.{(max 1 (u+1))}
      (@subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
      (λ
       (z :
         @subtype.{u+1} (set.{u} α)
           (λ (s : set.{u} α),
              and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
         and
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 (@subtype.mk.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                    s₁
                    (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b)
                       has₁
                       hs₁)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))
           (@ge.{u} (filter.{u} α)
              (@preorder.to_has_le.{u} (filter.{u} α)
                 (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 _a)
              ((λ
                (x :
                  @subtype.{u+1} (set.{u} α)
                    (λ (s : set.{u} α),
                       and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                         (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                  @filter.principal.{u} α
                    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                       (@subtype.val.{u+1} (set.{u} α)
                          (λ (s : set.{u} α),
                             and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b))
                          x)
                       (@set.Union.{u u+1} α (set.{u} α)
                          (λ (s : set.{u} α),
                             @set.Union.{u 0} α
                               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b)
                               (λ
                                (h₁ :
                                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                                    s
                                    b),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b)
                                    (λ
                                     (h₂ :
                                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                         (@set.has_mem.{u} (set.{u} α))
                                         s
                                         b),
                                       @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α)
                                         (@set.has_insert.{u} α)
                                         (f s h₂)))))))
                 z))),
s₂ : set.{u} α,
has₂ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂,
hs₂ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b,
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₃ : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b)
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t₃ b),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t₃)
              (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t₃
                 (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂)))) →
  @Exists.{(max 1 (u+1))}
    (@subtype.{u+1} (set.{u} α)
       (λ (s : set.{u} α),
          and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)))
    (λ
     (z :
       @subtype.{u+1} (set.{u} α)
         (λ (s : set.{u} α),
            and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
              (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
       and
         (@ge.{u} (filter.{u} α)
            (@preorder.to_has_le.{u} (filter.{u} α)
               (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               (@subtype.mk.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                  s₁
                  (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₁)
                     (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₁ b)
                     has₁
                     hs₁)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               z))
         (@ge.{u} (filter.{u} α)
            (@preorder.to_has_le.{u} (filter.{u} α)
               (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               (@subtype.mk.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))
                  s₂
                  (@and.intro (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₂)
                     (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₂ b)
                     has₂
                     hs₂)))
            ((λ
              (x :
                @subtype.{u+1} (set.{u} α)
                  (λ (s : set.{u} α),
                     and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))),
                @filter.principal.{u} α
                  (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                     (@subtype.val.{u+1} (set.{u} α)
                        (λ (s : set.{u} α),
                           and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b))
                        x)
                     (@set.Union.{u u+1} α (set.{u} α)
                        (λ (s : set.{u} α),
                           @set.Union.{u 0} α
                             (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                b)
                             (λ
                              (h₁ :
                                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s
                                  b),
                                @set.Union.{u 0} α
                                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                     (@set.has_mem.{u} (set.{u} α))
                                     s
                                     b)
                                  (λ
                                   (h₂ :
                                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α))
                                       (@set.has_mem.{u} (set.{u} α))
                                       s
                                       b),
                                     @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                                       (f s h₂)))))))
               z))),
s₃ : set.{u} α,
hs₃ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s₃ b,
has₃ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s₃,
hs :
  and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s₃ s₁)
    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s₃ s₂)
⊢ and
    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₃
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂))))))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂)))))))
    (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₃
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂))))))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₂
          (@set.Union.{u u+1} α (set.{u} α)
             (λ (s : set.{u} α),
                @set.Union.{u 0} α
                  (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                  (λ
                   (h₁ : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                     @set.Union.{u 0} α
                       (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b)
                       (λ
                        (h₂ :
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b),
                          @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α)
                            (f s h₂)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>350      (assume ⟨s, has, hs⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@subtype.{u+1} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>351        have (s ∩ (⋃ (s : set α) (H h : s ∈ b), {f s h})).nonempty,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type u} {ι : Type u}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {β : Type u} {ι : Type u}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title=' The property `s.nonempty` expresses the fact that the set `s` is not empty. It should be used
in theorem assumptions instead of `∃ x, x ∈ s` or `s ≠ ∅` as it gives access to a nice API thanks
to the dot notation.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>352          from ⟨_, hf _ hs, mem_bUnion hs $ mem_Union.mpr ⟨hs, mem_singleton _⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='set.mem_bUnion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.mem_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.mem_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 200, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 516, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {s : set.{u} α} {t : α → set.{v} β} {x : α} {y : β}, @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s → @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) y (t x) → @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) y (@set.Union.{v u+1} β α (λ (x : α), @set.Union.{v 0} β (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s) (λ (H : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s), t x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {β : Type u} {ι : Prop} {x : β} {s : ι → set.{u} β}, iff (@has_mem.mem.{u u} β (set.{u} β) (@set.has_mem.{u} β) x (@set.Union.{u 0} β ι s)) (@Exists.{0} ι (λ (i : ι), @has_mem.mem.{u u} β (set.{u} β) (@set.has_mem.{u} β) x (s i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u} (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>353        principal_ne_bot_iff.2 this) ⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='filter.principal_ne_bot_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 723, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, iff (@ne.{u+1} (filter.{u} α) (@filter.principal.{u} α s) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)))))) (@set.nonempty.{u} α s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@set.nonempty.{u} α (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.Union.{u (max (u+1) 1)} α (set.{u} α) (λ (s : set.{u} α), @set.Union.{u 0} α (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b), @set.Union.{u 0} α (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b) (λ (h : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s b), @singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) (f s h))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>354  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>355  variables {α}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>356  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>357  lemma is_open_Union_countable [second_countable_topology α]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='topological_space.second_countable_topology'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π (α : Type u) [t : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='A second-countable space is one with a countable basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>358    {ι} (s : ι → set α) (H : ∀ i, _root_.is_open (s i)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>359    ∃ T : set ι, countable T ∧ (⋃ i ∈ T, s i) = ⋃ i, s i :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.countable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type u} {ι : Type u_1}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u_1} ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {β : Type u} {ι : Type u_1}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {β : Type u} {ι : Type u_1}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {β : Type u} {ι : Type u_1}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title=' Countable sets

A set is countable if there exists an encoding of the set into the natural numbers.
An encoding is an injection with a partial inverse, which can be viewed as a
constructive analogue of countability. (For the most part, theorems about
`countable` will be classical and `encodable` will be constructive.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>360  let ⟨B, cB, _, bB⟩ := is_open_generated_countable_inter α in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='topological_space.is_open_generated_countable_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 284, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} (set.{u} α)) (λ (b : set.{u} (set.{u} α)), and (@set.countable.{u} (set.{u} α) b) (and (not (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) b)) (@topological_space.is_topological_basis.{u} α t b))) → @Exists.{(max (u_1+1) 1)} (set.{u_1} ι) (λ (T : set.{u_1} ι), and (@set.countable.{u_1} ι T) (@eq.{(max (u+1) 1)} (set.{u} α) (@set.Union.{u u_1+1} α ι (λ (i : ι), @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T) (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i))) (@set.Union.{u u_1+1} α ι (λ (i : ι), s i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='∀ (α : Type u) [t : topological_space.{u} α] [_inst_1 : @topological_space.second_countable_topology.{u} α t], @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α)) (λ (b : set.{u} (set.{u} α)), and (@set.countable.{u} (set.{u} α) b) (and (not (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) b)) (@topological_space.is_topological_basis.{u} α t b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>361  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
ι : Type u_1,
s : ι → set.{u} α,
H : ∀ (i : ι), @is_open.{u} α t (s i),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i)))),
B : set.{u} (set.{u} α),
cB : @set.countable.{u} (set.{u} α) B,
_x :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       B),
bB : @topological_space.is_topological_basis.{u} α t B
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>362    let B&#x27; := {b ∈ B | ∃ i, b ⊆ s i},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='has_sep.sep'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u} [c : has_sep.{u u} α γ], (α → Prop) → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
ι : Type u_1,
s : ι → set.{u} α,
H : ∀ (i : ι), @is_open.{u} α t (s i),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i)))),
B : set.{u} (set.{u} α),
cB : @set.countable.{u} (set.{u} α) B,
_x :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       B),
bB : @topological_space.is_topological_basis.{u} α t B
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
ι : Type u_1,
s : ι → set.{u} α,
H : ∀ (i : ι), @is_open.{u} α t (s i),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i)))),
B : set.{u} (set.{u} α),
cB : @set.countable.{u} (set.{u} α) B,
_x :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       B),
bB : @topological_space.is_topological_basis.{u} α t B,
B&#x27; : set.{u} (set.{u} α) :=
  @has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α))
    (λ (b : set.{u} α),
       @Exists.{u_1+1} ι (λ (i : ι), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b (s i)))
    B
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>363    choose f hf using λ b:B&#x27;, b.2.2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='B&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
ι : Type u_1,
s : ι → set.{u} α,
H : ∀ (i : ι), @is_open.{u} α t (s i),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i)))),
B : set.{u} (set.{u} α),
cB : @set.countable.{u} (set.{u} α) B,
_x :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       B),
bB : @topological_space.is_topological_basis.{u} α t B,
B&#x27; : set.{u} (set.{u} α) :=
  @has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α))
    (λ (b : set.{u} α),
       @Exists.{u_1+1} ι (λ (i : ι), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b (s i)))
    B
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
ι : Type u_1,
s : ι → set.{u} α,
H : ∀ (i : ι), @is_open.{u} α t (s i),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i)))),
B : set.{u} (set.{u} α),
cB : @set.countable.{u} (set.{u} α) B,
_x :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       B),
bB : @topological_space.is_topological_basis.{u} α t B,
B&#x27; : set.{u} (set.{u} α) :=
  @has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α))
    (λ (b : set.{u} α),
       @Exists.{u_1+1} ι (λ (i : ι), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b (s i)))
    B,
f : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27; → ι,
hf :
  ∀ (b : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
    @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
      (@subtype.val.{u+1} (set.{u} α)
         (λ (x : set.{u} α),
            @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B&#x27;)
         b)
      (s (f b))
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>364    haveI : encodable B&#x27; := (countable_subset (sep_subset _ _) cB).to_encodable,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='encodable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.countable_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.sep_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='cB'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/encodable.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 578, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {s₁ s₂ : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s₁ s₂ → @set.countable.{u} α s₂ → @set.countable.{u} α s₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} (s : set.{u} α) (p : α → Prop), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_sep.sep.{u u} α (set.{u} α) (@set.has_sep.{u} α) (λ (x : α), p x) s) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@set.countable.{u} (set.{u} α) B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An encodable type is a &quot;constructively countable&quot; type. This is where
 we have an explicit injection `encode : α → nat` and a partial inverse
 `decode : nat → option α`. This makes the range of `encode` decidable,
 although it is not decidable if `α` is finite or not.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
ι : Type u_1,
s : ι → set.{u} α,
H : ∀ (i : ι), @is_open.{u} α t (s i),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i)))),
B : set.{u} (set.{u} α),
cB : @set.countable.{u} (set.{u} α) B,
_x :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       B),
bB : @topological_space.is_topological_basis.{u} α t B,
B&#x27; : set.{u} (set.{u} α) :=
  @has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α))
    (λ (b : set.{u} α),
       @Exists.{u_1+1} ι (λ (i : ι), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b (s i)))
    B,
f : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27; → ι,
hf :
  ∀ (b : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
    @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
      (@subtype.val.{u+1} (set.{u} α)
         (λ (x : set.{u} α),
            @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B&#x27;)
         b)
      (s (f b))
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
ι : Type u_1,
s : ι → set.{u} α,
H : ∀ (i : ι), @is_open.{u} α t (s i),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i)))),
B : set.{u} (set.{u} α),
cB : @set.countable.{u} (set.{u} α) B,
_x :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       B),
bB : @topological_space.is_topological_basis.{u} α t B,
B&#x27; : set.{u} (set.{u} α) :=
  @has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α))
    (λ (b : set.{u} α),
       @Exists.{u_1+1} ι (λ (i : ι), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b (s i)))
    B,
f : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27; → ι,
hf :
  ∀ (b : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
    @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
      (@subtype.val.{u+1} (set.{u} α)
         (λ (x : set.{u} α),
            @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B&#x27;)
         b)
      (s (f b)),
_inst :
  encodable.{u}
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;)
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>365    refine ⟨_, countable_range f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='set.countable_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 106, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type u_1} [_inst_1 : encodable.{u} α] (f : α → β), @set.countable.{u_1} β (@set.range.{u_1 u+1} β α f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27; → ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
ι : Type u_1,
s : ι → set.{u} α,
H : ∀ (i : ι), @is_open.{u} α t (s i),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i)))),
B : set.{u} (set.{u} α),
cB : @set.countable.{u} (set.{u} α) B,
_x :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       B),
bB : @topological_space.is_topological_basis.{u} α t B,
B&#x27; : set.{u} (set.{u} α) :=
  @has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α))
    (λ (b : set.{u} α),
       @Exists.{u_1+1} ι (λ (i : ι), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b (s i)))
    B,
f : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27; → ι,
hf :
  ∀ (b : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
    @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
      (@subtype.val.{u+1} (set.{u} α)
         (λ (x : set.{u} α),
            @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B&#x27;)
         b)
      (s (f b)),
_inst :
  encodable.{u}
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;)
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>366      subset.antisymm (bUnion_subset_Union _ _) (sUnion_subset _)⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.subset.antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.bUnion_subset_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.sUnion_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 100, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 468, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 354, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a b → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b a → @eq.{(max (u+1) 1)} (set.{u} α) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u} (s : set.{u_1} α) (t : α → set.{u} β), @has_subset.subset.{u} (set.{u} β) (@set.has_subset.{u} β) (@set.Union.{u u_1+1} β α (λ (x : α), @set.Union.{u 0} β (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s) (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s), t x))) (@set.Union.{u u_1+1} β α (λ (x : α), t x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {S : set.{u} (set.{u} α)} {t : set.{u} α}, (∀ (t&#x27; : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t&#x27; S → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t&#x27; t) → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@set.sUnion.{u} α S) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
ι : Type u_1,
s : ι → set.{u} α,
H : ∀ (i : ι), @is_open.{u} α t (s i),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i)))),
B : set.{u} (set.{u} α),
cB : @set.countable.{u} (set.{u} α) B,
_x :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       B),
bB : @topological_space.is_topological_basis.{u} α t B,
B&#x27; : set.{u} (set.{u} α) :=
  @has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α))
    (λ (b : set.{u} α),
       @Exists.{u_1+1} ι (λ (i : ι), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b (s i)))
    B,
f : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27; → ι,
hf :
  ∀ (b : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
    @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
      (@subtype.val.{u+1} (set.{u} α)
         (λ (x : set.{u} α),
            @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B&#x27;)
         b)
      (s (f b)),
_inst :
  encodable.{u}
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;)
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
ι : Type u_1,
s : ι → set.{u} α,
H : ∀ (i : ι), @is_open.{u} α t (s i),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i)))),
B : set.{u} (set.{u} α),
cB : @set.countable.{u} (set.{u} α) B,
_x :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       B),
bB : @topological_space.is_topological_basis.{u} α t B,
B&#x27; : set.{u} (set.{u} α) :=
  @has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α))
    (λ (b : set.{u} α),
       @Exists.{u_1+1} ι (λ (i : ι), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b (s i)))
    B,
f : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27; → ι,
hf :
  ∀ (b : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
    @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
      (@subtype.val.{u+1} (set.{u} α)
         (λ (x : set.{u} α),
            @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B&#x27;)
         b)
      (s (f b)),
_inst :
  encodable.{u}
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;)
⊢ ∀ (t&#x27; : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t&#x27;
      (@set.range.{u u_1+1} (set.{u} α) ι (λ (i : ι), s i)) →
    @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t&#x27;
      (@set.Union.{u u_1+1} α ι
         (λ (i : ι),
            @set.Union.{u 0} α
              (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i
                 (@set.range.{u_1 u+1} ι
                    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       B&#x27;)
                    f))
              (λ
               (H :
                 @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i
                   (@set.range.{u_1 u+1} ι
                      (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                         (@set.has_coe_to_sort.{u} (set.{u} α))
                         B&#x27;)
                      f)), s i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>367    rintro _ ⟨i, rfl⟩ x xs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
ι : Type u_1,
s : ι → set.{u} α,
H : ∀ (i : ι), @is_open.{u} α t (s i),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i)))),
B : set.{u} (set.{u} α),
cB : @set.countable.{u} (set.{u} α) B,
_x :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       B),
bB : @topological_space.is_topological_basis.{u} α t B,
B&#x27; : set.{u} (set.{u} α) :=
  @has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α))
    (λ (b : set.{u} α),
       @Exists.{u_1+1} ι (λ (i : ι), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b (s i)))
    B,
f : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27; → ι,
hf :
  ∀ (b : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
    @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
      (@subtype.val.{u+1} (set.{u} α)
         (λ (x : set.{u} α),
            @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B&#x27;)
         b)
      (s (f b)),
_inst :
  encodable.{u}
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;)
⊢ ∀ (t&#x27; : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) t&#x27;
      (@set.range.{u u_1+1} (set.{u} α) ι (λ (i : ι), s i)) →
    @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t&#x27;
      (@set.Union.{u u_1+1} α ι
         (λ (i : ι),
            @set.Union.{u 0} α
              (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i
                 (@set.range.{u_1 u+1} ι
                    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       B&#x27;)
                    f))
              (λ
               (H :
                 @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i
                   (@set.range.{u_1 u+1} ι
                      (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                         (@set.has_coe_to_sort.{u} (set.{u} α))
                         B&#x27;)
                      f)), s i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
ι : Type u_1,
s : ι → set.{u} α,
H : ∀ (i : ι), @is_open.{u} α t (s i),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i)))),
B : set.{u} (set.{u} α),
cB : @set.countable.{u} (set.{u} α) B,
_x :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       B),
bB : @topological_space.is_topological_basis.{u} α t B,
B&#x27; : set.{u} (set.{u} α) :=
  @has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α))
    (λ (b : set.{u} α),
       @Exists.{u_1+1} ι (λ (i : ι), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b (s i)))
    B,
f : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27; → ι,
hf :
  ∀ (b : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
    @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
      (@subtype.val.{u+1} (set.{u} α)
         (λ (x : set.{u} α),
            @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B&#x27;)
         b)
      (s (f b)),
_inst :
  encodable.{u}
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
x : α,
i : ι,
xs : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x ((λ (i : ι), s i) i)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.Union.{u u_1+1} α ι
       (λ (i : ι),
          @set.Union.{u 0} α
            (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i
               (@set.range.{u_1 u+1} ι
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     B&#x27;)
                  f))
            (λ
             (H :
               @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i
                 (@set.range.{u_1 u+1} ι
                    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       B&#x27;)
                    f)), s i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>368    rcases mem_basis_subset_of_mem_open bB xs (H _) with ⟨b, hb, xb, bs⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='topological_space.mem_basis_subset_of_mem_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='bB'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='xs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 230, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [t : topological_space.{u} α] {b : set.{u} (set.{u} α)}, @topological_space.is_topological_basis.{u} α t b → ∀ {a : α} {u : set.{u} α}, @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a u → @is_open.{u} α t u → @Exists.{u+1} (set.{u} α) (λ (v : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v b) (λ (H : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) v b), and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a v) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) v u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_space.is_topological_basis.{u} α t B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x ((λ (i : ι), s i) i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : ι), @is_open.{u} α t (s i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
ι : Type u_1,
s : ι → set.{u} α,
H : ∀ (i : ι), @is_open.{u} α t (s i),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i)))),
B : set.{u} (set.{u} α),
cB : @set.countable.{u} (set.{u} α) B,
_x :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       B),
bB : @topological_space.is_topological_basis.{u} α t B,
B&#x27; : set.{u} (set.{u} α) :=
  @has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α))
    (λ (b : set.{u} α),
       @Exists.{u_1+1} ι (λ (i : ι), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b (s i)))
    B,
f : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27; → ι,
hf :
  ∀ (b : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
    @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
      (@subtype.val.{u+1} (set.{u} α)
         (λ (x : set.{u} α),
            @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B&#x27;)
         b)
      (s (f b)),
_inst :
  encodable.{u}
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
x : α,
i : ι,
xs : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x ((λ (i : ι), s i) i)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.Union.{u u_1+1} α ι
       (λ (i : ι),
          @set.Union.{u 0} α
            (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i
               (@set.range.{u_1 u+1} ι
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     B&#x27;)
                  f))
            (λ
             (H :
               @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i
                 (@set.range.{u_1 u+1} ι
                    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       B&#x27;)
                    f)), s i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
ι : Type u_1,
s : ι → set.{u} α,
H : ∀ (i : ι), @is_open.{u} α t (s i),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i)))),
B : set.{u} (set.{u} α),
cB : @set.countable.{u} (set.{u} α) B,
_x :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       B),
bB : @topological_space.is_topological_basis.{u} α t B,
B&#x27; : set.{u} (set.{u} α) :=
  @has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α))
    (λ (b : set.{u} α),
       @Exists.{u_1+1} ι (λ (i : ι), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b (s i)))
    B,
f : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27; → ι,
hf :
  ∀ (b : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
    @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
      (@subtype.val.{u+1} (set.{u} α)
         (λ (x : set.{u} α),
            @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B&#x27;)
         b)
      (s (f b)),
_inst :
  encodable.{u}
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
x : α,
i : ι,
xs : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x ((λ (i : ι), s i) i),
b : set.{u} α,
hb : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) b B,
xb : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x b,
bs : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b ((λ (i : ι), s i) i)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.Union.{u u_1+1} α ι
       (λ (i : ι),
          @set.Union.{u 0} α
            (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i
               (@set.range.{u_1 u+1} ι
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     B&#x27;)
                  f))
            (λ
             (H :
               @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i
                 (@set.range.{u_1 u+1} ι
                    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       B&#x27;)
                    f)), s i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>369    exact ⟨_, ⟨_, rfl⟩, _, ⟨⟨⟨_, hb, _, bs⟩, rfl⟩, rfl⟩, hf _ (by exact xb)⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='bs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='xb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) b B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b ((λ (i : ι), s i) i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (b : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@subtype.val.{u+1} (set.{u} α) (λ (x : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B&#x27;) b) (s (f b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
ι : Type u_1,
s : ι → set.{u} α,
H : ∀ (i : ι), @is_open.{u} α t (s i),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i)))),
B : set.{u} (set.{u} α),
cB : @set.countable.{u} (set.{u} α) B,
_x :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       B),
bB : @topological_space.is_topological_basis.{u} α t B,
B&#x27; : set.{u} (set.{u} α) :=
  @has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α))
    (λ (b : set.{u} α),
       @Exists.{u_1+1} ι (λ (i : ι), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b (s i)))
    B,
f : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27; → ι,
hf :
  ∀ (b : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
    @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
      (@subtype.val.{u+1} (set.{u} α)
         (λ (x : set.{u} α),
            @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B&#x27;)
         b)
      (s (f b)),
_inst :
  encodable.{u}
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
x : α,
i : ι,
xs : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x ((λ (i : ι), s i) i),
b : set.{u} α,
hb : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) b B,
xb : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x b,
bs : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b ((λ (i : ι), s i) i)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.Union.{u u_1+1} α ι
       (λ (i : ι),
          @set.Union.{u 0} α
            (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i
               (@set.range.{u_1 u+1} ι
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     B&#x27;)
                  f))
            (λ
             (H :
               @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i
                 (@set.range.{u_1 u+1} ι
                    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       B&#x27;)
                    f)), s i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
ι : Type u_1,
s : ι → set.{u} α,
H : ∀ (i : ι), @is_open.{u} α t (s i),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i)))),
B : set.{u} (set.{u} α),
cB : @set.countable.{u} (set.{u} α) B,
_x :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       B),
bB : @topological_space.is_topological_basis.{u} α t B,
B&#x27; : set.{u} (set.{u} α) :=
  @has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α))
    (λ (b : set.{u} α),
       @Exists.{u_1+1} ι (λ (i : ι), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b (s i)))
    B,
f : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27; → ι,
hf :
  ∀ (b : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
    @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
      (@subtype.val.{u+1} (set.{u} α)
         (λ (x : set.{u} α),
            @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B&#x27;)
         b)
      (s (f b)),
_inst :
  encodable.{u}
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
x : α,
i : ι,
xs : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x ((λ (i : ι), s i) i),
b : set.{u} α,
hb : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) b B,
xb : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x b,
bs : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b ((λ (i : ι), s i) i)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@subtype.val.{u+1} (set.{u} α)
       (λ (x : set.{u} α),
          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B&#x27;)
       (@subtype.mk.{u+1} (set.{u} α)
          (λ (x : set.{u} α),
             @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B&#x27;)
          b
          (@and.intro (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) b B)
             ((λ (b : set.{u} α),
                 @Exists.{u_1+1} ι (λ (i : ι), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b (s i)))
                b)
             hb
             (@Exists.intro.{u_1+1} ι
                (λ (i : ι), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b (s i))
                i
                bs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
ι : Type u_1,
s : ι → set.{u} α,
H : ∀ (i : ι), @is_open.{u} α t (s i),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (b : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) b)
         (and
            (not
               (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
                  (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
                  b))
            (@topological_space.is_topological_basis.{u} α t b))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} ι)
    (λ (T : set.{u_1} ι),
       and (@set.countable.{u_1} ι T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u_1+1} α ι
               (λ (i : ι),
                  @set.Union.{u 0} α (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T)
                    (λ (H : @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i T), s i)))
            (@set.Union.{u u_1+1} α ι (λ (i : ι), s i)))),
B : set.{u} (set.{u} α),
cB : @set.countable.{u} (set.{u} α) B,
_x :
  not
    (@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α))
       (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
       B),
bB : @topological_space.is_topological_basis.{u} α t B,
B&#x27; : set.{u} (set.{u} α) :=
  @has_sep.sep.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_sep.{u} (set.{u} α))
    (λ (b : set.{u} α),
       @Exists.{u_1+1} ι (λ (i : ι), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b (s i)))
    B,
f : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27; → ι,
hf :
  ∀ (b : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
    @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
      (@subtype.val.{u+1} (set.{u} α)
         (λ (x : set.{u} α),
            @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x B&#x27;)
         b)
      (s (f b)),
_inst :
  encodable.{u}
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) B&#x27;),
x : α,
i : ι,
xs : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x ((λ (i : ι), s i) i),
b : set.{u} α,
hb : @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) b B,
xb : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x b,
bs : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b ((λ (i : ι), s i) i)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.Union.{u u_1+1} α ι
       (λ (i : ι),
          @set.Union.{u 0} α
            (@has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i
               (@set.range.{u_1 u+1} ι
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     B&#x27;)
                  f))
            (λ
             (H :
               @has_mem.mem.{u_1 u_1} ι (set.{u_1} ι) (@set.has_mem.{u_1} ι) i
                 (@set.range.{u_1 u+1} ι
                    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       B&#x27;)
                    f)), s i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>370  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>371  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>372  lemma is_open_sUnion_countable [second_countable_topology α]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='topological_space.second_countable_topology'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π (α : Type u) [t : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='A second-countable space is one with a countable basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>373    (S : set (set α)) (H : ∀ s ∈ S, _root_.is_open s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>374    ∃ T : set (set α), countable T ∧ T ⊆ S ∧ ⋃₀ T = ⋃₀ S :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.countable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.sUnion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.sUnion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 78, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 78, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title=' Countable sets

A set is countable if there exists an encoding of the set into the natural numbers.
An encoding is an injection with a partial inverse, which can be viewed as a
constructive analogue of countability. (For the most part, theorems about
`countable` will be classical and `encodable` will be constructive.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>375  let ⟨T, cT, hT⟩ := is_open_Union_countable (λ s:S, s.1) (λ s, H s.1 s.2) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cT'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='topological_space.is_open_Union_countable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.property'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;line&#x27;: 357, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)) (λ (T : set.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)), and (@set.countable.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S) T) (@eq.{(max (u+1) 1)} (set.{u} α) (@set.Union.{u u+1} α (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S) (λ (i : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S), @set.Union.{u 0} α (@has_mem.mem.{u u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S) (set.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)) (@set.has_mem.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)) i T) (λ (H : @has_mem.mem.{u u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S) (set.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)) (@set.has_mem.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)) i T), (λ (s : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S), @subtype.val.{u+1} (set.{u} α) (λ (x : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S) s) i))) (@set.Union.{u u+1} α (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S) (λ (i : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S), (λ (s : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S), @subtype.val.{u+1} (set.{u} α) (λ (x : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S) s) i)))) → @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α)) (λ (T : set.{u} (set.{u} α)), and (@set.countable.{u} (set.{u} α) T) (and (@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) T S) (@eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α T) (@set.sUnion.{u} α S))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@set.countable.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S) T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u} [t : topological_space.{u} α] [_inst_1 : @topological_space.second_countable_topology.{u} α t] {ι : Type u} (s : ι → set.{u} α), (∀ (i : ι), @is_open.{u} α t (s i)) → @Exists.{(max (u+1) 1)} (set.{u} ι) (λ (T : set.{u} ι), and (@set.countable.{u} ι T) (@eq.{(max (u+1) 1)} (set.{u} α) (@set.Union.{u u+1} α ι (λ (i : ι), @set.Union.{u 0} α (@has_mem.mem.{u u} ι (set.{u} ι) (@set.has_mem.{u} ι) i T) (λ (H : @has_mem.mem.{u u} ι (set.{u} ι) (@set.has_mem.{u} ι) i T), s i))) (@set.Union.{u u+1} α ι (λ (i : ι), s i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='set.{u} (set.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {p : α → Prop}, @subtype.{u+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (s : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s S → @is_open.{u} α t s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {p : α → Prop}, @subtype.{u+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} (c : @subtype.{u+1} α p), p (@subtype.val.{u+1} α p c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>376  ⟨subtype.val &#x27;&#x27; T, countable_image _ cT,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.countable_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/countable.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {p : α → Prop}, @subtype.{(max (u+1) 1)} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, (α → β) → set.{u} α → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α β : Type u} {s : set.{u} α} (f : α → β), @set.countable.{u} α s → @set.countable.{u} β (@set.image.{u u} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>377    image_subset_iff.2 $ λ ⟨x, xs⟩ xt, xs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.image_subset_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='xs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1063, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α β : Type u} {s : set.{u} α} {t : set.{u} β} {f : α → β}, iff (@has_subset.subset.{u} (set.{u} β) (@set.has_subset.{u} β) (@set.image.{u u} α β f s) t) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s (@set.preimage.{u u} α β f t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@subtype.{(max (u+1) 1)} (set.{u} α) (λ (x : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (@subtype.{(max (u+1) 1)} (set.{u} α) (λ (x : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)) (set.{u} (@subtype.{(max (u+1) 1)} (set.{u} α) (λ (x : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S))) (@set.has_mem.{u} (@subtype.{(max (u+1) 1)} (set.{u} α) (λ (x : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S))) (@subtype.mk.{(max (u+1) 1)} . (set.{u} α) . (λ (x : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S) x xs) T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='image and preimage are a Galois connection'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>378    by rwa [sUnion_image, sUnion_eq_Union]⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.sUnion_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.sUnion_eq_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 478, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → set.{u} β) (s : set.{u} α), @eq.{(max (u+1) 1)} (set.{u} β) (@set.sUnion.{u} β (@set.image.{u u} α (set.{u} β) f s)) (@set.Union.{u u+1} β α (λ (x : α), @set.Union.{u 0} β (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s) (λ (H : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s), f x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s : set.{u} (set.{u} α)}, @eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α s) (@set.Union.{u (max 1 (u+1))} α (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) s) (λ (i : @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) s), @subtype.val.{u+1} (set.{u} α) (λ (x : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x s) i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
S : set.{u} (set.{u} α),
H :
  ∀ (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s S → @is_open.{u} α t s,
_let_match :
  @Exists.{(max (u+1) 1)}
    (set.{u}
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S))
    (λ
     (T :
       set.{u}
         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)),
       and
         (@set.countable.{u}
            (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)
            T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u+1} α
               (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                  S)
               (λ
                (i :
                  @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                    (@set.has_coe_to_sort.{u} (set.{u} α))
                    S),
                  @set.Union.{u 0} α
                    (@has_mem.mem.{u u}
                       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                          (@set.has_coe_to_sort.{u} (set.{u} α))
                          S)
                       (set.{u}
                          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                             (@set.has_coe_to_sort.{u} (set.{u} α))
                             S))
                       (@set.has_mem.{u}
                          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                             (@set.has_coe_to_sort.{u} (set.{u} α))
                             S))
                       i
                       T)
                    (λ
                     (H :
                       @has_mem.mem.{u u}
                         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                            (@set.has_coe_to_sort.{u} (set.{u} α))
                            S)
                         (set.{u}
                            (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                               (@set.has_coe_to_sort.{u} (set.{u} α))
                               S))
                         (@set.has_mem.{u}
                            (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                               (@set.has_coe_to_sort.{u} (set.{u} α))
                               S))
                         i
                         T),
                       (λ
                        (s :
                          @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                            (@set.has_coe_to_sort.{u} (set.{u} α))
                            S),
                          @subtype.val.{u+1} (set.{u} α)
                            (λ (x : set.{u} α),
                               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x
                                 S)
                            s)
                         i)))
            (@set.Union.{u u+1} α
               (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                  S)
               (λ
                (i :
                  @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                    (@set.has_coe_to_sort.{u} (set.{u} α))
                    S),
                  (λ
                   (s :
                     @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       S),
                     @subtype.val.{u+1} (set.{u} α)
                       (λ (x : set.{u} α),
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)
                       s)
                    i)))) →
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (T : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) T)
         (and (@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) T S)
            (@eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α T) (@set.sUnion.{u} α S)))),
T :
  set.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S),
cT :
  @set.countable.{u}
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)
    T,
hT :
  @eq.{(max (u+1) 1)} (set.{u} α)
    (@set.Union.{u u+1} α
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)
       (λ
        (i :
          @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S),
          @set.Union.{u 0} α
            (@has_mem.mem.{u u}
               (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                  S)
               (set.{u}
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     S))
               (@set.has_mem.{u}
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     S))
               i
               T)
            (λ
             (H :
               @has_mem.mem.{u u}
                 (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                    (@set.has_coe_to_sort.{u} (set.{u} α))
                    S)
                 (set.{u}
                    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       S))
                 (@set.has_mem.{u}
                    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       S))
                 i
                 T),
               (λ
                (s :
                  @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                    (@set.has_coe_to_sort.{u} (set.{u} α))
                    S),
                  @subtype.val.{u+1} (set.{u} α)
                    (λ (x : set.{u} α),
                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)
                    s)
                 i)))
    (@set.Union.{u u+1} α
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)
       (λ
        (i :
          @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S),
          (λ
           (s :
             @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
               S),
             @subtype.val.{u+1} (set.{u} α)
               (λ (x : set.{u} α),
                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)
               s)
            i))
⊢ @eq.{(max (u+1) 1)} (set.{u} α)
    (@set.sUnion.{u} α
       (@set.image.{u u}
          (@subtype.{(max (u+1) 1)} (set.{u} α)
             (λ (x : set.{u} α),
                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S))
          (set.{u} α)
          (@subtype.val.{(max (u+1) 1)} (set.{u} α)
             (λ (x : set.{u} α),
                @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S))
          T))
    (@set.sUnion.{u} α S)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
S : set.{u} (set.{u} α),
H :
  ∀ (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s S → @is_open.{u} α t s,
_let_match :
  @Exists.{(max (u+1) 1)}
    (set.{u}
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S))
    (λ
     (T :
       set.{u}
         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)),
       and
         (@set.countable.{u}
            (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)
            T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u+1} α
               (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                  S)
               (λ
                (i :
                  @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                    (@set.has_coe_to_sort.{u} (set.{u} α))
                    S),
                  @set.Union.{u 0} α
                    (@has_mem.mem.{u u}
                       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                          (@set.has_coe_to_sort.{u} (set.{u} α))
                          S)
                       (set.{u}
                          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                             (@set.has_coe_to_sort.{u} (set.{u} α))
                             S))
                       (@set.has_mem.{u}
                          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                             (@set.has_coe_to_sort.{u} (set.{u} α))
                             S))
                       i
                       T)
                    (λ
                     (H :
                       @has_mem.mem.{u u}
                         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                            (@set.has_coe_to_sort.{u} (set.{u} α))
                            S)
                         (set.{u}
                            (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                               (@set.has_coe_to_sort.{u} (set.{u} α))
                               S))
                         (@set.has_mem.{u}
                            (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                               (@set.has_coe_to_sort.{u} (set.{u} α))
                               S))
                         i
                         T),
                       (λ
                        (s :
                          @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                            (@set.has_coe_to_sort.{u} (set.{u} α))
                            S),
                          @subtype.val.{u+1} (set.{u} α)
                            (λ (x : set.{u} α),
                               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x
                                 S)
                            s)
                         i)))
            (@set.Union.{u u+1} α
               (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                  S)
               (λ
                (i :
                  @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                    (@set.has_coe_to_sort.{u} (set.{u} α))
                    S),
                  (λ
                   (s :
                     @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       S),
                     @subtype.val.{u+1} (set.{u} α)
                       (λ (x : set.{u} α),
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)
                       s)
                    i)))) →
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (T : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) T)
         (and (@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) T S)
            (@eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α T) (@set.sUnion.{u} α S)))),
T :
  set.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S),
cT :
  @set.countable.{u}
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)
    T,
hT :
  @eq.{(max (u+1) 1)} (set.{u} α)
    (@set.Union.{u u+1} α
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)
       (λ
        (i :
          @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S),
          @set.Union.{u 0} α
            (@has_mem.mem.{u u}
               (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                  S)
               (set.{u}
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     S))
               (@set.has_mem.{u}
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     S))
               i
               T)
            (λ
             (H :
               @has_mem.mem.{u u}
                 (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                    (@set.has_coe_to_sort.{u} (set.{u} α))
                    S)
                 (set.{u}
                    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       S))
                 (@set.has_mem.{u}
                    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       S))
                 i
                 T),
               (λ
                (s :
                  @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                    (@set.has_coe_to_sort.{u} (set.{u} α))
                    S),
                  @subtype.val.{u+1} (set.{u} α)
                    (λ (x : set.{u} α),
                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)
                    s)
                 i)))
    (@set.Union.{u u+1} α
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)
       (λ
        (i :
          @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S),
          (λ
           (s :
             @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
               S),
             @subtype.val.{u+1} (set.{u} α)
               (λ (x : set.{u} α),
                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)
               s)
            i))
⊢ @eq.{(max (u+1) 1)} (set.{u} α)
    (@set.Union.{u u+1} α
       (@subtype.{(max (u+1) 1)} (set.{u} α)
          (λ (x : set.{u} α),
             @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S))
       (λ
        (x :
          @subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (x : set.{u} α),
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)),
          @set.Union.{u 0} α
            (@has_mem.mem.{u u}
               (@subtype.{(max (u+1) 1)} (set.{u} α)
                  (λ (x : set.{u} α),
                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S))
               (set.{u}
                  (@subtype.{(max (u+1) 1)} (set.{u} α)
                     (λ (x : set.{u} α),
                        @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)))
               (@set.has_mem.{u}
                  (@subtype.{(max (u+1) 1)} (set.{u} α)
                     (λ (x : set.{u} α),
                        @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)))
               x
               T)
            (λ
             (H :
               @has_mem.mem.{u u}
                 (@subtype.{(max (u+1) 1)} (set.{u} α)
                    (λ (x : set.{u} α),
                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S))
                 (set.{u}
                    (@subtype.{(max (u+1) 1)} (set.{u} α)
                       (λ (x : set.{u} α),
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)))
                 (@set.has_mem.{u}
                    (@subtype.{(max (u+1) 1)} (set.{u} α)
                       (λ (x : set.{u} α),
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)))
                 x
                 T),
               @subtype.val.{(max (u+1) 1)} (set.{u} α)
                 (λ (x : set.{u} α),
                    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)
                 x)))
    (@set.sUnion.{u} α S)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : topological_space.{u} α,
_inst_1 : @topological_space.second_countable_topology.{u} α t,
S : set.{u} (set.{u} α),
H :
  ∀ (s : set.{u} α),
    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) s S → @is_open.{u} α t s,
_let_match :
  @Exists.{(max (u+1) 1)}
    (set.{u}
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S))
    (λ
     (T :
       set.{u}
         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)),
       and
         (@set.countable.{u}
            (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)
            T)
         (@eq.{(max (u+1) 1)} (set.{u} α)
            (@set.Union.{u u+1} α
               (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                  S)
               (λ
                (i :
                  @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                    (@set.has_coe_to_sort.{u} (set.{u} α))
                    S),
                  @set.Union.{u 0} α
                    (@has_mem.mem.{u u}
                       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                          (@set.has_coe_to_sort.{u} (set.{u} α))
                          S)
                       (set.{u}
                          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                             (@set.has_coe_to_sort.{u} (set.{u} α))
                             S))
                       (@set.has_mem.{u}
                          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                             (@set.has_coe_to_sort.{u} (set.{u} α))
                             S))
                       i
                       T)
                    (λ
                     (H :
                       @has_mem.mem.{u u}
                         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                            (@set.has_coe_to_sort.{u} (set.{u} α))
                            S)
                         (set.{u}
                            (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                               (@set.has_coe_to_sort.{u} (set.{u} α))
                               S))
                         (@set.has_mem.{u}
                            (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                               (@set.has_coe_to_sort.{u} (set.{u} α))
                               S))
                         i
                         T),
                       (λ
                        (s :
                          @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                            (@set.has_coe_to_sort.{u} (set.{u} α))
                            S),
                          @subtype.val.{u+1} (set.{u} α)
                            (λ (x : set.{u} α),
                               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x
                                 S)
                            s)
                         i)))
            (@set.Union.{u u+1} α
               (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                  S)
               (λ
                (i :
                  @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                    (@set.has_coe_to_sort.{u} (set.{u} α))
                    S),
                  (λ
                   (s :
                     @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       S),
                     @subtype.val.{u+1} (set.{u} α)
                       (λ (x : set.{u} α),
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)
                       s)
                    i)))) →
  @Exists.{(max (u+1) 1)} (set.{u} (set.{u} α))
    (λ (T : set.{u} (set.{u} α)),
       and (@set.countable.{u} (set.{u} α) T)
         (and (@has_subset.subset.{u} (set.{u} (set.{u} α)) (@set.has_subset.{u} (set.{u} α)) T S)
            (@eq.{(max (u+1) 1)} (set.{u} α) (@set.sUnion.{u} α T) (@set.sUnion.{u} α S)))),
T :
  set.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S),
cT :
  @set.countable.{u}
    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)
    T,
hT :
  @eq.{(max (u+1) 1)} (set.{u} α)
    (@set.Union.{u u+1} α
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)
       (λ
        (i :
          @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S),
          @set.Union.{u 0} α
            (@has_mem.mem.{u u}
               (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
                  S)
               (set.{u}
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     S))
               (@set.has_mem.{u}
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                     (@set.has_coe_to_sort.{u} (set.{u} α))
                     S))
               i
               T)
            (λ
             (H :
               @has_mem.mem.{u u}
                 (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                    (@set.has_coe_to_sort.{u} (set.{u} α))
                    S)
                 (set.{u}
                    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       S))
                 (@set.has_mem.{u}
                    (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                       (@set.has_coe_to_sort.{u} (set.{u} α))
                       S))
                 i
                 T),
               (λ
                (s :
                  @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α))
                    (@set.has_coe_to_sort.{u} (set.{u} α))
                    S),
                  @subtype.val.{u+1} (set.{u} α)
                    (λ (x : set.{u} α),
                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)
                    s)
                 i)))
    (@set.Union.{u u+1} α
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)
       (λ
        (i :
          @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S),
          (λ
           (s :
             @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α))
               S),
             @subtype.val.{u+1} (set.{u} α)
               (λ (x : set.{u} α),
                  @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)
               s)
            i))
⊢ @eq.{(max (u+1) 1)} (set.{u} α)
    (@set.Union.{u u+1} α
       (@subtype.{(max (u+1) 1)} (set.{u} α)
          (λ (x : set.{u} α),
             @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S))
       (λ
        (x :
          @subtype.{(max (u+1) 1)} (set.{u} α)
            (λ (x : set.{u} α),
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)),
          @set.Union.{u 0} α
            (@has_mem.mem.{u u}
               (@subtype.{(max (u+1) 1)} (set.{u} α)
                  (λ (x : set.{u} α),
                     @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S))
               (set.{u}
                  (@subtype.{(max (u+1) 1)} (set.{u} α)
                     (λ (x : set.{u} α),
                        @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)))
               (@set.has_mem.{u}
                  (@subtype.{(max (u+1) 1)} (set.{u} α)
                     (λ (x : set.{u} α),
                        @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)))
               x
               T)
            (λ
             (H :
               @has_mem.mem.{u u}
                 (@subtype.{(max (u+1) 1)} (set.{u} α)
                    (λ (x : set.{u} α),
                       @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S))
                 (set.{u}
                    (@subtype.{(max (u+1) 1)} (set.{u} α)
                       (λ (x : set.{u} α),
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)))
                 (@set.has_mem.{u}
                    (@subtype.{(max (u+1) 1)} (set.{u} α)
                       (λ (x : set.{u} α),
                          @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)))
                 x
                 T),
               @subtype.val.{(max (u+1) 1)} (set.{u} α)
                 (λ (x : set.{u} α),
                    @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)
                 x)))
    (@set.Union.{u (max 1 (u+1))} α
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S)
       (λ
        (i :
          @coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (set.{u} α)) (@set.has_coe_to_sort.{u} (set.{u} α)) S),
          @subtype.val.{u+1} (set.{u} α)
            (λ (x : set.{u} α),
               @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x S)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>379  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>380  end topological_space</code></pre>
</body>