<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Sébastien Gouëzel. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Sébastien Gouëzel</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import topology.local_homeomorph</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  # Fiber bundles</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  A topological fiber bundle with fiber F over a base B is a space projecting on B for which the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  fibers are all homeomorphic to F, such that the local situation around each point is a direct</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  product. We define a predicate `is_topological_fiber_bundle F p` saying that `p : Z → B` is a</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  topological fiber bundle with fiber `F`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  It is in general nontrivial to construct a fiber bundle. A way is to start from the knowledge of</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  how changes of local trivializations act on the fiber. From this, one can construct the total space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  of the bundle and its topology by a suitable gluing construction. The main content of this file is</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  an implementation of this construction: starting from an object of type</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  `topological_fiber_bundle_core` registering the trivialization changes, one gets the corresponding</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  fiber bundle and projection.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  ## Main definitions</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  `bundle_trivialization F p` : structure extending local homeomorphisms, defining a local</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27                    trivialization of a topological space `Z` with projection `p` and fiber `F`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  `is_topological_fiber_bundle F p` : Prop saying that the map `p` between topological spaces is a</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29                    fiber bundle with fiber `F`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  `topological_fiber_bundle_core ι B F` : structure registering how changes of coordinates act on the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32                    fiber `F` above open subsets of `B`, where local trivializations are indexed by ι.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  Let `Z : topological_fiber_bundle_core ι B F`. Then we define</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  `Z.total_space` : the total space of `Z`, defined as a Type as `B × F`, but with a twisted topology</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35                    coming from the fiber bundle structure</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  `Z.proj`        : projection from `Z.total_space` to `B`. It is continuous.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  `Z.fiber x`     : the fiber above `x`, homeomorphic to `F` (and defeq to `F` as a type).</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  `Z.local_triv i`: for `i : ι`, a local homeomorphism from `Z.total_space` to `B × F`, that realizes</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39                    a trivialization above the set `Z.base_set i`, which is an open set in `B`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  ## Implementation notes</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  A topological fiber bundle with fiber F over a base B is a family of spaces isomorphic to F,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  indexed by B, which is locally trivial in the following sense: there is a covering of B by open</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  sets such that, on each such open set `s`, the bundle is isomorphic to `s × F`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  To construct a fiber bundle formally, the main data is what happens when one changes trivializations</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  from `s × F` to `s&#x27; × F` on `s ∩ s&#x27;`: one should get a family of homeomorphisms of `F`, depending</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  continuously on the base point, satisfying basic compatibility conditions (cocycle property).</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  Useful classes of bundles can then be specified by requiring that these homeomorphisms of `F`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  belong to some subgroup, preserving some structure (the &quot;structure group of the bundle&quot;): then</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  these structures are inherited by the fibers of the bundle.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  Given such trivialization change data (encoded below in a structure called</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  `topological_fiber_bundle_core`), one can construct the fiber bundle. The intrinsic canonical</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  mathematical construction is the following.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  The fiber above x is the disjoint union of F over all trivializations, modulo the gluing</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  identifications: one gets a fiber which is isomorphic to F, but non-canonically</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  (each choice of one of the trivializations around x gives such an isomorphism). Given a</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  trivialization over a set `s`, one gets an isomorphism between `s × F` and `proj^{-1} s`, by using</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  the identification corresponding to this trivialization. One chooses the topology on the bundle that</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  makes all of these into homeomorphisms.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  For the practical implementation, it turns out to be more convenient to avoid completely the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  gluing and quotienting construction above, and to declare above each `x` that the fiber is `F`,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  but thinking that it corresponds to the `F` coming from the choice of one trivialization around `x`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  This has several practical advantages:</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  * without any work, one gets a topological space structure on the fiber. And if `F` has more</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  structure it is inherited for free by the fiber.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  * In the trivial situation of the trivial bundle where there is only one chart and one</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  trivialization, this construction gives the product space B × F with the product topology. In the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  case of the tangent bundle of manifolds, this also implies that on vector spaces the derivative and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  the manifold derivative are equal.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  A drawback is that some silly constructions will typecheck: in the case of the tangent bundle, one</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  can add two vectors in different tangent spaces (as they both are elements of F from the point of</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  view of Lean). To solve this, one could mark the tangent space as irreducible, but then one would</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  lose the identification of the tangent space to F with F. There is however a big advantage of this</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  situation: even if Lean can not check that two basepoints are defeq, it will accept the fact that</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  the tangent spaces are the same. For instance, if two maps f and g are locally inverse to each</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  other, one can express that the composition of their derivatives is the identity of</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  `tangent_space I x`. One could fear issues as this composition goes from `tangent_space I x` to</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  `tangent_space I (g (f x))` (which should be the same, but should not be obvious to Lean</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  as it does not know that `g (f x) = x`). As these types are the same to Lean (equal to `F`), there</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  are in fact no dependent type difficulties here!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  For this construction of a fiber bundle from a `topological_fiber_bundle_core`, we should thus</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  choose for each `x` one specific trivialization around it. We include this choice in the definition</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  of the `topological_fiber_bundle_core`, as it makes some constructions more</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  functorial and it is a nice way to say that the trivializations cover the whole space B.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  With this definition, the type of the fiber bundle space constructed from the core data is just</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  `B × F`, but the topology is not the product one.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  We also take the indexing type (indexing all the trivializations) as a parameter to the fiber bundle</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  core: it could always be taken as a subtype of all the maps from open subsets of B to continuous</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  maps of F, but in practice it will sometimes be something else. For instance, on a manifold, one</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  will use the set of charts as a good parameterization for the trivializations of the tangent bundle.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  Or for the pullback of a `topological_fiber_bundle_core`, the indexing type will be the same as</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  for the initial bundle.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  ## Tags</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  Fiber bundle, topological bundle, vector bundle, local trivialization, structure group</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  variables {ι : Type*} {B : Type*} {F : Type*}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  open topological_space set</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  open_locale topological_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  section topological_fiber_bundle</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  variables {Z : Type*} [topological_space B] [topological_space Z]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='_inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='topological_space.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='topological_space.{u_4} Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114    [topological_space F] (proj : Z → B)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='_inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='topological_space.{u_3} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  variable (F)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  A structure extending local homeomorphisms, defining a local trivialization of a projection</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  `proj : Z → B` with fiber `F`, as a local homeomorphism between `Z` and `B × F` defined between two</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  sets of the form `proj ⁻¹&#x27; base_set` and `base_set × F`, acting trivially on the first coordinate.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  structure bundle_trivialization extends local_homeomorph Z (B × F) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='local_homeomorph'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Π (α : Type u_4) (β : Type (max u_2 u_3)) [_inst_5 : topological_space.{u_4} α] [_inst_6 : topological_space.{(max u_2 u_3)} β], Type (max u_4 u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_3 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='local homeomorphisms, defined on open subsets of the space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  (base_set      : set B)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  (open_base_set : is_open base_set)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π {α : Type u_2} [t : topological_space.{u_2} α], set.{u_2} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  (source_eq     : source = proj ⁻¹&#x27; base_set)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@(λ {α : Type u_4} {β : Type (max u_2 u_3)} (c : local_equiv.{u_4 (max u_2 u_3)} α β), set.{u_4} α) Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) to_local_homeomorph)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, (α → β) → set.{u_2} β → set.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  (target_eq     : target = set.prod base_set univ)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='target'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@(λ {α : Type u_4} {β : Type (max u_2 u_3)} (c : local_equiv.{u_4 (max u_2 u_3)} α β), set.{(max u_2 u_3)} β) Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) to_local_homeomorph)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_2 u_3)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, set.{u_1} α → set.{u_2} β → set.{(max u_1 u_2)} (prod.{u_1 u_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  (proj_to_fun   : ∀ p ∈ source, (to_fun p).1 = proj p)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Π {α γ : Type u_5} [c : has_mem.{u_5 u_5} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@(λ {α : Type u_4} {β : Type (max u_2 u_3)} (c : local_equiv.{u_4 (max u_2 u_3)} α β), set.{u_4} α) Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) to_local_homeomorph)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@(λ {α : Type u_4} {β : Type (max u_2 u_3)} (c : local_equiv.{u_4 (max u_2 u_3)} α β), α → β) Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) to_local_homeomorph)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  /-- A topological fiber bundle with fiber F over a base B is a space projecting on B for which the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  fibers are all homeomorphic to F, such that the local situation around each point is a direct</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  product. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  def is_topological_fiber_bundle : Prop :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  ∀ x : Z, ∃e : bundle_trivialization F proj, x ∈ e.source</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='bundle_trivialization'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 123, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u_2 u_3 u_4)}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {B : Type u_2} (F : Type u_3) {Z : Type u_4} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_4} Z] [_inst_3 : topological_space.{u_3} F], (Z → B) → Type (max u_2 u_3 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u_2 u_3 u_4)}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_4} [c : has_mem.{u_4 u_4} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_4} {β : Type (max u_2 u_3)}, local_equiv.{u_4 (max u_2 u_3)} α β → set.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='A structure extending local homeomorphisms, defining a local trivialization of a projection
`proj : Z → B` with fiber `F`, as a local homeomorphism between `Z` and `B × F` defined between two
sets of the form `proj ⁻¹&#x27; base_set` and `base_set × F`, acting trivially on the first coordinate.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  variables {F} {proj}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  /-- In the domain of a bundle trivialization, the projection is continuous-/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  lemma bundle_trivialization.continuous_at_proj (e : bundle_trivialization F proj) {x : Z}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='blue'><a title='bundle_trivialization'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='red'><a title='{&#x27;line&#x27;: 123, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='green'><a title='Π {B : Type u_2} (F : Type u_3) {Z : Type u_4} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_4} Z] [_inst_3 : topological_space.{u_3} F], (Z → B) → Type (max u_2 u_3 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title='A structure extending local homeomorphisms, defining a local trivialization of a projection
`proj : Z → B` with fiber `F`, as a local homeomorphism between `Z` and `B × F` defined between two
sets of the form `proj ⁻¹&#x27; base_set` and `base_set × F`, acting trivially on the first coordinate.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140    (ex : x ∈ e.source) : continuous_at proj x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='continuous_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 648, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_4} [c : has_mem.{u_4 u_4} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_4} {β : Type (max u_2 u_3)}, local_equiv.{u_4 (max u_2 u_3)} α β → set.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title=' A function between topological spaces is continuous at a point `x₀`
if `f x` tends to `f x₀` when `x` tends to `x₀`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
⊢ @continuous_at.{u_4 u_2} Z B _inst_2 _inst_1 proj x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142    assume s hs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
⊢ @continuous_at.{u_4 u_2} Z B _inst_2 _inst_1 proj x'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))),
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x))
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143    obtain ⟨t, st, t_open, xt⟩ : ∃ t ⊆ s, is_open t ∧ proj x ∈ t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} [t : topological_space.{u_2} α], set.{u_2} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))),
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x))
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))),
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x))
⊢ @Exists.{u_2+1} (set.{u_2} B)
    (λ (t : set.{u_2} B),
       @Exists.{0} (@has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s)
         (λ (H : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s),
            and (@is_open.{u_2} B _inst_1 t)
              (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t)))

B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))),
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144      from mem_nhds_sets_iff.1 hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='mem_nhds_sets_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 421, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] {a : α} {s : set.{u_2} α}, iff (@has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) s (@nhds.{u_2} α _inst_1 a)) (@Exists.{u_2+1} (set.{u_2} α) (λ (t : set.{u_2} α), @Exists.{0} (@has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) t s) (λ (H : @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) t s), and (@is_open.{u_2} α _inst_1 t) (@has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) a t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))),
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x))
⊢ @Exists.{u_2+1} (set.{u_2} B)
    (λ (t : set.{u_2} B),
       @Exists.{0} (@has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s)
         (λ (H : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s),
            and (@is_open.{u_2} B _inst_1 t)
              (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t)))

B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))),
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))),
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145    rw e.source_eq at ex,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u_4+1) 1)} (@(λ {α : Type u_4} {β : Type (max u_2 u_3)} (c : local_equiv.{u_4 (max u_2 u_3)} α β), set.{u_4} α) Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))) (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))) (@set.preimage.{u_4 u_2} Z B proj (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))),
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146    let u := e.base_set ∩ t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 123, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} [c : has_inter.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147    have u_open : is_open u := is_open_inter e.open_base_set t_open,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_open_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 123, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} [t : topological_space.{u_2} α], set.{u_2} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {s₁ s₂ : set.{u_2} α} [t : topological_space.{u_2} α], @is_open.{u_2} α t s₁ → @is_open.{u_2} α t s₂ → @is_open.{u_2} α t (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) s₁ s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u_2} B _inst_1 t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148    have xu : proj x ∈ u := ⟨ex, xt⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x (@set.preimage.{u_4 u_2} Z B proj (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149    /- Take a small enough open neighborhood u of `proj x`, contained in a trivialization domain o.</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150      One should show that its preimage is open. -/</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151    suffices : is_open (proj ⁻¹&#x27; u),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_4} [t : topological_space.{u_4} α], set.{u_4} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, (α → β) → set.{u_2} β → set.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
this : @is_open.{u_4} Z _inst_2 (@set.preimage.{u_4 u_2} Z B proj u)
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))

B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u
⊢ @is_open.{u_4} Z _inst_2 (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152    { have : proj ⁻¹&#x27; u ∈ 𝓝 x := mem_nhds_sets this xu,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='mem_nhds_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='xu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_4} [_inst_1 : topological_space.{u_4} α], α → filter.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} [_inst_1 : topological_space.{u_4} α] {a : α} {s : set.{u_4} α}, @is_open.{u_4} α _inst_1 s → @has_mem.mem.{u_4 u_4} α (set.{u_4} α) (@set.has_mem.{u_4} α) a s → @has_mem.mem.{u_4 u_4} (set.{u_4} α) (filter.{u_4} α) (@filter.has_mem.{u_4} α) s (@nhds.{u_4} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u_4} Z _inst_2 (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
this : @is_open.{u_4} Z _inst_2 (@set.preimage.{u_4 u_2} Z B proj u)
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))

B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u
⊢ @is_open.{u_4} Z _inst_2 (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
this : @is_open.{u_4} Z _inst_2 (@set.preimage.{u_4 u_2} Z B proj u)
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
this : @is_open.{u_4} Z _inst_2 (@set.preimage.{u_4 u_2} Z B proj u),
this :
  @has_mem.mem.{u_4 u_4} (set.{u_4} Z) (filter.{u_4} Z) (@filter.has_mem.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u)
    (@nhds.{u_4} Z _inst_2 x)
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153      apply filter.mem_sets_of_superset this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter.mem_sets_of_superset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {f : filter.{u_4} α} {x y : set.{u_4} α}, @has_mem.mem.{u_4 u_4} (set.{u_4} α) (filter.{u_4} α) (@filter.has_mem.{u_4} α) x f → @has_subset.subset.{u_4} (set.{u_4} α) (@set.has_subset.{u_4} α) x y → @has_mem.mem.{u_4 u_4} (set.{u_4} α) (filter.{u_4} α) (@filter.has_mem.{u_4} α) y f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} (set.{u_4} Z) (filter.{u_4} Z) (@filter.has_mem.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u) (@nhds.{u_4} Z _inst_2 x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
this : @is_open.{u_4} Z _inst_2 (@set.preimage.{u_4 u_2} Z B proj u),
this :
  @has_mem.mem.{u_4 u_4} (set.{u_4} Z) (filter.{u_4} Z) (@filter.has_mem.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u)
    (@nhds.{u_4} Z _inst_2 x)
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s
    (@filter.map.{u_4 u_2} Z B proj (@nhds.{u_4} Z _inst_2 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
this : @is_open.{u_4} Z _inst_2 (@set.preimage.{u_4 u_2} Z B proj u),
this :
  @has_mem.mem.{u_4 u_4} (set.{u_4} Z) (filter.{u_4} Z) (@filter.has_mem.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u)
    (@nhds.{u_4} Z _inst_2 x)
⊢ @has_subset.subset.{u_4} (set.{u_4} Z) (@set.has_subset.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u)
    (@set.preimage.{u_4 u_2} Z B proj s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154      exact preimage_mono (subset.trans (inter_subset_right _ _) st) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.preimage_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.inter_subset_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='st'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 840, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 387, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type u_2} {f : α → β} {s t : set.{u_2} β}, @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) s t → @has_subset.subset.{u_4} (set.{u_4} α) (@set.has_subset.{u_4} α) (@set.preimage.{u_4 u_2} α β f s) (@set.preimage.{u_4 u_2} α β f t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} {a b c : set.{u_2} α}, @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) a b → @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) b c → @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} (s t : set.{u_2} α), @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) s t) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
this : @is_open.{u_4} Z _inst_2 (@set.preimage.{u_4 u_2} Z B proj u),
this :
  @has_mem.mem.{u_4 u_4} (set.{u_4} Z) (filter.{u_4} Z) (@filter.has_mem.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u)
    (@nhds.{u_4} Z _inst_2 x)
⊢ @has_subset.subset.{u_4} (set.{u_4} Z) (@set.has_subset.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u)
    (@set.preimage.{u_4 u_2} Z B proj s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u
⊢ @is_open.{u_4} Z _inst_2 (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155    -- to do this, rewrite `proj ⁻¹&#x27; u` in terms of the trivialization, and use its continuity.</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u
⊢ @is_open.{u_4} Z _inst_2 (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156    have : proj ⁻¹&#x27; u = e.to_fun ⁻¹&#x27; (set.prod u univ) ∩ e.source,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_4}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_4} {β : Type (max u_2 u_3)}, local_equiv.{u_4 (max u_2 u_3)} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, set.{u_2} α → set.{u_3} β → set.{(max u_2 u_3)} (prod.{u_2 u_3} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3}, set.{u_3} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u
⊢ @is_open.{u_4} Z _inst_2 (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u
⊢ @eq.{(max (u_4+1) 1)} (set.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u)
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))

B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
this :
  @eq.{(max (u_4+1) 1)} (set.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u)
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))
⊢ @is_open.{u_4} Z _inst_2 (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157    { ext p,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u
⊢ @eq.{(max (u_4+1) 1)} (set.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u)
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))

B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
this :
  @eq.{(max (u_4+1) 1)} (set.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u)
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))
⊢ @is_open.{u_4} Z _inst_2 (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u
⊢ @eq.{(max (u_4+1) 1)} (set.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u)
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z
⊢ iff (@has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u))
    (@has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
       (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
          (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
                (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
             (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
          (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158      split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z
⊢ iff (@has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u))
    (@has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
       (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
          (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
                (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
             (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
          (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u) →
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))

B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))) →
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159      { assume h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u) →
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))

B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))) →
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u) →
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z,
h : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u)
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160        have : p ∈ e.source,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z,
h : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u)
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z,
h : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u)
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))

B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z,
h : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u),
this :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161        { rw e.source_eq,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u_4+1) 1)} (@(λ {α : Type u_4} {β : Type (max u_2 u_3)} (c : local_equiv.{u_4 (max u_2 u_3)} α β), set.{u_4} α) Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))) (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))) (@set.preimage.{u_4 u_2} Z B proj (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z,
h : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u)
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))

B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z,
h : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u),
this :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z,
h : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u)
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z,
h : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u)
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162          have : u ⊆ e.base_set := inter_subset_left _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.inter_subset_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 123, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} (s t : set.{u_2} α), @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) s t) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z,
h : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u)
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z,
h : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u),
this :
  @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) u
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163          exact preimage_mono this h },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='set.preimage_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 840, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type u_2} {f : α → β} {s t : set.{u_2} β}, @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) s t → @has_subset.subset.{u_4} (set.{u_4} α) (@set.has_subset.{u_4} α) (@set.preimage.{u_4 u_2} α β f s) (@set.preimage.{u_4 u_2} α β f t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) u (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z,
h : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u),
this :
  @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) u
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z,
h : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u),
this :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164        simp [this, e.proj_to_fun, h.1, h.2] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : Z), @has_mem.mem.{u_4 u_4} Z (@(λ {α : Type u_4} {β : Type (max u_2 u_3)} (c : local_equiv.{u_4 (max u_2 u_3)} α β), set.{u_4} α) Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))) (@set.has_mem.{u_4} Z) p (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))) → @eq.{u_2+1} B (@prod.fst.{u_2 u_3} B F (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)) p)) (proj p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z,
h : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u),
this :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))) →
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165      { rintros ⟨h, h_source⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))) →
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z,
h :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
       (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F))),
h_source :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166        simpa [e.proj_to_fun, h_source] using h } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='h_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : Z), @has_mem.mem.{u_4 u_4} Z (@(λ {α : Type u_4} {β : Type (max u_2 u_3)} (c : local_equiv.{u_4 (max u_2 u_3)} α β), set.{u_4} α) Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))) (@set.has_mem.{u_4} Z) p (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))) → @eq.{u_2+1} B (@prod.fst.{u_2 u_3} B F (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)) p)) (proj p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))) (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
p : Z,
h :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
       (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F))),
h_source :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
⊢ @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) p (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
this :
  @eq.{(max (u_4+1) 1)} (set.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u)
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))
⊢ @is_open.{u_4} Z _inst_2 (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167    rw [this, inter_comm],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.inter_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 367, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u_4+1) 1)} (set.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u) (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))) (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F))) (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} (a b : set.{u_4} α), @eq.{u_4+1} (set.{u_4} α) (@has_inter.inter.{u_4} (set.{u_4} α) (@set.has_inter.{u_4} α) a b) (@has_inter.inter.{u_4} (set.{u_4} α) (@set.has_inter.{u_4} α) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
this :
  @eq.{(max (u_4+1) 1)} (set.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u)
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))
⊢ @is_open.{u_4} Z _inst_2 (@set.preimage.{u_4 u_2} Z B proj u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
this :
  @eq.{(max (u_4+1) 1)} (set.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u)
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))
⊢ @is_open.{u_4} Z _inst_2
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
this :
  @eq.{(max (u_4+1) 1)} (set.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u)
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))
⊢ @is_open.{u_4} Z _inst_2
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168    exact continuous_on.preimage_open_of_open e.continuous_to_fun e.open_source</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='continuous_on.preimage_open_of_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_homeomorph.continuous_to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 489, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type (max u_2 u_3)} [_inst_1 : topological_space.{u_4} α] [_inst_2 : topological_space.{(max u_2 u_3)} β] {f : α → β} {s : set.{u_4} α} {t : set.{(max u_2 u_3)} β}, @continuous_on.{u_4 (max u_2 u_3)} α β _inst_1 _inst_2 f s → @is_open.{u_4} α _inst_1 s → @is_open.{(max u_2 u_3)} β _inst_2 t → @is_open.{u_4} α _inst_1 (@has_inter.inter.{u_4} (set.{u_4} α) (@set.has_inter.{u_4} α) s (@set.preimage.{u_4 (max u_2 u_3)} α β f t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type (max u_2 u_3)} [_inst_5 : topological_space.{u_4} α] [_inst_6 : topological_space.{(max u_2 u_3)} β] (c : @local_homeomorph.{u_4 (max u_2 u_3)} α β _inst_5 _inst_6), @continuous_on.{u_4 (max u_2 u_3)} α β _inst_5 _inst_6 (@local_equiv.to_fun.{u_4 (max u_2 u_3)} α β (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} α β _inst_5 _inst_6 c)) (@local_equiv.source.{u_4 (max u_2 u_3)} α β (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} α β _inst_5 _inst_6 c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
this :
  @eq.{(max (u_4+1) 1)} (set.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u)
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))
⊢ @is_open.{u_4} Z _inst_2
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169      (is_open_prod u_open is_open_univ)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='is_open_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 128, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_3} β] {s : set.{u_2} α} {t : set.{u_3} β}, @is_open.{u_2} α _inst_1 s → @is_open.{u_3} β _inst_2 t → @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} α β) (@prod.topological_space.{u_2 u_3} α β _inst_1 _inst_2) (@set.prod.{u_2 u_3} α β s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u_2} B _inst_1 u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_3} [t : topological_space.{u_3} α], @is_open.{u_3} α t (@set.univ.{u_3} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
s : set.{u_2} B,
hs : @has_mem.mem.{u_2 u_2} (set.{u_2} B) (filter.{u_2} B) (@filter.has_mem.{u_2} B) s (@nhds.{u_2} B _inst_1 (proj x)),
t : set.{u_2} B,
st : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t s,
t_open : @is_open.{u_2} B _inst_1 t,
xt : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) t,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@set.preimage.{u_4 u_2} Z B proj
       (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)),
u : set.{u_2} B :=
  @has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
    (@bundle_trivialization.base_set.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)
    t,
u_open : @is_open.{u_2} B _inst_1 u,
xu : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (proj x) u,
this :
  @eq.{(max (u_4+1) 1)} (set.{u_4} Z) (@set.preimage.{u_4 u_2} Z B proj u)
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F)))
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))
⊢ @is_open.{u_4} Z _inst_2
    (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z)
       (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
       (@set.preimage.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
          (@set.prod.{u_2 u_3} B F u (@set.univ.{u_3} F))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  /-- The projection from a topological fiber bundle to its base is continuous. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173  lemma is_topological_fiber_bundle.continuous_proj (h : is_topological_fiber_bundle F proj) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='blue'><a title='is_topological_fiber_bundle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='red'><a title='{&#x27;line&#x27;: 133, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='green'><a title='Π {B : Type u_2} (F : Type u_3) {Z : Type u_4} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_4} Z] [_inst_3 : topological_space.{u_3} F], (Z → B) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='orange'><a title=' A topological fiber bundle with fiber F over a base B is a space projecting on B for which the
fibers are all homeomorphic to F, such that the local situation around each point is a direct
product.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174    continuous proj :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 644, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A function between topological spaces is continuous if the preimage
 of every open set is open.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj
⊢ @continuous.{u_4 u_2} Z B _inst_2 _inst_1 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176    rw continuous_iff_continuous_at,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='continuous_iff_continuous_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 677, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type u_2} [_inst_1 : topological_space.{u_4} α] [_inst_2 : topological_space.{u_2} β] {f : α → β}, iff (@continuous.{u_4 u_2} α β _inst_1 _inst_2 f) (∀ (x : α), @continuous_at.{u_4 u_2} α β _inst_1 _inst_2 f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj
⊢ @continuous.{u_4 u_2} Z B _inst_2 _inst_1 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj
⊢ ∀ (x : Z), @continuous_at.{u_4 u_2} Z B _inst_2 _inst_1 proj x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177    assume x,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj
⊢ ∀ (x : Z), @continuous_at.{u_4 u_2} Z B _inst_2 _inst_1 proj x'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z
⊢ @continuous_at.{u_4 u_2} Z B _inst_2 _inst_1 proj x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178    rcases h x with ⟨e, ex⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z
⊢ @continuous_at.{u_4 u_2} Z B _inst_2 _inst_1 proj x'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
⊢ @continuous_at.{u_4 u_2} Z B _inst_2 _inst_1 proj x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179    exact e.continuous_at_proj ex</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='In the domain of a bundle trivialization, the projection is continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
x : Z,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
ex :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) x
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
⊢ @continuous_at.{u_4 u_2} Z B _inst_2 _inst_1 proj x'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182  /-- The projection from a topological fiber bundle to its base is an open map. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183  lemma is_topological_fiber_bundle.is_open_map_proj (h : is_topological_fiber_bundle F proj) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='blue'><a title='is_topological_fiber_bundle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='red'><a title='{&#x27;line&#x27;: 133, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='green'><a title='Π {B : Type u_2} (F : Type u_3) {Z : Type u_4} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_4} Z] [_inst_3 : topological_space.{u_3} F], (Z → B) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='orange'><a title=' A topological fiber bundle with fiber F over a base B is a space projecting on B for which the
fibers are all homeomorphic to F, such that the local situation around each point is a direct
product.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184    is_open_map proj :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/maps.lean&#x27;, &#x27;line&#x27;: 197, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' A map `f : α → β` is said to be an *open map*, if the image of any open `U : set α`
is open in `β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj
⊢ @is_open_map.{u_4 u_2} Z B _inst_2 _inst_1 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186    assume s hs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj
⊢ @is_open_map.{u_4 u_2} Z B _inst_2 _inst_1 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s
⊢ @is_open.{u_2} B _inst_1 (@set.image.{u_4 u_2} Z B proj s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187    rw is_open_iff_forall_mem_open,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='is_open_iff_forall_mem_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 241, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {s : set.{u_2} α} [_inst_1 : topological_space.{u_2} α], iff (@is_open.{u_2} α _inst_1 s) (∀ (x : α), @has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) x s → @Exists.{u_2+1} (set.{u_2} α) (λ (t : set.{u_2} α), @Exists.{0} (@has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) t s) (λ (H : @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) t s), and (@is_open.{u_2} α _inst_1 t) (@has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) x t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s
⊢ @is_open.{u_2} B _inst_1 (@set.image.{u_4 u_2} Z B proj s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s
⊢ ∀ (x : B),
    @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s) →
    @Exists.{u_2+1} (set.{u_2} B)
      (λ (t : set.{u_2} B),
         @Exists.{0}
           (@has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s))
           (λ
            (H : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s)),
              and (@is_open.{u_2} B _inst_1 t) (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188    assume x xs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s
⊢ ∀ (x : B),
    @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s) →
    @Exists.{u_2+1} (set.{u_2} B)
      (λ (t : set.{u_2} B),
         @Exists.{0}
           (@has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s))
           (λ
            (H : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s)),
              and (@is_open.{u_2} B _inst_1 t) (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s)
⊢ @Exists.{u_2+1} (set.{u_2} B)
    (λ (t : set.{u_2} B),
       @Exists.{0}
         (@has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s))
         (λ (H : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s)),
            and (@is_open.{u_2} B _inst_1 t) (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189    obtain ⟨y, ys, yx⟩ : ∃ y, y ∈ s ∧ proj y = x, from (mem_image _ _ _).1 xs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.mem_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='xs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 897, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_4}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_4}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u_4} [c : has_mem.{u_4 u_4} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_4} Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_4} {β : Type u_2} (f : α → β) (s : set.{u_4} α) (y : β), iff (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y (@set.image.{u_4 u_2} α β f s)) (@Exists.{u_4+1} α (λ (x : α), and (@has_mem.mem.{u_4 u_4} α (set.{u_4} α) (@set.has_mem.{u_4} α) x s) (@eq.{u_2+1} β (f x) y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s)
⊢ @Exists.{u_2+1} (set.{u_2} B)
    (λ (t : set.{u_2} B),
       @Exists.{0}
         (@has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s))
         (λ (H : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s)),
            and (@is_open.{u_2} B _inst_1 t) (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s)
⊢ @Exists.{u_4+1} Z
    (λ (y : Z), and (@has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s) (@eq.{u_2+1} B (proj y) x))

B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x
⊢ @Exists.{u_2+1} (set.{u_2} B)
    (λ (t : set.{u_2} B),
       @Exists.{0}
         (@has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s))
         (λ (H : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s)),
            and (@is_open.{u_2} B _inst_1 t) (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x
⊢ @Exists.{u_2+1} (set.{u_2} B)
    (λ (t : set.{u_2} B),
       @Exists.{0}
         (@has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s))
         (λ (H : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s)),
            and (@is_open.{u_2} B _inst_1 t) (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190    obtain ⟨e, he⟩ : ∃ (e : bundle_trivialization F proj), y ∈ e.source, from h y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='bundle_trivialization'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 123, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u_2 u_3 u_4)}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {B : Type u_2} (F : Type u_3) {Z : Type u_4} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_4} Z] [_inst_3 : topological_space.{u_3} F], (Z → B) → Type (max u_2 u_3 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u_2 u_3 u_4)}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type (max u_2 u_3)}, local_equiv.{u_4 (max u_2 u_3)} α β → set.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A structure extending local homeomorphisms, defining a local trivialization of a projection
`proj : Z → B` with fiber `F`, as a local homeomorphism between `Z` and `B × F` defined between two
sets of the form `proj ⁻¹&#x27; base_set` and `base_set × F`, acting trivially on the first coordinate.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x
⊢ @Exists.{u_2+1} (set.{u_2} B)
    (λ (t : set.{u_2} B),
       @Exists.{0}
         (@has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s))
         (λ (H : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s)),
            and (@is_open.{u_2} B _inst_1 t) (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x
⊢ @Exists.{(max (u_2+1) (u_3+1) (u_4+1))} (@bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj)
    (λ (e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj),
       @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y
         (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))

B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
he :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
⊢ @Exists.{u_2+1} (set.{u_2} B)
    (λ (t : set.{u_2} B),
       @Exists.{0}
         (@has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s))
         (λ (H : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s)),
            and (@is_open.{u_2} B _inst_1 t) (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
he :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
⊢ @Exists.{u_2+1} (set.{u_2} B)
    (λ (t : set.{u_2} B),
       @Exists.{0}
         (@has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s))
         (λ (H : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s)),
            and (@is_open.{u_2} B _inst_1 t) (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191    refine ⟨proj &#x27;&#x27; (s ∩ e.source), image_subset _ (inter_subset_left _ _), _, ⟨y, ⟨ys, he⟩, yx⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.image_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.inter_subset_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ys'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='yx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 958, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, (α → β) → set.{u_4} α → set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_4} Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_4} [c : has_inter.{u_4} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type u_2} {a b : set.{u_4} α} (f : α → β), @has_subset.subset.{u_4} (set.{u_4} α) (@set.has_subset.{u_4} α) a b → @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) (@set.image.{u_4 u_2} α β f a) (@set.image.{u_4 u_2} α β f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_4} (s t : set.{u_4} α), @has_subset.subset.{u_4} (set.{u_4} α) (@set.has_subset.{u_4} α) (@has_inter.inter.{u_4} (set.{u_4} α) (@set.has_inter.{u_4} α) s t) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_2+1} B (proj y) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
he :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
⊢ @Exists.{u_2+1} (set.{u_2} B)
    (λ (t : set.{u_2} B),
       @Exists.{0}
         (@has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s))
         (λ (H : @has_subset.subset.{u_2} (set.{u_2} B) (@set.has_subset.{u_2} B) t (@set.image.{u_4 u_2} Z B proj s)),
            and (@is_open.{u_2} B _inst_1 t) (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
he :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
⊢ @is_open.{u_2} B _inst_1
    (@set.image.{u_4 u_2} Z B proj
       (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
          (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192    have : ∀z ∈ s ∩ e.source, prod.fst (e.to_fun z) = proj z := λz hz, e.proj_to_fun z hz.2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 123, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_4} Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_4} {β : Type (max u_2 u_3)}, local_equiv.{u_4 (max u_2 u_3)} α β → set.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
he :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
⊢ @is_open.{u_2} B _inst_1
    (@set.image.{u_4 u_2} Z B proj
       (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
          (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
he :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))),
this :
  ∀ (z : Z),
    @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) z
      (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
         (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))) →
    @eq.{u_2+1} B
      (@prod.fst.{u_2 u_3} B F
         (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
            z))
      (proj z)
⊢ @is_open.{u_2} B _inst_1
    (@set.image.{u_4 u_2} Z B proj
       (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
          (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193    rw [← image_congr this, image_comp],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.image_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.image_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 929, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type u_2} {f g : α → β} {s : set.{u_4} α}, (∀ (a : α), @has_mem.mem.{u_4 u_4} α (set.{u_4} α) (@set.has_mem.{u_4} α) a s → @eq.{u_2+1} β (f a) (g a)) → @eq.{(max (u_2+1) 1)} (set.{u_2} β) (@set.image.{u_4 u_2} α β f s) (@set.image.{u_4 u_2} α β g s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (z : Z), @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) z (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))) → @eq.{u_2+1} B (@prod.fst.{u_2 u_3} B F (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)) z)) (proj z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type (max u_2 u_3)} {γ : Type u_2} (f : β → γ) (g : α → β) (a : set.{u_4} α), @eq.{(max (u_2+1) 1)} (set.{u_2} γ) (@set.image.{u_4 u_2} α γ (@function.comp.{u_4+1 (max u_2 u_3)+1 u_2+1} α β γ f g) a) (@set.image.{(max u_2 u_3) u_2} β γ f (@set.image.{u_4 (max u_2 u_3)} α β g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
he :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))),
this :
  ∀ (z : Z),
    @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) z
      (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
         (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))) →
    @eq.{u_2+1} B
      (@prod.fst.{u_2 u_3} B F
         (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
            z))
      (proj z)
⊢ @is_open.{u_2} B _inst_1
    (@set.image.{u_4 u_2} Z B proj
       (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
          (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
he :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))),
this :
  ∀ (z : Z),
    @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) z
      (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
         (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))) →
    @eq.{u_2+1} B
      (@prod.fst.{u_2 u_3} B F
         (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
            z))
      (proj z)
⊢ @is_open.{u_2} B _inst_1
    (@set.image.{u_4 u_2} Z B
       (λ (z : Z),
          @prod.fst.{u_2 u_3} B F
            (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
               (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
               z))
       (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
          (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
he :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))),
this :
  ∀ (z : Z),
    @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) z
      (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
         (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))) →
    @eq.{u_2+1} B
      (@prod.fst.{u_2 u_3} B F
         (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
            z))
      (proj z)
⊢ @is_open.{u_2} B _inst_1
    (@set.image.{(max u_2 u_3) u_2} (prod.{u_2 u_3} B F) B (@prod.fst.{u_2 u_3} B F)
       (@set.image.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (λ (x : Z),
             @local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
               (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
               x)
          (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
             (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
                (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194    have : is_open (e.to_fun &#x27;&#x27; (s ∩ e.source)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u_2 u_3)} [t : topological_space.{(max u_2 u_3)} α], set.{(max u_2 u_3)} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type (max u_2 u_3)}, local_equiv.{u_4 (max u_2 u_3)} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_4} Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
he :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))),
this :
  ∀ (z : Z),
    @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) z
      (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
         (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))) →
    @eq.{u_2+1} B
      (@prod.fst.{u_2 u_3} B F
         (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
            z))
      (proj z)
⊢ @is_open.{u_2} B _inst_1
    (@set.image.{(max u_2 u_3) u_2} (prod.{u_2 u_3} B F) B (@prod.fst.{u_2 u_3} B F)
       (@set.image.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (λ (x : Z),
             @local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
               (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
               x)
          (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
             (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
                (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195      e.to_local_homeomorph.image_open_of_open (is_open_inter hs e.to_local_homeomorph.open_source)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='local_homeomorph.image_open_of_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 144, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 123, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type (max u_2 u_3)} [_inst_1 : topological_space.{u_4} α] [_inst_2 : topological_space.{(max u_2 u_3)} β] (e : @local_homeomorph.{u_4 (max u_2 u_3)} α β _inst_1 _inst_2) {s : set.{u_4} α}, @is_open.{u_4} α _inst_1 s → @has_subset.subset.{u_4} (set.{u_4} α) (@set.has_subset.{u_4} α) s (@local_equiv.source.{u_4 (max u_2 u_3)} α β (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} α β _inst_1 _inst_2 e)) → @is_open.{(max u_2 u_3)} β _inst_2 (@set.image.{u_4 (max u_2 u_3)} α β (@local_equiv.to_fun.{u_4 (max u_2 u_3)} α β (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} α β _inst_1 _inst_2 e)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_4} {s₁ s₂ : set.{u_4} α} [t : topological_space.{u_4} α], @is_open.{u_4} α t s₁ → @is_open.{u_4} α t s₂ → @is_open.{u_4} α t (@has_inter.inter.{u_4} (set.{u_4} α) (@set.has_inter.{u_4} α) s₁ s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u_4} Z _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The image of an open set in the source is open.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
he :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))),
this :
  ∀ (z : Z),
    @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) z
      (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
         (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))) →
    @eq.{u_2+1} B
      (@prod.fst.{u_2 u_3} B F
         (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
            z))
      (proj z)
⊢ @is_open.{u_2} B _inst_1
    (@set.image.{(max u_2 u_3) u_2} (prod.{u_2 u_3} B F) B (@prod.fst.{u_2 u_3} B F)
       (@set.image.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (λ (x : Z),
             @local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
               (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
               x)
          (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
             (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
                (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196      (inter_subset_right _ _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.inter_subset_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 387, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_4} (s t : set.{u_4} α), @has_subset.subset.{u_4} (set.{u_4} α) (@set.has_subset.{u_4} α) (@has_inter.inter.{u_4} (set.{u_4} α) (@set.has_inter.{u_4} α) s t) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
he :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))),
this :
  ∀ (z : Z),
    @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) z
      (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
         (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))) →
    @eq.{u_2+1} B
      (@prod.fst.{u_2 u_3} B F
         (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
            z))
      (proj z)
⊢ @is_open.{u_2} B _inst_1
    (@set.image.{(max u_2 u_3) u_2} (prod.{u_2 u_3} B F) B (@prod.fst.{u_2 u_3} B F)
       (@set.image.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (λ (x : Z),
             @local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
               (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
               x)
          (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
             (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
                (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
he :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))),
this :
  ∀ (z : Z),
    @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) z
      (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
         (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))) →
    @eq.{u_2+1} B
      (@prod.fst.{u_2 u_3} B F
         (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
            z))
      (proj z),
this :
  @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    (@set.image.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
       (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
          (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))))
⊢ @is_open.{u_2} B _inst_1
    (@set.image.{(max u_2 u_3) u_2} (prod.{u_2 u_3} B F) B (@prod.fst.{u_2 u_3} B F)
       (@set.image.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (λ (x : Z),
             @local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
               (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
               x)
          (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
             (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
                (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197    exact is_open_map_fst _ this</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_open_map_fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 205, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_3} β], @is_open_map.{(max u_2 u_3) u_2} (prod.{u_2 u_3} α β) α (@prod.topological_space.{u_2 u_3} α β _inst_1 _inst_2) _inst_1 (@prod.fst.{u_2 u_3} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@set.image.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))) (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The first projection in a product of topological spaces sends open sets to open sets.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
Z : Type u_4,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_4} Z,
_inst_3 : topological_space.{u_3} F,
proj : Z → B,
h : @is_topological_fiber_bundle.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
s : set.{u_4} Z,
hs : @is_open.{u_4} Z _inst_2 s,
x : B,
xs : @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@set.image.{u_4 u_2} Z B proj s),
y : Z,
ys : @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y s,
yx : @eq.{u_2+1} B (proj y) x,
e : @bundle_trivialization.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj,
he :
  @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) y
    (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))),
this :
  ∀ (z : Z),
    @has_mem.mem.{u_4 u_4} Z (set.{u_4} Z) (@set.has_mem.{u_4} Z) z
      (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
         (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))) →
    @eq.{u_2+1} B
      (@prod.fst.{u_2 u_3} B F
         (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
            z))
      (proj z),
this :
  @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    (@set.image.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
       (@local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))
       (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
          (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e)))))
⊢ @is_open.{u_2} B _inst_1
    (@set.image.{(max u_2 u_3) u_2} (prod.{u_2 u_3} B F) B (@prod.fst.{u_2 u_3} B F)
       (@set.image.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
          (λ (x : Z),
             @local_equiv.to_fun.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
               (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))
               x)
          (@has_inter.inter.{u_4} (set.{u_4} Z) (@set.has_inter.{u_4} Z) s
             (@local_equiv.source.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F)
                (@local_homeomorph.to_local_equiv.{u_4 (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 u_4} B F Z _inst_1 _inst_2 _inst_3 proj e))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200  /-- The first projection in a product is a topological fiber bundle. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201  lemma is_topological_fiber_bundle_fst : is_topological_fiber_bundle F (prod.fst : B × F → B) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='is_topological_fiber_bundle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;line&#x27;: 133, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Π {B : Type u_2} (F : Type u_3) {Z : Type u_4} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_4} Z] [_inst_3 : topological_space.{u_3} F], (Z → B) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v}, prod.{u v} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_3 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title=' A topological fiber bundle with fiber F over a base B is a space projecting on B for which the
fibers are all homeomorphic to F, such that the local situation around each point is a direct
product.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    _inst_3
    (@prod.fst.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203    let F : bundle_trivialization F (prod.fst : B × F → B) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='bundle_trivialization'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 123, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {B : Type u_2} (F : Type u_3) {Z : Type (max u_2 u_3)} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{(max u_2 u_3)} Z] [_inst_3 : topological_space.{u_3} F], (Z → B) → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2 → Type u_3 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A structure extending local homeomorphisms, defining a local trivialization of a projection
`proj : Z → B` with fiber `F`, as a local homeomorphism between `Z` and `B × F` defined between two
sets of the form `proj ⁻¹&#x27; base_set` and `base_set × F`, acting trivially on the first coordinate.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    _inst_3
    (@prod.fst.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204    { base_set      := univ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2}, set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    _inst_3
    (@prod.fst.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205      open_base_set := is_open_univ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='is_open_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [t : topological_space.{u_2} α], @is_open.{u_2} α t (@set.univ.{u_2} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    _inst_3
    (@prod.fst.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206      source_eq     := rfl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_2 u_3)} {a : α}, @eq.{(max ((max u_2 u_3)+1) 1)} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    _inst_3
    (@prod.fst.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207      target_eq     := by simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    _inst_3
    (@prod.fst.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @eq.{(max ((max u_2 u_3)+1) 1)}
    (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
       (prod.{u_2 u_3} B F)
       (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
             (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
             (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
             (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
             (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
    (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
             (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
             (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
             (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
             (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
    (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    _inst_3
    (@prod.fst.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208      proj_to_fun   := by simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    _inst_3
    (@prod.fst.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ ∀ (p : prod.{u_2 u_3} B F),
    @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
      (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β), set.{(max u_2 u_3)} α)
         (prod.{u_2 u_3} B F)
         (prod.{u_2 u_3} B F)
         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
            (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
               (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
               (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
               (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                  (prod.{u_2 u_3} B F)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
               (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                  (prod.{u_2 u_3} B F)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
      (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      p
      (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
            (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
               (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
               (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
               (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                  (prod.{u_2 u_3} B F)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
               (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                  (prod.{u_2 u_3} B F)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))))) →
    @eq.{u_2+1} B
      (@prod.fst.{u_2 u_3} B F
         (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
            (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
               (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                  (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                     (prod.{u_2 u_3} B F)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                     (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                        (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                  (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                     (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                        (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                  (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                     (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                        (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                  (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                     (prod.{u_2 u_3} B F)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                     (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                        (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                  (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                     (prod.{u_2 u_3} B F)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                     (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                     (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                        (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))))
            p))
      (@prod.fst.{u_2 u_3} B F p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    _inst_3
    (@prod.fst.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209       ..local_homeomorph.refl _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='local_homeomorph.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 212, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type (max u_2 u_3)) [_inst_5 : topological_space.{(max u_2 u_3)} α], @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} α α _inst_5 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The identity on the whole space as a local homeomorphism.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    _inst_3
    (@prod.fst.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F,
F : @bundle_trivialization.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
  _inst_3
  (@prod.fst.{u_2 u_3} B F) :=
  @bundle_trivialization.mk.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    _inst_3
    (@prod.fst.{u_2 u_3} B F)
    (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
       (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
       (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
       (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
       (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
       (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))
    (@set.univ.{u_2} B)
    (@is_open_univ.{u_2} B _inst_1)
    (@rfl.{(max ((max u_2 u_3)+1) 1)}
       (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β), set.{(max u_2 u_3)} α)
          (prod.{u_2 u_3} B F)
          (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))))))
    (@eq.mpr.{0}
       (@eq.{(max ((max u_2 u_3)+1) 1)}
          (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
              set.{(max u_2 u_3)} β)
             (prod.{u_2 u_3} B F)
             (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
          (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
          (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
       true
       (@id.{0}
          (@eq.{1} Prop
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
             true)
          (@eq.trans.{1} Prop
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@set.univ.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
                (@set.univ.{(max u_2 u_3)} (prod.{u_2 u_3} B F)))
             true
             ((λ
               (a a_1 :
                 @(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
               (e_1 :
                 @eq.{(max ((max u_2 u_3)+1) 1)}
                   (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                       set.{(max u_2 u_3)} β)
                      (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                   a
                   a_1)
               (a_2 a_3 :
                 @(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
               (e_2 :
                 @eq.{(max ((max u_2 u_3)+1) 1)}
                   (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                       set.{(max u_2 u_3)} β)
                      (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                   a_2
                   a_3),
                 @congr.{(max ((max u_2 u_3)+1) 1) 1}
                   (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                       set.{(max u_2 u_3)} β)
                      (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (… … …))
                   Prop
                   …
                   …
                   a_2
                   a_3
                   …
                   e_2)
                …
                …
                …
                …
                …
                …)
             …))
       trivial)
    …
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    _inst_3
    (@prod.fst.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210    exact λx, ⟨F, by simp⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@bundle_trivialization.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3) _inst_3 (@prod.fst.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F,
F : @bundle_trivialization.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
  _inst_3
  (@prod.fst.{u_2 u_3} B F) :=
  @bundle_trivialization.mk.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    _inst_3
    (@prod.fst.{u_2 u_3} B F)
    (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
       (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
       (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
       (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
       (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
       (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))
    (@set.univ.{u_2} B)
    (@is_open_univ.{u_2} B _inst_1)
    (@rfl.{(max ((max u_2 u_3)+1) 1)}
       (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β), set.{(max u_2 u_3)} α)
          (prod.{u_2 u_3} B F)
          (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))))))
    (@eq.mpr.{0}
       (@eq.{(max ((max u_2 u_3)+1) 1)}
          (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
              set.{(max u_2 u_3)} β)
             (prod.{u_2 u_3} B F)
             (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
          (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
          (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
       true
       (@id.{0}
          (@eq.{1} Prop
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
             true)
          (@eq.trans.{1} Prop
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@set.univ.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
                (@set.univ.{(max u_2 u_3)} (prod.{u_2 u_3} B F)))
             true
             ((λ
               (a a_1 :
                 @(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
               (e_1 :
                 @eq.{(max ((max u_2 u_3)+1) 1)}
                   (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                       set.{(max u_2 u_3)} β)
                      (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                   a
                   a_1)
               (a_2 a_3 :
                 @(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
               (e_2 :
                 @eq.{(max ((max u_2 u_3)+1) 1)}
                   (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                       set.{(max u_2 u_3)} β)
                      (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                   a_2
                   a_3),
                 @congr.{(max ((max u_2 u_3)+1) 1) 1}
                   (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                       set.{(max u_2 u_3)} β)
                      (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (… … …))
                   Prop
                   …
                   …
                   a_2
                   a_3
                   …
                   e_2)
                …
                …
                …
                …
                …
                …)
             …))
       trivial)
    …
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    _inst_3
    (@prod.fst.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F,
F : @bundle_trivialization.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
  _inst_3
  (@prod.fst.{u_2 u_3} B F) :=
  @bundle_trivialization.mk.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    _inst_3
    (@prod.fst.{u_2 u_3} B F)
    (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
       (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
       (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
       (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
       (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
       (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))
    (@set.univ.{u_2} B)
    (@is_open_univ.{u_2} B _inst_1)
    (@rfl.{(max ((max u_2 u_3)+1) 1)}
       (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β), set.{(max u_2 u_3)} α)
          (prod.{u_2 u_3} B F)
          (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))))))
    (@eq.mpr.{0}
       (@eq.{(max ((max u_2 u_3)+1) 1)}
          (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
              set.{(max u_2 u_3)} β)
             (prod.{u_2 u_3} B F)
             (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
          (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
          (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
       true
       (@id.{0}
          (@eq.{1} Prop
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
             true)
          (@eq.trans.{1} Prop
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@set.univ.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
                (@set.univ.{(max u_2 u_3)} (prod.{u_2 u_3} B F)))
             true
             ((λ
               (a a_1 :
                 @(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
               (e_1 :
                 @eq.{(max ((max u_2 u_3)+1) 1)}
                   (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                       set.{(max u_2 u_3)} β)
                      (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                   a
                   a_1)
               (a_2 a_3 :
                 @(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
               (e_2 :
                 @eq.{(max ((max u_2 u_3)+1) 1)}
                   (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                       set.{(max u_2 u_3)} β)
                      (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                   a_2
                   a_3),
                 @congr.{(max ((max u_2 u_3)+1) 1) 1}
                   (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                       set.{(max u_2 u_3)} β)
                      (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (… … …))
                   Prop
                   …
                   …
                   a_2
                   a_3
                   …
                   e_2)
                …
                …
                …
                …
                …
                …)
             …))
       trivial)
    …,
x : prod.{u_2 u_3} B F
⊢ @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    x
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             _inst_3
             (@prod.fst.{u_2 u_3} B F)
             F)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F,
F : @bundle_trivialization.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
  _inst_3
  (@prod.fst.{u_2 u_3} B F) :=
  @bundle_trivialization.mk.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    _inst_3
    (@prod.fst.{u_2 u_3} B F)
    (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
       (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
       (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
       (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
       (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
       (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))
    (@set.univ.{u_2} B)
    (@is_open_univ.{u_2} B _inst_1)
    (@rfl.{(max ((max u_2 u_3)+1) 1)}
       (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β), set.{(max u_2 u_3)} α)
          (prod.{u_2 u_3} B F)
          (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))))))
    (@eq.mpr.{0}
       (@eq.{(max ((max u_2 u_3)+1) 1)}
          (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
              set.{(max u_2 u_3)} β)
             (prod.{u_2 u_3} B F)
             (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
          (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                   (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
          (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
       true
       (@id.{0}
          (@eq.{1} Prop
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
             true)
          (@eq.trans.{1} Prop
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                (@set.univ.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
                (@set.univ.{(max u_2 u_3)} (prod.{u_2 u_3} B F)))
             true
             ((λ
               (a a_1 :
                 @(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
               (e_1 :
                 @eq.{(max ((max u_2 u_3)+1) 1)}
                   (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                       set.{(max u_2 u_3)} β)
                      (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                   a
                   a_1)
               (a_2 a_3 :
                 @(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                    set.{(max u_2 u_3)} β)
                   (prod.{u_2 u_3} B F)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
               (e_2 :
                 @eq.{(max ((max u_2 u_3)+1) 1)}
                   (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                       set.{(max u_2 u_3)} β)
                      (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)))
                            (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@local_homeomorph.refl.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                                  (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3))))))
                   a_2
                   a_3),
                 @congr.{(max ((max u_2 u_3)+1) 1) 1}
                   (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β),
                       set.{(max u_2 u_3)} β)
                      (prod.{u_2 u_3} B F)
                      (prod.{u_2 u_3} B F)
                      (… … …))
                   Prop
                   …
                   …
                   a_2
                   a_3
                   …
                   e_2)
                …
                …
                …
                …
                …
                …)
             …))
       trivial)
    …
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_2 u_3)} B F (prod.{u_2 u_3} B F) _inst_1
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
    _inst_3
    (@prod.fst.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213  /-- The second projection in a product is a topological fiber bundle. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214  lemma is_topological_fiber_bundle_snd : is_topological_fiber_bundle F (prod.snd : F × B → B) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='is_topological_fiber_bundle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;line&#x27;: 133, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Π {B : Type u_2} (F : Type u_3) {Z : Type u_4} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_4} Z] [_inst_3 : topological_space.{u_3} F], (Z → B) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v}, prod.{u v} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3 → Type u_2 → Type (max u_3 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title=' A topological fiber bundle with fiber F over a base B is a space projecting on B for which the
fibers are all homeomorphic to F, such that the local situation around each point is a direct
product.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
    (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
    _inst_3
    (@prod.snd.{u_3 u_2} F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216    let F : bundle_trivialization F (prod.snd : F × B → B) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='bundle_trivialization'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 123, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {B : Type u_2} (F : Type u_3) {Z : Type (max u_3 u_2)} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{(max u_3 u_2)} Z] [_inst_3 : topological_space.{u_3} F], (Z → B) → Type (max u_3 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, prod.{u_3 u_2} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_3 → Type u_2 → Type (max u_3 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A structure extending local homeomorphisms, defining a local trivialization of a projection
`proj : Z → B` with fiber `F`, as a local homeomorphism between `Z` and `B × F` defined between two
sets of the form `proj ⁻¹&#x27; base_set` and `base_set × F`, acting trivially on the first coordinate.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
    (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
    _inst_3
    (@prod.snd.{u_3 u_2} F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217    { base_set      := univ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2}, set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
    (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
    _inst_3
    (@prod.snd.{u_3 u_2} F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218      open_base_set := is_open_univ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='is_open_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [t : topological_space.{u_2} α], @is_open.{u_2} α t (@set.univ.{u_2} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
    (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
    _inst_3
    (@prod.snd.{u_3 u_2} F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219      source_eq     := rfl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_3 u_2)} {a : α}, @eq.{(max ((max u_3 u_2)+1) 1)} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
    (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
    _inst_3
    (@prod.snd.{u_3 u_2} F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220      target_eq     := by simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
    (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
    _inst_3
    (@prod.snd.{u_3 u_2} F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @eq.{(max ((max u_2 u_3)+1) 1)}
    (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)} (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β),
        set.{(max u_2 u_3)} β)
       (prod.{u_3 u_2} F B)
       (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
             (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
             (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
             (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
             (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
    (@local_equiv.target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
             (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
             (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
             (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
             (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
    (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
    (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
    _inst_3
    (@prod.snd.{u_3 u_2} F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221      proj_to_fun   := λp, by { simp, refl },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
    (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
    _inst_3
    (@prod.snd.{u_3 u_2} F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F,
p : prod.{u_3 u_2} F B
⊢ @has_mem.mem.{(max u_3 u_2) (max u_3 u_2)} (prod.{u_3 u_2} F B)
    (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)} (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β),
        set.{(max u_3 u_2)} α)
       (prod.{u_3 u_2} F B)
       (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
             (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
             (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
             (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
             (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
    (@set.has_mem.{(max u_3 u_2)} (prod.{u_3 u_2} F B))
    p
    (@local_equiv.source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
             (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
             (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
             (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
             (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))))) →
  @eq.{u_2+1} B
    (@prod.fst.{u_2 u_3} B F
       (@local_equiv.to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))))
          p))
    (@prod.snd.{u_3 u_2} F B p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F,
p : prod.{u_3 u_2} F B
⊢ @eq.{u_2+1} B
    (@prod.fst.{u_2 u_3} B F
       (@equiv.to_fun.{(max u_3 u_2)+1 (max u_2 u_3)+1} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@homeomorph.to_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))
          p))
    (@prod.snd.{u_3 u_2} F B p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
    (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
    _inst_3
    (@prod.snd.{u_3 u_2} F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222       ..(homeomorph.prod_comm F B).to_local_homeomorph },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='homeomorph.prod_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/homeomorph.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_3) (β : Type u_2) [_inst_1 : topological_space.{u_3} α] [_inst_2 : topological_space.{u_2} β], @homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} α β) (prod.{u_2 u_3} β α) (@prod.topological_space.{u_3 u_2} α β _inst_1 _inst_2) (@prod.topological_space.{u_2 u_3} β α _inst_2 _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
    (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
    _inst_3
    (@prod.snd.{u_3 u_2} F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F,
F : @bundle_trivialization.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
  (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
  _inst_3
  (@prod.snd.{u_3 u_2} F B) :=
  @bundle_trivialization.mk.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
    (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
    _inst_3
    (@prod.snd.{u_3 u_2} F B)
    (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
       (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
       (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
       (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
       (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
       (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
       (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
       (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))
    (@set.univ.{u_2} B)
    (@is_open_univ.{u_2} B _inst_1)
    (@rfl.{(max ((max u_3 u_2)+1) 1)}
       (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)} (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β),
           set.{(max u_3 u_2)} α)
          (prod.{u_3 u_2} F B)
          (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
       (@local_equiv.source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))))))
    (@eq.mpr.{0}
       (@eq.{(max ((max u_2 u_3)+1) 1)}
          (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
            (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
             (prod.{u_3 u_2} F B)
             (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
          (@local_equiv.target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
          (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
       true
       (@id.{0}
          (@eq.{1} Prop
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
                  (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
                   (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@local_equiv.target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
             true)
          (@eq.trans.{1} Prop
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
                  (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
                   (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@local_equiv.target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
                  (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
                   (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@set.univ.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
                (@set.univ.{(max u_2 u_3)} (prod.{u_2 u_3} B F)))
             true
             ((λ
               (a a_1 :
                 @(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
                  (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
                   (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) … …
                               …
                               …))
                         …
                         …
                         …
                         …))) (e_1 : …) (a_2 a_3 : …) (e_2 : …), …)
                …
                …
                …
                …
                …
                …)
             …))
       trivial)
    …
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
    (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
    _inst_3
    (@prod.snd.{u_3 u_2} F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223    exact λx, ⟨F, by simp⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@bundle_trivialization.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1 (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1) _inst_3 (@prod.snd.{u_3 u_2} F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F,
F : @bundle_trivialization.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
  (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
  _inst_3
  (@prod.snd.{u_3 u_2} F B) :=
  @bundle_trivialization.mk.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
    (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
    _inst_3
    (@prod.snd.{u_3 u_2} F B)
    (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
       (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
       (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
       (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
       (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
       (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
       (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
       (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))
    (@set.univ.{u_2} B)
    (@is_open_univ.{u_2} B _inst_1)
    (@rfl.{(max ((max u_3 u_2)+1) 1)}
       (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)} (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β),
           set.{(max u_3 u_2)} α)
          (prod.{u_3 u_2} F B)
          (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
       (@local_equiv.source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))))))
    (@eq.mpr.{0}
       (@eq.{(max ((max u_2 u_3)+1) 1)}
          (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
            (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
             (prod.{u_3 u_2} F B)
             (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
          (@local_equiv.target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
          (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
       true
       (@id.{0}
          (@eq.{1} Prop
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
                  (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
                   (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@local_equiv.target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
             true)
          (@eq.trans.{1} Prop
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
                  (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
                   (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@local_equiv.target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
                  (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
                   (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@set.univ.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
                (@set.univ.{(max u_2 u_3)} (prod.{u_2 u_3} B F)))
             true
             ((λ
               (a a_1 :
                 @(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
                  (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
                   (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) … …
                               …
                               …))
                         …
                         …
                         …
                         …))) (e_1 : …) (a_2 a_3 : …) (e_2 : …), …)
                …
                …
                …
                …
                …
                …)
             …))
       trivial)
    …
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
    (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
    _inst_3
    (@prod.snd.{u_3 u_2} F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F,
F : @bundle_trivialization.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
  (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
  _inst_3
  (@prod.snd.{u_3 u_2} F B) :=
  @bundle_trivialization.mk.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
    (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
    _inst_3
    (@prod.snd.{u_3 u_2} F B)
    (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
       (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
       (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
       (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
       (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
       (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
       (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
       (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))
    (@set.univ.{u_2} B)
    (@is_open_univ.{u_2} B _inst_1)
    (@rfl.{(max ((max u_3 u_2)+1) 1)}
       (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)} (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β),
           set.{(max u_3 u_2)} α)
          (prod.{u_3 u_2} F B)
          (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
       (@local_equiv.source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))))))
    (@eq.mpr.{0}
       (@eq.{(max ((max u_2 u_3)+1) 1)}
          (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
            (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
             (prod.{u_3 u_2} F B)
             (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
          (@local_equiv.target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
          (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
       true
       (@id.{0}
          (@eq.{1} Prop
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
                  (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
                   (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@local_equiv.target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
             true)
          (@eq.trans.{1} Prop
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
                  (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
                   (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@local_equiv.target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
                  (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
                   (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@set.univ.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
                (@set.univ.{(max u_2 u_3)} (prod.{u_2 u_3} B F)))
             true
             ((λ
               (a a_1 :
                 @(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
                  (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
                   (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) … …
                               …
                               …))
                         …
                         …
                         …
                         …))) (e_1 : …) (a_2 a_3 : …) (e_2 : …), …)
                …
                …
                …
                …
                …
                …)
             …))
       trivial)
    …,
x : prod.{u_3 u_2} F B
⊢ @has_mem.mem.{(max u_3 u_2) (max u_3 u_2)} (prod.{u_3 u_2} F B) (set.{(max u_3 u_2)} (prod.{u_3 u_2} F B))
    (@set.has_mem.{(max u_3 u_2)} (prod.{u_3 u_2} F B))
    x
    (@local_equiv.source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             _inst_3
             (@prod.snd.{u_3 u_2} F B)
             F)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_3 : topological_space.{u_3} F,
F : @bundle_trivialization.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
  (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
  _inst_3
  (@prod.snd.{u_3 u_2} F B) :=
  @bundle_trivialization.mk.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
    (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
    _inst_3
    (@prod.snd.{u_3 u_2} F B)
    (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
       (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
       (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
       (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
       (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
       (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
       (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
       (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
          (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))
    (@set.univ.{u_2} B)
    (@is_open_univ.{u_2} B _inst_1)
    (@rfl.{(max ((max u_3 u_2)+1) 1)}
       (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)} (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β),
           set.{(max u_3 u_2)} α)
          (prod.{u_3 u_2} F B)
          (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
       (@local_equiv.source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
             (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))))))
    (@eq.mpr.{0}
       (@eq.{(max ((max u_2 u_3)+1) 1)}
          (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
            (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
             (prod.{u_3 u_2} F B)
             (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
          (@local_equiv.target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                   (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                         (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
          (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
       true
       (@id.{0}
          (@eq.{1} Prop
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
                  (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
                   (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@local_equiv.target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
             true)
          (@eq.trans.{1} Prop
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
                  (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
                   (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@local_equiv.target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@set.prod.{u_2 u_3} B F (@set.univ.{u_2} B) (@set.univ.{u_3} F)))
             (@eq.{(max ((max u_2 u_3)+1) 1)}
                (@(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
                  (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
                   (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_source.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.open_target.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_to_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1)))
                         (@local_homeomorph.continuous_inv_fun.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                               (prod.{u_2 u_3} B F)
                               (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                               (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                               (@homeomorph.prod_comm.{u_3 u_2} F B _inst_3 _inst_1))))))
                (@set.univ.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
                (@set.univ.{(max u_2 u_3)} (prod.{u_2 u_3} B F)))
             true
             ((λ
               (a a_1 :
                 @(λ {α : Type (max u_3 u_2)} {β : Type (max u_2 u_3)}
                  (c : local_equiv.{(max u_3 u_2) (max u_2 u_3)} α β), set.{(max u_2 u_3)} β)
                   (prod.{u_3 u_2} F B)
                   (prod.{u_2 u_3} B F)
                   (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                      (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                      (@local_homeomorph.mk.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) (prod.{u_2 u_3} B F)
                         (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                         (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                         (@local_homeomorph.to_local_equiv.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B)
                            (prod.{u_2 u_3} B F)
                            (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
                            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)
                            (@homeomorph.to_local_homeomorph.{(max u_3 u_2) (max u_2 u_3)} (prod.{u_3 u_2} F B) … …
                               …
                               …))
                         …
                         …
                         …
                         …))) (e_1 : …) (a_2 a_3 : …) (e_2 : …), …)
                …
                …
                …
                …
                …
                …)
             …))
       trivial)
    …
⊢ @is_topological_fiber_bundle.{u_2 u_3 (max u_3 u_2)} B F (prod.{u_3 u_2} F B) _inst_1
    (@prod.topological_space.{u_3 u_2} F B _inst_3 _inst_1)
    _inst_3
    (@prod.snd.{u_3 u_2} F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226  end topological_fiber_bundle</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228  /-- Core data defining a locally trivial topological bundle with fiber `F` over a topological</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229  space `B`. Note that &quot;bundle&quot; is used in its mathematical sense. This is the (computer science)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230  bundled version, i.e., all the relevant data is contained in the following structure. A family of</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231  local trivializations is indexed by a type ι, on open subsets `base_set i` for each `i : ι`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232  Trivialization changes from `i` to `j` are given by continuous maps `coord_change i j` from</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233  `base_set i ∩ base_set j` to the set of homeomorphisms of `F`, but we express them as maps</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234  `B → F → F` and require continuity on `(base_set i ∩ base_set j) × F` to avoid the topology on the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235  space of continuous maps on `F`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236  structure topological_fiber_bundle_core (ι : Type*) (B : Type*) [topological_space B]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237    (F : Type*) [topological_space F] :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_3 → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238  (base_set          : ι → set B)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → set.{u_5} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239  (is_open_base_set  : ∀i, is_open (base_set i))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_5} [t : topological_space.{u_5} α], set.{u_5} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → set.{u_5} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240  (index_at          : B → ι)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='index_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='B → ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241  (mem_base_set_at   : ∀x, x ∈ base_set (index_at x))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='index_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_5} [c : has_mem.{u_5 u_5} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → set.{u_5} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='B → ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  (coord_change      : ι → ι → B → F → F)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coord_change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → ι → B → F → F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243  (coord_change_self : ∀i, ∀ x ∈ base_set i, ∀v, coord_change i i x v = v)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='coord_change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='ι → set.{u_5} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → ι → B → F → F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_6}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244  (coord_change_continuous : ∀i j, continuous_on (λp : B × F, coord_change i j p.1 p.2)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='continuous_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='coord_change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 242, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → set.{u_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_5 → Type u_6 → Type (max u_5 u_6)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → ι → B → F → F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_5 u_6} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_5} {β : Type u_6}, prod.{u_5 u_6} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u_5 u_6} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_5} {β : Type u_6}, prod.{u_5 u_6} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title=' A function between topological spaces is continuous on a subset `s`
when it&#x27;s continuous at every point of `s` within `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245                                                 (set.prod ((base_set i) ∩ (base_set j)) univ))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, set.{u_1} α → set.{u_2} β → set.{(max u_1 u_2)} (prod.{u_1 u_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='ι → set.{u_5} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_5} [c : has_inter.{u_5} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → set.{u_5} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246  (coord_change_comp : ∀i j k, ∀x ∈ (base_set i) ∩ (base_set j) ∩ (base_set k), ∀v,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='ι → set.{u_5} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_5} [c : has_inter.{u_5} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → set.{u_5} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_5} [c : has_inter.{u_5} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → set.{u_5} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247    (coord_change j k x) (coord_change i j x v) = coord_change i k x v)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='coord_change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='coord_change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coord_change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='ι → ι → B → F → F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='ι → ι → B → F → F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_6}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → ι → B → F → F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249  attribute [simp] topological_fiber_bundle_core.mem_base_set_at</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='topological_fiber_bundle_core.mem_base_set_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {ι : Type u_4} {B : Type u_5} [_inst_1 : topological_space.{u_5} B] {F : Type u_6} [_inst_2 : topological_space.{u_6} F] (c : @topological_fiber_bundle_core.{u_4 u_5 u_6} ι B _inst_1 F _inst_2) (x : B), @has_mem.mem.{u_5 u_5} B (set.{u_5} B) (@set.has_mem.{u_5} B) x (@topological_fiber_bundle_core.base_set.{u_4 u_5 u_6} ι B _inst_1 F _inst_2 c (@topological_fiber_bundle_core.index_at.{u_4 u_5 u_6} ι B _inst_1 F _inst_2 c x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251  namespace topological_fiber_bundle_core</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253  variables [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='topological_fiber_bundle_core'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_3 → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_4 → Π (B : Type u_5) [_inst_1 : topological_space.{u_5} B] (F : Type u_6) [_inst_2 : topological_space.{u_6} F], Type (max u_4 u_5 u_6)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title=' Core data defining a locally trivial topological bundle with fiber `F` over a topological
space `B`. Note that &quot;bundle&quot; is used in its mathematical sense. This is the (computer science)
bundled version, i.e., all the relevant data is contained in the following structure. A family of
local trivializations is indexed by a type ι, on open subsets `base_set i` for each `i : ι`.
Trivialization changes from `i` to `j` are given by continuous maps `coord_change i j` from
`base_set i ∩ base_set j` to the set of homeomorphisms of `F`, but we express them as maps
`B → F → F` and require continuity on `(base_set i ∩ base_set j) × F` to avoid the topology on the
space of continuous maps on `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255  include Z</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  /-- The index set of a topological fiber bundle core, as a convenience function for dot notation -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  @[nolint] def index := ι</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Do not report this declaration in any of the tests of `#lint`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260  /-- The base space of a topological fiber bundle core, as a convenience function for dot notation -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261  @[nolint] def base := B</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Do not report this declaration in any of the tests of `#lint`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263  /-- The fiber of a topological fiber bundle core, as a convenience function for dot notation and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264  typeclass inference -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265  @[nolint] def fiber (x : B) := F</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Do not report this declaration in any of the tests of `#lint`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267  instance topological_space_fiber (x : B) : topological_space (Z.fiber x) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.fiber'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 265, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → B → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' The fiber of a topological fiber bundle core, as a convenience function for dot notation and
typeclass inference'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  by { dsimp [fiber], apply_instance }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='topological_fiber_bundle_core.fiber'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 265, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type ?l_1} {B : Type ?l_2} {F : Type ?l_3} [_inst_1 : topological_space.{?l_2} B] [_inst_2 : topological_space.{?l_3} F], @topological_fiber_bundle_core.{?l_1 ?l_2 ?l_3} ι B _inst_1 F _inst_2 → B → Type ?l_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' The fiber of a topological fiber bundle core, as a convenience function for dot notation and
typeclass inference'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
x : B
⊢ topological_space.{u_3} (@topological_fiber_bundle_core.fiber.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
x : B
⊢ topological_space.{u_3} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270  /-- Total space of a topological bundle created from core. It is equal to `B × F`, but as it is</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  not marked as reducible, typeclass inference will not infer the wrong topology, and will use the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272  instance `topological_fiber_bundle_core.to_topological_space` with the right topology. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273  @[nolint] def total_space := B × F</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_3 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Do not report this declaration in any of the tests of `#lint`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275  /-- The projection from the total space of a topological fiber bundle core, on its base. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276  @[simp] def proj : Z.total_space → B := λp, p.1</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.total_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title=' Total space of a topological bundle created from core. It is equal to `B × F`, but as it is
not marked as reducible, typeclass inference will not infer the wrong topology, and will use the
instance `topological_fiber_bundle_core.to_topological_space` with the right topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278  /-- Local homeomorphism version of the trivialization change. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279  def triv_change (i j : ι) : local_homeomorph (B × F) (B × F) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='local_homeomorph'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u_5) (β : Type u_6) [_inst_5 : topological_space.{u_5} α] [_inst_6 : topological_space.{u_6} β], Type (max u_5 u_6)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_3 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_3 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='local homeomorphisms, defined on open subsets of the space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280  { source     := set.prod (Z.base_set i ∩ Z.base_set j) univ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, set.{u_1} α → set.{u_2} β → set.{(max u_1 u_2)} (prod.{u_1 u_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_inter.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281    target     := set.prod (Z.base_set i ∩ Z.base_set j) univ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, set.{u_1} α → set.{u_2} β → set.{(max u_1 u_2)} (prod.{u_1 u_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_inter.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282    to_fun     := λp, ⟨p.1, Z.coord_change i j p.1 p.2⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.coord_change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → ι → B → F → F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283    inv_fun    := λp, ⟨p.1, Z.coord_change j i p.1 p.2⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.coord_change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → ι → B → F → F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284    map_source := λp hp, by simpa using hp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)) (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F)) p (@set.prod.{u_2 u_3} B F (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)) (@set.univ.{u_3} F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)) (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F)) p (@set.prod.{u_2 u_3} B F (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)) (@set.univ.{u_3} F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
p : prod.{u_2 u_3} B F,
hp :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    p
    (@set.prod.{u_2 u_3} B F
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
       (@set.univ.{u_3} F))
⊢ @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F p)
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
          (@prod.fst.{u_2 u_3} B F p)
          (@prod.snd.{u_2 u_3} B F p)))
    (@set.prod.{u_2 u_3} B F
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
       (@set.univ.{u_3} F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285    map_target := λp hp, by simpa using hp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)) (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F)) p (@set.prod.{u_2 u_3} B F (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)) (@set.univ.{u_3} F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)) (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F)) p (@set.prod.{u_2 u_3} B F (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)) (@set.univ.{u_3} F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
p : prod.{u_2 u_3} B F,
hp :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    p
    (@set.prod.{u_2 u_3} B F
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
       (@set.univ.{u_3} F))
⊢ @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F p)
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
          (@prod.fst.{u_2 u_3} B F p)
          (@prod.snd.{u_2 u_3} B F p)))
    (@set.prod.{u_2 u_3} B F
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
       (@set.univ.{u_3} F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286    left_inv   := begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι
⊢ ∀ {x : prod.{u_2 u_3} B F},
    @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      x
      (@set.prod.{u_2 u_3} B F
         (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
            (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
            (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
         (@set.univ.{u_3} F)) →
    @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
      (@prod.mk.{u_2 u_3} B F
         (@prod.fst.{u_2 u_3} B F
            (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
               (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                  (@prod.fst.{u_2 u_3} B F x)
                  (@prod.snd.{u_2 u_3} B F x))))
         (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
            (@prod.fst.{u_2 u_3} B F
               (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                  (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                     (@prod.fst.{u_2 u_3} B F x)
                     (@prod.snd.{u_2 u_3} B F x))))
            (@prod.snd.{u_2 u_3} B F
               (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                  (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                     (@prod.fst.{u_2 u_3} B F x)
                     (@prod.snd.{u_2 u_3} B F x))))))
      x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287      rintros ⟨x, v⟩ hx,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι
⊢ ∀ {x : prod.{u_2 u_3} B F},
    @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      x
      (@set.prod.{u_2 u_3} B F
         (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
            (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
            (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
         (@set.univ.{u_3} F)) →
    @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
      (@prod.mk.{u_2 u_3} B F
         (@prod.fst.{u_2 u_3} B F
            (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
               (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                  (@prod.fst.{u_2 u_3} B F x)
                  (@prod.snd.{u_2 u_3} B F x))))
         (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
            (@prod.fst.{u_2 u_3} B F
               (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                  (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                     (@prod.fst.{u_2 u_3} B F x)
                     (@prod.snd.{u_2 u_3} B F x))))
            (@prod.snd.{u_2 u_3} B F
               (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                  (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                     (@prod.fst.{u_2 u_3} B F x)
                     (@prod.snd.{u_2 u_3} B F x))))))
      x'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@prod.mk.{u_2 u_3} B F x v)
    (@set.prod.{u_2 u_3} B F
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
       (@set.univ.{u_3} F))
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288      simp only [prod_mk_mem_set_prod_eq, mem_inter_eq, and_true, mem_univ] at hx,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set.prod_mk_mem_set_prod_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_inter_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and_true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1496, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 347, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 401, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 235, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {a : α} {b : β} {s : set.{?l_1} α} {t : set.{?l_2} β}, @eq.{1} Prop (@has_mem.mem.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (set.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)) (@set.has_mem.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)) (@prod.mk.{?l_1 ?l_2} α β a b) (@set.prod.{?l_1 ?l_2} α β s t)) (and (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a s) (@has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) b t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (x : α) (a b : set.{?l_1} α), @eq.{1} Prop (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x (@has_inter.inter.{?l_1} (set.{?l_1} α) (@set.has_inter.{?l_1} α) a b)) (and (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x a) (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : Prop), iff (and a true) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (x : α), @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x (@set.univ.{?l_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@prod.mk.{u_2 u_3} B F x v)
    (@set.prod.{u_2 u_3} B F
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
       (@set.univ.{u_3} F))
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289      rw [Z.coord_change_comp, Z.coord_change_self],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i j k : ι) (x : B), @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B) (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z k)) → ∀ (v : F), @eq.{u_3+1} F (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j k x (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j x v)) (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i k x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i : ι) (x : B), @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i) → ∀ (v : F), @eq.{u_3+1} F (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i i x v) v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i i
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))))
    (@prod.mk.{u_2 u_3} B F x v)

ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)

ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290      { exact hx.1 },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)) (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)

ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291      { simp [hx] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)) (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293    right_inv  := begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι
⊢ ∀ {x : prod.{u_2 u_3} B F},
    @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      x
      (@set.prod.{u_2 u_3} B F
         (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
            (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
            (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
         (@set.univ.{u_3} F)) →
    @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
      (@prod.mk.{u_2 u_3} B F
         (@prod.fst.{u_2 u_3} B F
            (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
               (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                  (@prod.fst.{u_2 u_3} B F x)
                  (@prod.snd.{u_2 u_3} B F x))))
         (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
            (@prod.fst.{u_2 u_3} B F
               (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                  (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                     (@prod.fst.{u_2 u_3} B F x)
                     (@prod.snd.{u_2 u_3} B F x))))
            (@prod.snd.{u_2 u_3} B F
               (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                  (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                     (@prod.fst.{u_2 u_3} B F x)
                     (@prod.snd.{u_2 u_3} B F x))))))
      x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294      rintros ⟨x, v⟩ hx,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι
⊢ ∀ {x : prod.{u_2 u_3} B F},
    @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      x
      (@set.prod.{u_2 u_3} B F
         (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
            (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
            (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
         (@set.univ.{u_3} F)) →
    @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
      (@prod.mk.{u_2 u_3} B F
         (@prod.fst.{u_2 u_3} B F
            (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
               (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                  (@prod.fst.{u_2 u_3} B F x)
                  (@prod.snd.{u_2 u_3} B F x))))
         (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
            (@prod.fst.{u_2 u_3} B F
               (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                  (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                     (@prod.fst.{u_2 u_3} B F x)
                     (@prod.snd.{u_2 u_3} B F x))))
            (@prod.snd.{u_2 u_3} B F
               (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                  (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                     (@prod.fst.{u_2 u_3} B F x)
                     (@prod.snd.{u_2 u_3} B F x))))))
      x'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@prod.mk.{u_2 u_3} B F x v)
    (@set.prod.{u_2 u_3} B F
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
       (@set.univ.{u_3} F))
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295      simp only [prod_mk_mem_set_prod_eq, mem_inter_eq, and_true, mem_univ] at hx,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set.prod_mk_mem_set_prod_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_inter_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and_true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1496, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 347, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 401, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 235, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {a : α} {b : β} {s : set.{?l_1} α} {t : set.{?l_2} β}, @eq.{1} Prop (@has_mem.mem.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (set.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)) (@set.has_mem.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)) (@prod.mk.{?l_1 ?l_2} α β a b) (@set.prod.{?l_1 ?l_2} α β s t)) (and (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a s) (@has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) b t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (x : α) (a b : set.{?l_1} α), @eq.{1} Prop (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x (@has_inter.inter.{?l_1} (set.{?l_1} α) (@set.has_inter.{?l_1} α) a b)) (and (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x a) (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : Prop), iff (and a true) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (x : α), @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x (@set.univ.{?l_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@prod.mk.{u_2 u_3} B F x v)
    (@set.prod.{u_2 u_3} B F
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
       (@set.univ.{u_3} F))
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296      rw [Z.coord_change_comp, Z.coord_change_self],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i j k : ι) (x : B), @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B) (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z k)) → ∀ (v : F), @eq.{u_3+1} F (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j k x (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j x v)) (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i k x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i : ι) (x : B), @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i) → ∀ (v : F), @eq.{u_3+1} F (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i i x v) v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j j
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))))
    (@prod.mk.{u_2 u_3} B F x v)

ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)

ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>297      { exact hx.2 },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)) (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)

ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>298      { simp [hx] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)) (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>299    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>300    open_source :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>301      is_open_prod (is_open_inter (Z.is_open_base_set i) (Z.is_open_base_set j)) is_open_univ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_open_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.is_open_base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.is_open_base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_open_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 128, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{v} β] {s : set.{u} α} {t : set.{v} β}, @is_open.{u} α _inst_1 s → @is_open.{v} β _inst_2 t → @is_open.{(max u v)} (prod.{u v} α β) (@prod.topological_space.{u v} α β _inst_1 _inst_2) (@set.prod.{u v} α β s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} {s₁ s₂ : set.{u_2} α} [t : topological_space.{u_2} α], @is_open.{u_2} α t s₁ → @is_open.{u_2} α t s₂ → @is_open.{u_2} α t (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) s₁ s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F] (c : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2) (i : ι), @is_open.{u_2} B _inst_1 (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 c i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F] (c : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2) (i : ι), @is_open.{u_2} B _inst_1 (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 c i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_3} [t : topological_space.{u_3} α], @is_open.{u_3} α t (@set.univ.{u_3} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>302    open_target :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>303      is_open_prod (is_open_inter (Z.is_open_base_set i) (Z.is_open_base_set j)) is_open_univ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_open_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.is_open_base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.is_open_base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_open_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 128, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{v} β] {s : set.{u} α} {t : set.{v} β}, @is_open.{u} α _inst_1 s → @is_open.{v} β _inst_2 t → @is_open.{(max u v)} (prod.{u v} α β) (@prod.topological_space.{u v} α β _inst_1 _inst_2) (@set.prod.{u v} α β s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} {s₁ s₂ : set.{u_2} α} [t : topological_space.{u_2} α], @is_open.{u_2} α t s₁ → @is_open.{u_2} α t s₂ → @is_open.{u_2} α t (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) s₁ s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F] (c : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2) (i : ι), @is_open.{u_2} B _inst_1 (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 c i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F] (c : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2) (i : ι), @is_open.{u_2} B _inst_1 (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 c i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_3} [t : topological_space.{u_3} α], @is_open.{u_3} α t (@set.univ.{u_3} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>304    continuous_to_fun  :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>305      continuous_on.prod continuous_fst.continuous_on (Z.coord_change_continuous i j),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='continuous_on.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='continuous.continuous_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.coord_change_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 543, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 115, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 417, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β] [_inst_3 : topological_space.{u_3} γ] {f : α → β} {g : α → γ} {s : set.{u_1} α}, @continuous_on.{u_1 u_2} α β _inst_1 _inst_2 f s → @continuous_on.{u_1 u_3} α γ _inst_1 _inst_3 g s → @continuous_on.{u_1 (max u_2 u_3)} α (prod.{u_2 u_3} β γ) _inst_1 (@prod.topological_space.{u_2 u_3} β γ _inst_2 _inst_3) (λ (x : α), @prod.mk.{u_2 u_3} β γ (f x) (g x)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_3} β], @continuous.{(max u_2 u_3) u_2} (prod.{u_2 u_3} α β) α (@prod.topological_space.{u_2 u_3} α β _inst_1 _inst_2) _inst_1 (@prod.fst.{u_2 u_3} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_2 u_3)} {β : Type u_2} [_inst_1 : topological_space.{(max u_2 u_3)} α] [_inst_2 : topological_space.{u_2} β] {f : α → β} {s : set.{(max u_2 u_3)} α}, @continuous.{(max u_2 u_3) u_2} α β _inst_1 _inst_2 f → @continuous_on.{(max u_2 u_3) u_2} α β _inst_1 _inst_2 f s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F] (c : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2) (i j : ι), @continuous_on.{(max u_2 u_3) u_3} (prod.{u_2 u_3} B F) F (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) _inst_2 (λ (p : prod.{u_2 u_3} B F), @topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 c i j (@prod.fst.{u_2 u_3} B F p) (@prod.snd.{u_2 u_3} B F p)) (@set.prod.{u_2 u_3} B F (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 c i) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 c j)) (@set.univ.{u_3} F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>306    continuous_inv_fun := by simpa [inter_comm]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='set.inter_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 367, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (a b : set.{?l_1} α), @eq.{?l_1+1} (set.{?l_1} α) (@has_inter.inter.{?l_1} (set.{?l_1} α) (@set.has_inter.{?l_1} α) a b) (@has_inter.inter.{?l_1} (set.{?l_1} α) (@set.has_inter.{?l_1} α) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι
⊢ @continuous_on.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (λ (p : prod.{u_2 u_3} B F),
       @prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F p)
         (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
            (@prod.fst.{u_2 u_3} B F p)
            (@prod.snd.{u_2 u_3} B F p)))
    (@set.prod.{u_2 u_3} B F
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
       (@set.univ.{u_3} F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>307      using continuous_on.prod continuous_fst.continuous_on (Z.coord_change_continuous j i) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='continuous_on.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 543, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 115, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_2 u_3)} {β : Type u_2} {γ : Type u_3} [_inst_1 : topological_space.{(max u_2 u_3)} α] [_inst_2 : topological_space.{u_2} β] [_inst_3 : topological_space.{u_3} γ] {f : α → β} {g : α → γ} {s : set.{(max u_2 u_3)} α}, @continuous_on.{(max u_2 u_3) u_2} α β _inst_1 _inst_2 f s → @continuous_on.{(max u_2 u_3) u_3} α γ _inst_1 _inst_3 g s → @continuous_on.{(max u_2 u_3) (max u_2 u_3)} α (prod.{u_2 u_3} β γ) _inst_1 (@prod.topological_space.{u_2 u_3} β γ _inst_2 _inst_3) (λ (x : α), @prod.mk.{u_2 u_3} β γ (f x) (g x)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_3} β], @continuous.{(max u_2 u_3) u_2} (prod.{u_2 u_3} α β) α (@prod.topological_space.{u_2 u_3} α β _inst_1 _inst_2) _inst_1 (@prod.fst.{u_2 u_3} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι
⊢ @continuous_on.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (λ (p : prod.{u_2 u_3} B F),
       @prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F p)
         (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j i
            (@prod.fst.{u_2 u_3} B F p)
            (@prod.snd.{u_2 u_3} B F p)))
    (@set.prod.{u_2 u_3} B F
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
       (@set.univ.{u_3} F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>308  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>309  @[simp] lemma mem_triv_change_source (i j : ι) (p : B × F) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_3 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>310    p ∈ (Z.triv_change i j).source ↔ p.1 ∈ Z.base_set i ∩ Z.base_set j :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.triv_change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 279, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type (max u_2 u_3)} [c : has_mem.{(max u_2 u_3) (max u_2 u_3)} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → ι → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → set.{(max u_2 u_3)} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_inter.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Local homeomorphism version of the trivialization change.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>311  by { erw [mem_prod], simp }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.mem_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1415, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} {s : set.{u_2} α} {t : set.{u_3} β} {p : prod.{u_2 u_3} α β}, iff (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} α β) (set.{(max u_2 u_3)} (prod.{u_2 u_3} α β)) (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} α β)) p (@set.prod.{u_2 u_3} α β s t)) (and (@has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) (@prod.fst.{u_2 u_3} α β p) s) (@has_mem.mem.{u_3 u_3} β (set.{u_3} β) (@set.has_mem.{u_3} β) (@prod.snd.{u_2 u_3} α β p) t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
p : prod.{u_2 u_3} B F
⊢ iff
    (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       p
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
             (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j))))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (@prod.fst.{u_2 u_3} B F p)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
p : prod.{u_2 u_3} B F
⊢ iff
    (and
       (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (@prod.fst.{u_2 u_3} B F p)
          (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
             (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
             (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)))
       (@has_mem.mem.{u_3 u_3} F (set.{u_3} F) (@set.has_mem.{u_3} F) (@prod.snd.{u_2 u_3} B F p) (@set.univ.{u_3} F)))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (@prod.fst.{u_2 u_3} B F p)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>312  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>313  /-- Associate to a trivialization index `i : ι` the corresponding trivialization, i.e., a bijection</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>314  between `proj ⁻¹ (base_set i)` and `base_set i × F`. As the fiber above `x` is `F` but read in the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>315  chart with index `index_at x`, the trivialization in the fiber above x is by definition the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>316  coordinate change from i to `index_at x`, so it depends on `x`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>317  The local trivialization will ultimately be a local homeomorphism. For now, we only introduce the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>318  local equiv version, denoted with a prime. In further developments, avoid this auxiliary version,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>319  and use Z.local_triv instead.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>320  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>321  def local_triv&#x27; (i : ι) : local_equiv Z.total_space (B × F) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='local_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.total_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_5 → Type u_6 → Type (max u_5 u_6)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_3 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title=' Local equivalence between subsets `source` and `target` of α and β respectively. The (global)
maps `to_fun : α → β` and `inv_fun : β → α` map `source` to `target` and conversely, and are inverse
to each other there. The values of `to_fun` outside of `source` and of `inv_fun` outside of `target`
are irrelevant.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Total space of a topological bundle created from core. It is equal to `B × F`, but as it is
not marked as reducible, typeclass inference will not infer the wrong topology, and will use the
instance `topological_fiber_bundle_core.to_topological_space` with the right topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>322  { source     := Z.proj ⁻¹&#x27; (Z.base_set i),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_2 u_3)} {β : Type u_2}, (α → β) → set.{u_2} β → set.{(max u_2 u_3)} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The projection from the total space of a topological fiber bundle core, on its base.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>323    target     := set.prod (Z.base_set i) univ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, set.{u_1} α → set.{u_2} β → set.{(max u_1 u_2)} (prod.{u_1 u_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>324    inv_fun    := λp, ⟨p.1, Z.coord_change i (Z.index_at p.1) p.1 p.2⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.coord_change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.index_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → ι → B → F → F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → B → ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>325    to_fun     := λp, ⟨p.1, Z.coord_change (Z.index_at p.1) i p.1 p.2⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.coord_change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.index_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → ι → B → F → F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → B → ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>326    map_source := λp hp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)) (@set.has_mem.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)) p (@set.preimage.{(max u_2 u_3) u_2} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) B (@topological_fiber_bundle_core.proj.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>327      by simpa only [set.mem_preimage, and_true, set.mem_univ, set.prod_mk_mem_set_prod_eq] using hp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='set.mem_preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and_true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.prod_mk_mem_set_prod_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 838, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 401, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 235, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1496, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {f : α → β} {s : set.{?l_2} β} {a : α}, iff (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@set.preimage.{?l_1 ?l_2} α β f s)) (@has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) (f a) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : Prop), iff (and a true) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (x : α), @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x (@set.univ.{?l_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {a : α} {b : β} {s : set.{?l_1} α} {t : set.{?l_2} β}, @eq.{1} Prop (@has_mem.mem.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (set.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)) (@set.has_mem.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)) (@prod.mk.{?l_1 ?l_2} α β a b) (@set.prod.{?l_1 ?l_2} α β s t)) (and (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a s) (@has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) b t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)) (@set.has_mem.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)) p (@set.preimage.{(max u_2 u_3) u_2} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) B (@topological_fiber_bundle_core.proj.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
p : @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z,
hp :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (@set.has_mem.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    p
    (@set.preimage.{(max u_2 u_3) u_2}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       B
       (@topological_fiber_bundle_core.proj.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
⊢ @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F p)
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z (@prod.fst.{u_2 u_3} B F p))
          i
          (@prod.fst.{u_2 u_3} B F p)
          (@prod.snd.{u_2 u_3} B F p)))
    (@set.prod.{u_2 u_3} B F (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
       (@set.univ.{u_3} F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>328    map_target := λp hp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)) (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F)) p (@set.prod.{u_2 u_3} B F (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i) (@set.univ.{u_3} F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>329      by simpa only [set.mem_preimage, and_true, set.mem_univ, set.mem_prod] using hp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='set.mem_preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and_true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 838, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 401, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 235, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1415, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {f : α → β} {s : set.{?l_2} β} {a : α}, iff (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@set.preimage.{?l_1 ?l_2} α β f s)) (@has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) (f a) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : Prop), iff (and a true) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (x : α), @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x (@set.univ.{?l_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {s : set.{?l_1} α} {t : set.{?l_2} β} {p : prod.{?l_1 ?l_2} α β}, iff (@has_mem.mem.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (set.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)) (@set.has_mem.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)) p (@set.prod.{?l_1 ?l_2} α β s t)) (and (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) (@prod.fst.{?l_1 ?l_2} α β p) s) (@has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) (@prod.snd.{?l_1 ?l_2} α β p) t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)) (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F)) p (@set.prod.{u_2 u_3} B F (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i) (@set.univ.{u_3} F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
p : prod.{u_2 u_3} B F,
hp :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    p
    (@set.prod.{u_2 u_3} B F (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
       (@set.univ.{u_3} F))
⊢ @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (@set.has_mem.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F p)
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z (@prod.fst.{u_2 u_3} B F p))
          (@prod.fst.{u_2 u_3} B F p)
          (@prod.snd.{u_2 u_3} B F p)))
    (@set.preimage.{(max u_2 u_3) u_2}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       B
       (@topological_fiber_bundle_core.proj.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>330    left_inv   := begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ ∀ {x : @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z},
    @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
      (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
      (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
      (@set.has_mem.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
      x
      (@set.preimage.{(max u_2 u_3) u_2}
         (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
         B
         (@topological_fiber_bundle_core.proj.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
         (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)) →
    @eq.{(max u_2 u_3)+1} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
      (@prod.mk.{u_2 u_3} B F
         (@prod.fst.{u_2 u_3} B F
            (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
               (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                  (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                     (@prod.fst.{u_2 u_3} B F x))
                  i
                  (@prod.fst.{u_2 u_3} B F x)
                  (@prod.snd.{u_2 u_3} B F x))))
         (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
            (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
               (@prod.fst.{u_2 u_3} B F
                  (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                     (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                        (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                           (@prod.fst.{u_2 u_3} B F x))
                        i
                        (@prod.fst.{u_2 u_3} B F x)
                        (@prod.snd.{u_2 u_3} B F x)))))
            (@prod.fst.{u_2 u_3} B F
               (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                  (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                     (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                        (@prod.fst.{u_2 u_3} B F x))
                     i
                     (@prod.fst.{u_2 u_3} B F x)
                     (@prod.snd.{u_2 u_3} B F x))))
            (@prod.snd.{u_2 u_3} B F
               (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                  (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                     (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                        (@prod.fst.{u_2 u_3} B F x))
                     i
                     (@prod.fst.{u_2 u_3} B F x)
                     (@prod.snd.{u_2 u_3} B F x))))))
      x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>331      rintros ⟨x, v⟩ hx,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ ∀ {x : @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z},
    @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
      (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
      (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
      (@set.has_mem.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
      x
      (@set.preimage.{(max u_2 u_3) u_2}
         (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
         B
         (@topological_fiber_bundle_core.proj.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
         (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)) →
    @eq.{(max u_2 u_3)+1} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
      (@prod.mk.{u_2 u_3} B F
         (@prod.fst.{u_2 u_3} B F
            (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
               (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                  (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                     (@prod.fst.{u_2 u_3} B F x))
                  i
                  (@prod.fst.{u_2 u_3} B F x)
                  (@prod.snd.{u_2 u_3} B F x))))
         (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
            (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
               (@prod.fst.{u_2 u_3} B F
                  (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                     (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                        (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                           (@prod.fst.{u_2 u_3} B F x))
                        i
                        (@prod.fst.{u_2 u_3} B F x)
                        (@prod.snd.{u_2 u_3} B F x)))))
            (@prod.fst.{u_2 u_3} B F
               (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                  (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                     (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                        (@prod.fst.{u_2 u_3} B F x))
                     i
                     (@prod.fst.{u_2 u_3} B F x)
                     (@prod.snd.{u_2 u_3} B F x))))
            (@prod.snd.{u_2 u_3} B F
               (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                  (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                     (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                        (@prod.fst.{u_2 u_3} B F x))
                     i
                     (@prod.fst.{u_2 u_3} B F x)
                     (@prod.snd.{u_2 u_3} B F x))))))
      x'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (@set.has_mem.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (@prod.mk.{u_2 u_3} B F x v)
    (@set.preimage.{(max u_2 u_3) u_2}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       B
       (@topological_fiber_bundle_core.proj.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
⊢ @eq.{(max u_2 u_3)+1} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                i
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@prod.fst.{u_2 u_3} B F
                (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                         (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                      i
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                      (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))))))
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                   i
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                   i
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>332      change x ∈ Z.base_set i at hx,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (@set.has_mem.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (@prod.mk.{u_2 u_3} B F x v)
    (@set.preimage.{(max u_2 u_3) u_2}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       B
       (@topological_fiber_bundle_core.proj.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
⊢ @eq.{(max u_2 u_3)+1} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                i
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@prod.fst.{u_2 u_3} B F
                (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                         (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                      i
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                      (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))))))
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                   i
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                   i
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @eq.{(max u_2 u_3)+1} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                i
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@prod.fst.{u_2 u_3} B F
                (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                         (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                      i
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                      (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))))))
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                   i
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                   i
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>333      dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @eq.{(max u_2 u_3)+1} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                i
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@prod.fst.{u_2 u_3} B F
                (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                         (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                      i
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                      (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))))))
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                   i
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                   i
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @eq.{(max u_2 u_3)+1} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@prod.mk.{u_2 u_3} B F x
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x)
          x
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x)
             i
             x
             v)))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>334      rw [Z.coord_change_comp, Z.coord_change_self],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i j k : ι) (x : B), @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B) (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z k)) → ∀ (v : F), @eq.{u_3+1} F (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j k x (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j x v)) (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i k x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i : ι) (x : B), @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i) → ∀ (v : F), @eq.{u_3+1} F (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i i x v) v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @eq.{(max u_2 u_3)+1} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@prod.mk.{u_2 u_3} B F x
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x)
          x
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x)
             i
             x
             v)))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @eq.{(max u_2 u_3)+1} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@prod.mk.{u_2 u_3} B F x
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x)
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x)
          x
          v))
    (@prod.mk.{u_2 u_3} B F x v)

ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x))
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
       (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x))

ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x))
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>335      { exact Z.mem_base_set_at _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
       (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x))

ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x))
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
       (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x))
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>336      { simp [hx] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x))
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>337    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>338    right_inv := begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ ∀ {x : prod.{u_2 u_3} B F},
    @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      x
      (@set.prod.{u_2 u_3} B F (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
         (@set.univ.{u_3} F)) →
    @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
      (@prod.mk.{u_2 u_3} B F
         (@prod.fst.{u_2 u_3} B F
            (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
               (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                  (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                     (@prod.fst.{u_2 u_3} B F x))
                  (@prod.fst.{u_2 u_3} B F x)
                  (@prod.snd.{u_2 u_3} B F x))))
         (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
            (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
               (@prod.fst.{u_2 u_3} B F
                  (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                     (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                        (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                           (@prod.fst.{u_2 u_3} B F x))
                        (@prod.fst.{u_2 u_3} B F x)
                        (@prod.snd.{u_2 u_3} B F x)))))
            i
            (@prod.fst.{u_2 u_3} B F
               (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                  (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                     (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                        (@prod.fst.{u_2 u_3} B F x))
                     (@prod.fst.{u_2 u_3} B F x)
                     (@prod.snd.{u_2 u_3} B F x))))
            (@prod.snd.{u_2 u_3} B F
               (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                  (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                     (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                        (@prod.fst.{u_2 u_3} B F x))
                     (@prod.fst.{u_2 u_3} B F x)
                     (@prod.snd.{u_2 u_3} B F x))))))
      x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>339      rintros ⟨x, v⟩ hx,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ ∀ {x : prod.{u_2 u_3} B F},
    @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      x
      (@set.prod.{u_2 u_3} B F (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
         (@set.univ.{u_3} F)) →
    @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
      (@prod.mk.{u_2 u_3} B F
         (@prod.fst.{u_2 u_3} B F
            (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
               (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                  (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                     (@prod.fst.{u_2 u_3} B F x))
                  (@prod.fst.{u_2 u_3} B F x)
                  (@prod.snd.{u_2 u_3} B F x))))
         (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
            (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
               (@prod.fst.{u_2 u_3} B F
                  (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                     (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                        (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                           (@prod.fst.{u_2 u_3} B F x))
                        (@prod.fst.{u_2 u_3} B F x)
                        (@prod.snd.{u_2 u_3} B F x)))))
            i
            (@prod.fst.{u_2 u_3} B F
               (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                  (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                     (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                        (@prod.fst.{u_2 u_3} B F x))
                     (@prod.fst.{u_2 u_3} B F x)
                     (@prod.snd.{u_2 u_3} B F x))))
            (@prod.snd.{u_2 u_3} B F
               (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F x)
                  (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                     (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                        (@prod.fst.{u_2 u_3} B F x))
                     (@prod.fst.{u_2 u_3} B F x)
                     (@prod.snd.{u_2 u_3} B F x))))))
      x'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@prod.mk.{u_2 u_3} B F x v)
    (@set.prod.{u_2 u_3} B F (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
       (@set.univ.{u_3} F))
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@prod.fst.{u_2 u_3} B F
                (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                      (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                         (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                      (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))))))
          i
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                   (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                   (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>340      simp only [prod_mk_mem_set_prod_eq, and_true, mem_univ] at hx,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set.prod_mk_mem_set_prod_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and_true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1496, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 401, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 235, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {a : α} {b : β} {s : set.{?l_1} α} {t : set.{?l_2} β}, @eq.{1} Prop (@has_mem.mem.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (set.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)) (@set.has_mem.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)) (@prod.mk.{?l_1 ?l_2} α β a b) (@set.prod.{?l_1 ?l_2} α β s t)) (and (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a s) (@has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) b t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : Prop), iff (and a true) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (x : α), @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x (@set.univ.{?l_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@prod.mk.{u_2 u_3} B F x v)
    (@set.prod.{u_2 u_3} B F (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
       (@set.univ.{u_3} F))
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@prod.fst.{u_2 u_3} B F
                (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                      (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                         (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                      (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))))))
          i
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                   (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                   (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@prod.fst.{u_2 u_3} B F
                (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                      (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                         (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                      (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))))))
          i
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                   (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                   (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>341      rw [Z.coord_change_comp, Z.coord_change_self],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i j k : ι) (x : B), @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B) (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z k)) → ∀ (v : F), @eq.{u_3+1} F (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j k x (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j x v)) (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i k x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i : ι) (x : B), @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i) → ∀ (v : F), @eq.{u_3+1} F (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i i x v) v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@prod.fst.{u_2 u_3} B F
                (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                      (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                         (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                      (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))))))
          i
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                   (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                   (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))))
    (@prod.mk.{u_2 u_3} B F x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@prod.mk.{u_2 u_3} B F
       (@prod.fst.{u_2 u_3} B F
          (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i i
          (@prod.fst.{u_2 u_3} B F
             (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                   (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                      (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                   (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                   (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
          (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))))
    (@prod.mk.{u_2 u_3} B F x v)

ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                (@prod.fst.{u_2 u_3} B F
                   (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                      (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                         (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                            (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                         (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                         (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))))))))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)

ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                (@prod.fst.{u_2 u_3} B F
                   (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                      (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                         (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                            (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                         (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                         (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))))))))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>342      { exact hx },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)

ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                (@prod.fst.{u_2 u_3} B F
                   (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                      (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                         (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                            (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                         (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                         (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))))))))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                (@prod.fst.{u_2 u_3} B F
                   (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                      (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                         (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                            (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                         (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                         (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))))))))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>343      { simp [hx] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
    (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
⊢ @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B)
    (@prod.fst.{u_2 u_3} B F
       (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
             (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
             (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))))
    (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
       (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                (@prod.fst.{u_2 u_3} B F
                   (@prod.mk.{u_2 u_3} B F (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                      (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
                         (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                            (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v)))
                         (@prod.fst.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))
                         (@prod.snd.{u_2 u_3} B F (@prod.mk.{u_2 u_3} B F x v))))))))
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>344    end }</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>345  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>346  @[simp] lemma mem_local_triv&#x27;_source (i : ι) (p : Z.total_space) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.total_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title=' Total space of a topological bundle created from core. It is equal to `B × F`, but as it is
not marked as reducible, typeclass inference will not infer the wrong topology, and will use the
instance `topological_fiber_bundle_core.to_topological_space` with the right topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>347    p ∈ (Z.local_triv&#x27; i).source ↔ p.1 ∈ Z.base_set i :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 321, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type (max u_2 u_3)} [c : has_mem.{(max u_2 u_3) (max u_2 u_3)} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → set.{(max u_2 u_3)} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' Associate to a trivialization index `i : ι` the corresponding trivialization, i.e., a bijection
between `proj ⁻¹ (base_set i)` and `base_set i × F`. As the fiber above `x` is `F` but read in the
chart with index `index_at x`, the trivialization in the fiber above x is by definition the
coordinate change from i to `index_at x`, so it depends on `x`.
The local trivialization will ultimately be a local homeomorphism. For now, we only introduce the
local equiv version, denoted with a prime. In further developments, avoid this auxiliary version,
and use Z.local_triv instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>348  by refl</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
p : @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z
⊢ iff
    (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_mem.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       p
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (@prod.fst.{u_2 u_3} B F p)
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>349  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
p : @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z
⊢ iff
    (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_mem.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       p
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (@prod.fst.{u_2 u_3} B F p)
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>350  @[simp] lemma mem_local_triv&#x27;_target (i : ι) (p : B × F) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_3 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>351    p ∈ (Z.local_triv&#x27; i).target ↔ p.1 ∈ Z.base_set i :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.target'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 321, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type (max u_2 u_3)} [c : has_mem.{(max u_2 u_3) (max u_2 u_3)} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → set.{(max u_2 u_3)} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' Associate to a trivialization index `i : ι` the corresponding trivialization, i.e., a bijection
between `proj ⁻¹ (base_set i)` and `base_set i × F`. As the fiber above `x` is `F` but read in the
chart with index `index_at x`, the trivialization in the fiber above x is by definition the
coordinate change from i to `index_at x`, so it depends on `x`.
The local trivialization will ultimately be a local homeomorphism. For now, we only introduce the
local equiv version, denoted with a prime. In further developments, avoid this auxiliary version,
and use Z.local_triv instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>352  by { erw [mem_prod], simp }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.mem_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1415, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} {s : set.{u_2} α} {t : set.{u_3} β} {p : prod.{u_2 u_3} α β}, iff (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} α β) (set.{(max u_2 u_3)} (prod.{u_2 u_3} α β)) (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} α β)) p (@set.prod.{u_2 u_3} α β s t)) (and (@has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) (@prod.fst.{u_2 u_3} α β p) s) (@has_mem.mem.{u_3 u_3} β (set.{u_3} β) (@set.has_mem.{u_3} β) (@prod.snd.{u_2 u_3} α β p) t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
p : prod.{u_2 u_3} B F
⊢ iff
    (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       p
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (@prod.fst.{u_2 u_3} B F p)
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
p : prod.{u_2 u_3} B F
⊢ iff
    (and
       (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (@prod.fst.{u_2 u_3} B F p)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
       (@has_mem.mem.{u_3 u_3} F (set.{u_3} F) (@set.has_mem.{u_3} F) (@prod.snd.{u_2 u_3} B F p) (@set.univ.{u_3} F)))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (@prod.fst.{u_2 u_3} B F p)
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>353  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>354  @[simp] lemma local_triv&#x27;_fst (i : ι) (p : Z.total_space) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.total_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title=' Total space of a topological bundle created from core. It is equal to `B × F`, but as it is
not marked as reducible, typeclass inference will not infer the wrong topology, and will use the
instance `topological_fiber_bundle_core.to_topological_space` with the right topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>355    ((Z.local_triv&#x27; i).to_fun p).1 = p.1 := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 321, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_2} {a : α}, @eq.{u_2+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' Associate to a trivialization index `i : ι` the corresponding trivialization, i.e., a bijection
between `proj ⁻¹ (base_set i)` and `base_set i × F`. As the fiber above `x` is `F` but read in the
chart with index `index_at x`, the trivialization in the fiber above x is by definition the
coordinate change from i to `index_at x`, so it depends on `x`.
The local trivialization will ultimately be a local homeomorphism. For now, we only introduce the
local equiv version, denoted with a prime. In further developments, avoid this auxiliary version,
and use Z.local_triv instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>356  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>357  @[simp] lemma local_triv&#x27;_inv_fst (i : ι) (p : B × F) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_3 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>358    ((Z.local_triv&#x27; i).inv_fun p).1 = p.1 := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 321, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_2} {a : α}, @eq.{u_2+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' Associate to a trivialization index `i : ι` the corresponding trivialization, i.e., a bijection
between `proj ⁻¹ (base_set i)` and `base_set i × F`. As the fiber above `x` is `F` but read in the
chart with index `index_at x`, the trivialization in the fiber above x is by definition the
coordinate change from i to `index_at x`, so it depends on `x`.
The local trivialization will ultimately be a local homeomorphism. For now, we only introduce the
local equiv version, denoted with a prime. In further developments, avoid this auxiliary version,
and use Z.local_triv instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>359  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>360  /-- The composition of two local trivializations is the trivialization change Z.triv_change i j. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>361  lemma local_triv&#x27;_trans (i j : ι) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>362    (Z.local_triv&#x27; i).symm.trans (Z.local_triv&#x27; j) ≈ (Z.triv_change i j).to_local_equiv :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_equiv.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.triv_change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_homeomorph.to_local_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 321, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 284, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 321, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 326, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 279, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → local_equiv.{(max u_2 u_3) (max u_2 u_3)} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β γ : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → local_equiv.{(max u_2 u_3) (max u_2 u_3)} β γ → local_equiv.{(max u_2 u_3) (max u_2 u_3)} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u_2 u_3)} [c : has_equiv.{(max u_2 u_3)+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → ι → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)} [_inst_5 : topological_space.{(max u_2 u_3)} α] [_inst_6 : topological_space.{(max u_2 u_3)} β], @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} α β _inst_5 _inst_6 → local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' Associate to a trivialization index `i : ι` the corresponding trivialization, i.e., a bijection
between `proj ⁻¹ (base_set i)` and `base_set i × F`. As the fiber above `x` is `F` but read in the
chart with index `index_at x`, the trivialization in the fiber above x is by definition the
coordinate change from i to `index_at x`, so it depends on `x`.
The local trivialization will ultimately be a local homeomorphism. For now, we only introduce the
local equiv version, denoted with a prime. In further developments, avoid this auxiliary version,
and use Z.local_triv instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The inverse of a local equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Composing two local equivs, by restricting to the maximal domain where their composition
is well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' Associate to a trivialization index `i : ι` the corresponding trivialization, i.e., a bijection
between `proj ⁻¹ (base_set i)` and `base_set i × F`. As the fiber above `x` is `F` but read in the
chart with index `index_at x`, the trivialization in the fiber above x is by definition the
coordinate change from i to `index_at x`, so it depends on `x`.
The local trivialization will ultimately be a local homeomorphism. For now, we only introduce the
local equiv version, denoted with a prime. In further developments, avoid this auxiliary version,
and use Z.local_triv instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Local homeomorphism version of the trivialization change.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>363  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι
⊢ @has_equiv.equiv.{(max u_2 u_3)+1}
    (local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F))
    (@setoid_has_equiv.{(max u_2 u_3)+1}
       (local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F))
       (@local_equiv.eq_on_source_setoid.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)))
    (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
    (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
       (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
       (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>364    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι
⊢ @has_equiv.equiv.{(max u_2 u_3)+1}
    (local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F))
    (@setoid_has_equiv.{(max u_2 u_3)+1}
       (local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F))
       (@local_equiv.eq_on_source_setoid.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)))
    (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
    (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
       (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
       (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι
⊢ @eq.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j)))

ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι
⊢ ∀ (x : prod.{u_2 u_3} B F),
    @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      x
      (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
         (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
            (prod.{u_2 u_3} B F)
            (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
               (prod.{u_2 u_3} B F)
               (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))) →
    @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
      (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
         (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
            (prod.{u_2 u_3} B F)
            (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
               (prod.{u_2 u_3} B F)
               (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
         x)
      (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
            (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j))
         x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>365    { ext x, erw [mem_prod], simp [local_equiv.trans_source] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='set.mem_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='local_equiv.trans_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1415, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 297, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} {s : set.{u_2} α} {t : set.{u_3} β} {p : prod.{u_2 u_3} α β}, iff (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} α β) (set.{(max u_2 u_3)} (prod.{u_2 u_3} α β)) (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} α β)) p (@set.prod.{u_2 u_3} α β s t)) (and (@has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) (@prod.fst.{u_2 u_3} α β p) s) (@has_mem.mem.{u_3 u_3} β (set.{u_3} β) (@set.has_mem.{u_3} β) (@prod.snd.{u_2 u_3} α β p) t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} (e : local_equiv.{?l_1 ?l_2} α β) (e&#x27; : local_equiv.{?l_2 ?l_3} β γ), @eq.{(max (?l_1+1) 1)} (set.{?l_1} α) (@local_equiv.source.{?l_1 ?l_3} α γ (@local_equiv.trans.{?l_1 ?l_2 ?l_3} α β γ e e&#x27;)) (@has_inter.inter.{?l_1} (set.{?l_1} α) (@set.has_inter.{?l_1} α) (@local_equiv.source.{?l_1 ?l_2} α β e) (@set.preimage.{?l_1 ?l_2} α β (@local_equiv.to_fun.{?l_1 ?l_2} α β e) (@local_equiv.source.{?l_2 ?l_3} β γ e&#x27;)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι
⊢ @eq.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j)))

ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι
⊢ ∀ (x : prod.{u_2 u_3} B F),
    @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      x
      (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
         (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
            (prod.{u_2 u_3} B F)
            (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
               (prod.{u_2 u_3} B F)
               (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))) →
    @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
      (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
         (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
            (prod.{u_2 u_3} B F)
            (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
               (prod.{u_2 u_3} B F)
               (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
         x)
      (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
            (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j))
         x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι
⊢ @eq.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : prod.{u_2 u_3} B F
⊢ iff
    (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       x
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))))
    (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       x
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
             (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : prod.{u_2 u_3} B F
⊢ iff
    (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       x
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))))
    (and
       (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (@prod.fst.{u_2 u_3} B F x)
          (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B)
             (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
             (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)))
       (@has_mem.mem.{u_3 u_3} F (set.{u_3} F) (@set.has_mem.{u_3} F) (@prod.snd.{u_2 u_3} B F x) (@set.univ.{u_3} F)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι
⊢ ∀ (x : prod.{u_2 u_3} B F),
    @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      x
      (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
         (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
            (prod.{u_2 u_3} B F)
            (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
               (prod.{u_2 u_3} B F)
               (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))) →
    @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
      (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
         (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
            (prod.{u_2 u_3} B F)
            (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
               (prod.{u_2 u_3} B F)
               (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
         x)
      (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
            (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j))
         x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>366    { rintros ⟨x, v⟩ hx,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι
⊢ ∀ (x : prod.{u_2 u_3} B F),
    @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
      x
      (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
         (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
            (prod.{u_2 u_3} B F)
            (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
               (prod.{u_2 u_3} B F)
               (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))) →
    @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
      (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
         (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
            (prod.{u_2 u_3} B F)
            (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
               (prod.{u_2 u_3} B F)
               (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
         x)
      (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
         (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
            (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
            (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j))
         x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@prod.mk.{u_2 u_3} B F x v)
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@prod.mk.{u_2 u_3} B F x v))
    (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j))
       (@prod.mk.{u_2 u_3} B F x v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>367      simp only [triv_change, local_triv&#x27;, local_equiv.symm, true_and, local_equiv.right_inv,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='topological_fiber_bundle_core.triv_change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_fiber_bundle_core.local_triv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='local_equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='true_and'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='local_equiv.right_inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 279, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 321, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type ?l_1} {B : Type ?l_2} {F : Type ?l_3} [_inst_1 : topological_space.{?l_2} B] [_inst_2 : topological_space.{?l_3} F], @topological_fiber_bundle_core.{?l_1 ?l_2 ?l_3} ι B _inst_1 F _inst_2 → ι → ι → @local_homeomorph.{(max ?l_2 ?l_3) (max ?l_2 ?l_3)} (prod.{?l_2 ?l_3} B F) (prod.{?l_2 ?l_3} B F) (@prod.topological_space.{?l_2 ?l_3} B F _inst_1 _inst_2) (@prod.topological_space.{?l_2 ?l_3} B F _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type ?l_1} {B : Type ?l_2} {F : Type ?l_3} [_inst_1 : topological_space.{?l_2} B] [_inst_2 : topological_space.{?l_3} F] (Z : @topological_fiber_bundle_core.{?l_1 ?l_2 ?l_3} ι B _inst_1 F _inst_2), ι → local_equiv.{(max ?l_2 ?l_3) (max ?l_2 ?l_3)} (@topological_fiber_bundle_core.total_space.{?l_1 ?l_2 ?l_3} ι B F _inst_1 _inst_2 Z) (prod.{?l_2 ?l_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2}, local_equiv.{?l_1 ?l_2} α β → local_equiv.{?l_2 ?l_1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : Prop), iff (and true a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} (c : local_equiv.{?l_1 ?l_2} α β) {x : β}, @has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) x (@local_equiv.target.{?l_1 ?l_2} α β c) → @eq.{?l_2+1} β (@local_equiv.to_fun.{?l_1 ?l_2} α β c (@local_equiv.inv_fun.{?l_1 ?l_2} α β c x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Local homeomorphism version of the trivialization change.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Associate to a trivialization index `i : ι` the corresponding trivialization, i.e., a bijection
between `proj ⁻¹ (base_set i)` and `base_set i × F`. As the fiber above `x` is `F` but read in the
chart with index `index_at x`, the trivialization in the fiber above x is by definition the
coordinate change from i to `index_at x`, so it depends on `x`.
The local trivialization will ultimately be a local homeomorphism. For now, we only introduce the
local equiv version, denoted with a prime. In further developments, avoid this auxiliary version,
and use Z.local_triv instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The inverse of a local equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@prod.mk.{u_2 u_3} B F x v)
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@prod.mk.{u_2 u_3} B F x v))
    (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j))
       (@prod.mk.{u_2 u_3} B F x v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>368                 prod_mk_mem_set_prod_eq, local_equiv.trans_source, mem_inter_eq, and_true,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set.prod_mk_mem_set_prod_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='local_equiv.trans_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_inter_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and_true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1496, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 297, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 347, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 401, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {a : α} {b : β} {s : set.{?l_1} α} {t : set.{?l_2} β}, @eq.{1} Prop (@has_mem.mem.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (set.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)) (@set.has_mem.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)) (@prod.mk.{?l_1 ?l_2} α β a b) (@set.prod.{?l_1 ?l_2} α β s t)) (and (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a s) (@has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) b t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} (e : local_equiv.{?l_1 ?l_2} α β) (e&#x27; : local_equiv.{?l_2 ?l_3} β γ), @eq.{(max (?l_1+1) 1)} (set.{?l_1} α) (@local_equiv.source.{?l_1 ?l_3} α γ (@local_equiv.trans.{?l_1 ?l_2 ?l_3} α β γ e e&#x27;)) (@has_inter.inter.{?l_1} (set.{?l_1} α) (@set.has_inter.{?l_1} α) (@local_equiv.source.{?l_1 ?l_2} α β e) (@set.preimage.{?l_1 ?l_2} α β (@local_equiv.to_fun.{?l_1 ?l_2} α β e) (@local_equiv.source.{?l_2 ?l_3} β γ e&#x27;)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (x : α) (a b : set.{?l_1} α), @eq.{1} Prop (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x (@has_inter.inter.{?l_1} (set.{?l_1} α) (@set.has_inter.{?l_1} α) a b)) (and (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x a) (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : Prop), iff (and a true) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@prod.mk.{u_2 u_3} B F x v)
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@prod.mk.{u_2 u_3} B F x v))
    (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j))
       (@prod.mk.{u_2 u_3} B F x v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>369                 mem_univ, prod.mk.inj_iff, local_equiv.trans_apply, mem_preimage, proj,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk.inj_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='local_equiv.trans_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_fiber_bundle_core.proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 235, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/prod.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 288, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 838, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (x : α), @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x (@set.univ.{?l_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {a₁ a₂ : α} {b₁ b₂ : β}, iff (@eq.{(max (?l_1+1) (?l_2+1))} (prod.{?l_1 ?l_2} α β) (@prod.mk.{?l_1 ?l_2} α β a₁ b₁) (@prod.mk.{?l_1 ?l_2} α β a₂ b₂)) (and (@eq.{?l_1+1} α a₁ a₂) (@eq.{?l_2+1} β b₁ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} (e : local_equiv.{?l_1 ?l_2} α β) (e&#x27; : local_equiv.{?l_2 ?l_3} β γ) (x : α), @eq.{?l_3+1} γ (@local_equiv.to_fun.{?l_1 ?l_3} α γ (@local_equiv.trans.{?l_1 ?l_2 ?l_3} α β γ e e&#x27;) x) (@local_equiv.to_fun.{?l_2 ?l_3} β γ e&#x27; (@local_equiv.to_fun.{?l_1 ?l_2} α β e x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {f : α → β} {s : set.{?l_2} β} {a : α}, iff (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@set.preimage.{?l_1 ?l_2} α β f s)) (@has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) (f a) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type ?l_1} {B : Type ?l_2} {F : Type ?l_3} [_inst_1 : topological_space.{?l_2} B] [_inst_2 : topological_space.{?l_3} F] (Z : @topological_fiber_bundle_core.{?l_1 ?l_2 ?l_3} ι B _inst_1 F _inst_2), @topological_fiber_bundle_core.total_space.{?l_1 ?l_2 ?l_3} ι B F _inst_1 _inst_2 Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The projection from the total space of a topological fiber bundle core, on its base.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@prod.mk.{u_2 u_3} B F x v)
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@prod.mk.{u_2 u_3} B F x v))
    (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j))
       (@prod.mk.{u_2 u_3} B F x v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>370                 local_equiv.left_inv] at hx ⊢,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='local_equiv.left_inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} (c : local_equiv.{?l_1 ?l_2} α β) {x : α}, @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x (@local_equiv.source.{?l_1 ?l_2} α β c) → @eq.{?l_1+1} α (@local_equiv.inv_fun.{?l_1 ?l_2} α β c (@local_equiv.to_fun.{?l_1 ?l_2} α β c x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@prod.mk.{u_2 u_3} B F x v)
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
⊢ @eq.{(max u_2 u_3)+1} (prod.{u_2 u_3} B F)
    (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@prod.mk.{u_2 u_3} B F x v))
    (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j))
       (@prod.mk.{u_2 u_3} B F x v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ and (@eq.{u_2+1} B x x)
    (@eq.{u_3+1} F
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x)
          j
          x
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x)
             x
             v))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j x v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>371      simp [Z.coord_change_comp, hx] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i j k : ι) (x : B), @has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B) (@has_inter.inter.{u_2} (set.{u_2} B) (@set.has_inter.{u_2} B) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j)) (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z k)) → ∀ (v : F), @eq.{u_3+1} F (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j k x (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j x v)) (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i k x v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)) (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i j : ι,
x : B,
v : F,
hx :
  and
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) x
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z j))
⊢ and (@eq.{u_2+1} B x x)
    (@eq.{u_3+1} F
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
          (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x)
          j
          x
          (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i
             (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z x)
             x
             v))
       (@topological_fiber_bundle_core.coord_change.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i j x v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>372  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>373  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>374  /-- Topological structure on the total space of a topological bundle created from core, designed so</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>375  that all the local trivialization are continuous. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>376  instance to_topological_space : topological_space Z.total_space :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.total_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Total space of a topological bundle created from core. It is equal to `B × F`, but as it is
not marked as reducible, typeclass inference will not infer the wrong topology, and will use the
instance `topological_fiber_bundle_core.to_topological_space` with the right topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>377  topological_space.generate_from $ ⋃ (i : ι) (s : set (B × F)) (s_open : is_open s),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_space.generate_from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, set.{u} (set.{u} α) → topological_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {β : Type (max u_2 u_3)} {ι : Type u_1}, (ι → set.{(max u_2 u_3)} β) → set.{(max u_2 u_3)} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_3 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {α : Type (max u_2 u_3)} [t : topological_space.{(max u_2 u_3)} α], set.{(max u_2 u_3)} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {β : Type (max u_2 u_3)} {ι : Type u_1}, (ι → set.{(max u_2 u_3)} β) → set.{(max u_2 u_3)} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The smallest topological space containing the collection `g` of basic sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>378    {(Z.local_triv&#x27; i).source ∩ (Z.local_triv&#x27; i).to_fun ⁻¹&#x27; s }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 321, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 321, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type (max u_2 u_3)} [_inst_1 : has_emptyc.{(max u_2 u_3)} γ] [_inst_2 : has_insert.{(max u_2 u_3) (max u_2 u_3)} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → set.{(max u_2 u_3)} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u_2 u_3)} [c : has_inter.{(max u_2 u_3)} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, (α → β) → set.{(max u_2 u_3)} β → set.{(max u_2 u_3)} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' Associate to a trivialization index `i : ι` the corresponding trivialization, i.e., a bijection
between `proj ⁻¹ (base_set i)` and `base_set i × F`. As the fiber above `x` is `F` but read in the
chart with index `index_at x`, the trivialization in the fiber above x is by definition the
coordinate change from i to `index_at x`, so it depends on `x`.
The local trivialization will ultimately be a local homeomorphism. For now, we only introduce the
local equiv version, denoted with a prime. In further developments, avoid this auxiliary version,
and use Z.local_triv instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title=' Associate to a trivialization index `i : ι` the corresponding trivialization, i.e., a bijection
between `proj ⁻¹ (base_set i)` and `base_set i × F`. As the fiber above `x` is `F` but read in the
chart with index `index_at x`, the trivialization in the fiber above x is by definition the
coordinate change from i to `index_at x`, so it depends on `x`.
The local trivialization will ultimately be a local homeomorphism. For now, we only introduce the
local equiv version, denoted with a prime. In further developments, avoid this auxiliary version,
and use Z.local_triv instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>379  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>380  lemma open_source&#x27; (i : ι) : is_open (Z.local_triv&#x27; i).source :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 321, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type (max u_2 u_3)} [t : topological_space.{(max u_2 u_3)} α], set.{(max u_2 u_3)} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → set.{(max u_2 u_3)} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' Associate to a trivialization index `i : ι` the corresponding trivialization, i.e., a bijection
between `proj ⁻¹ (base_set i)` and `base_set i × F`. As the fiber above `x` is `F` but read in the
chart with index `index_at x`, the trivialization in the fiber above x is by definition the
coordinate change from i to `index_at x`, so it depends on `x`.
The local trivialization will ultimately be a local homeomorphism. For now, we only introduce the
local equiv version, denoted with a prime. In further developments, avoid this auxiliary version,
and use Z.local_triv instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>381  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ @is_open.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>382    apply topological_space.generate_open.basic,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='topological_space.generate_open.basic'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_2 u_3)} {g : set.{(max u_2 u_3)} (set.{(max u_2 u_3)} α)} (s : set.{(max u_2 u_3)} α), @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (set.{(max u_2 u_3)} α) (set.{(max u_2 u_3)} (set.{(max u_2 u_3)} α)) (@set.has_mem.{(max u_2 u_3)} (set.{(max u_2 u_3)} α)) s g → @topological_space.generate_open.{(max u_2 u_3)} α g s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ @is_open.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (set.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
    (@set.has_mem.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
    (@set.Union.{(max u_2 u_3) u_1+1}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       ι
       (λ (i : ι),
          @set.Union.{(max u_2 u_3) (max ((max u_2 u_3)+1) 1)}
            (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
            (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
            (λ (s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
               @set.Union.{(max u_2 u_3) 0}
                 (set.{(max u_2 u_3)}
                    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                 (@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                    s)
                 (λ
                  (s_open :
                    @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                      s),
                    @singleton.{(max u_2 u_3) (max u_2 u_3)}
                      (set.{(max u_2 u_3)}
                         (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                      (set.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@set.has_emptyc.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@set.has_insert.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@has_inter.inter.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                         (@set.has_inter.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                         (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                            (prod.{u_2 u_3} B F)
                            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                         (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                            (prod.{u_2 u_3} B F)
                            (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                               (prod.{u_2 u_3} B F)
                               (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                            s))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>383    simp only [exists_prop, mem_Union, mem_singleton_iff],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='exists_prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_singleton_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 544, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 509, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p q : Prop}, iff (@Exists.{0} p (λ (h : p), q)) (and p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type ?l_1} {ι : Sort ?l_2} {x : β} {s : ι → set.{?l_1} β}, iff (@has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x (@set.Union.{?l_1 ?l_2} β ι s)) (@Exists.{?l_2} ι (λ (i : ι), @has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x (s i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {a b : α}, iff (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@singleton.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_emptyc.{?l_1} α) (@set.has_insert.{?l_1} α) b)) (@eq.{?l_1+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (set.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
    (@set.has_mem.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
    (@set.Union.{(max u_2 u_3) u_1+1}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       ι
       (λ (i : ι),
          @set.Union.{(max u_2 u_3) (max ((max u_2 u_3)+1) 1)}
            (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
            (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
            (λ (s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
               @set.Union.{(max u_2 u_3) 0}
                 (set.{(max u_2 u_3)}
                    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                 (@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                    s)
                 (λ
                  (s_open :
                    @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                      s),
                    @singleton.{(max u_2 u_3) (max u_2 u_3)}
                      (set.{(max u_2 u_3)}
                         (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                      (set.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@set.has_emptyc.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@set.has_insert.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@has_inter.inter.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                         (@set.has_inter.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                         (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                            (prod.{u_2 u_3} B F)
                            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                         (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                            (prod.{u_2 u_3} B F)
                            (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                               (prod.{u_2 u_3} B F)
                               (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                            s))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ @Exists.{u_1+1} ι
    (λ (i_1 : ι),
       @Exists.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
         (λ (i_2 : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
            and
              (@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                 i_2)
              (@eq.{(max u_2 u_3)+1}
                 (set.{(max u_2 u_3)}
                    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                 (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                    (prod.{u_2 u_3} B F)
                    (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                 (@has_inter.inter.{(max u_2 u_3)}
                    (set.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@set.has_inter.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i_1))
                    (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                          (prod.{u_2 u_3} B F)
                          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i_1))
                       i_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>384    refine ⟨i, set.prod (Z.base_set i) univ, is_open_prod (Z.is_open_base_set i) (is_open_univ), _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_fiber_bundle_core.base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_open_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 128, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, set.{u_2} α → set.{u_3} β → set.{(max u_2 u_3)} (prod.{u_2 u_3} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3}, set.{u_3} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_3} β] {s : set.{u_2} α} {t : set.{u_3} β}, @is_open.{u_2} α _inst_1 s → @is_open.{u_3} β _inst_2 t → @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} α β) (@prod.topological_space.{u_2 u_3} α β _inst_1 _inst_2) (@set.prod.{u_2 u_3} α β s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_3} [t : topological_space.{u_3} α], @is_open.{u_3} α t (@set.univ.{u_3} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ @Exists.{u_1+1} ι
    (λ (i_1 : ι),
       @Exists.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
         (λ (i_2 : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
            and
              (@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                 i_2)
              (@eq.{(max u_2 u_3)+1}
                 (set.{(max u_2 u_3)}
                    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                 (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                    (prod.{u_2 u_3} B F)
                    (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                 (@has_inter.inter.{(max u_2 u_3)}
                    (set.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@set.has_inter.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i_1))
                    (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                          (prod.{u_2 u_3} B F)
                          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i_1))
                       i_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@set.prod.{u_2 u_3} B F (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
             (@set.univ.{u_3} F))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>385    ext p,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@set.prod.{u_2 u_3} B F (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
             (@set.univ.{u_3} F))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
p : @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z
⊢ iff
    (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_mem.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       p
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)))
    (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_mem.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       p
       (@has_inter.inter.{(max u_2 u_3)}
          (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
          (@set.has_inter.{(max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
          (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.prod.{u_2 u_3} B F (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
                (@set.univ.{u_3} F)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>386    simp [topological_fiber_bundle_core.local_triv&#x27;_fst,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='topological_fiber_bundle_core.local_triv&#x27;_fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 354, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type ?l_1} {B : Type ?l_2} {F : Type ?l_3} [_inst_1 : topological_space.{?l_2} B] [_inst_2 : topological_space.{?l_3} F] (Z : @topological_fiber_bundle_core.{?l_1 ?l_2 ?l_3} ι B _inst_1 F _inst_2) (i : ι) (p : @topological_fiber_bundle_core.total_space.{?l_1 ?l_2 ?l_3} ι B F _inst_1 _inst_2 Z), @eq.{?l_2+1} B (@prod.fst.{?l_2 ?l_3} B F (@local_equiv.to_fun.{(max ?l_2 ?l_3) (max ?l_2 ?l_3)} (@topological_fiber_bundle_core.total_space.{?l_1 ?l_2 ?l_3} ι B F _inst_1 _inst_2 Z) (prod.{?l_2 ?l_3} B F) (@topological_fiber_bundle_core.local_triv&#x27;.{?l_1 ?l_2 ?l_3} ι B F _inst_1 _inst_2 Z i) p)) (@prod.fst.{?l_2 ?l_3} B F p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
p : @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z
⊢ iff
    (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_mem.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       p
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)))
    (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_mem.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       p
       (@has_inter.inter.{(max u_2 u_3)}
          (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
          (@set.has_inter.{(max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
          (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.prod.{u_2 u_3} B F (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
                (@set.univ.{u_3} F)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>387          topological_fiber_bundle_core.mem_local_triv&#x27;_source]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='topological_fiber_bundle_core.mem_local_triv&#x27;_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 346, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type ?l_1} {B : Type ?l_2} {F : Type ?l_3} [_inst_1 : topological_space.{?l_2} B] [_inst_2 : topological_space.{?l_3} F] (Z : @topological_fiber_bundle_core.{?l_1 ?l_2 ?l_3} ι B _inst_1 F _inst_2) (i : ι) (p : @topological_fiber_bundle_core.total_space.{?l_1 ?l_2 ?l_3} ι B F _inst_1 _inst_2 Z), iff (@has_mem.mem.{(max ?l_2 ?l_3) (max ?l_2 ?l_3)} (@topological_fiber_bundle_core.total_space.{?l_1 ?l_2 ?l_3} ι B F _inst_1 _inst_2 Z) (set.{(max ?l_2 ?l_3)} (@topological_fiber_bundle_core.total_space.{?l_1 ?l_2 ?l_3} ι B F _inst_1 _inst_2 Z)) (@set.has_mem.{(max ?l_2 ?l_3)} (@topological_fiber_bundle_core.total_space.{?l_1 ?l_2 ?l_3} ι B F _inst_1 _inst_2 Z)) p (@local_equiv.source.{(max ?l_2 ?l_3) (max ?l_2 ?l_3)} (@topological_fiber_bundle_core.total_space.{?l_1 ?l_2 ?l_3} ι B F _inst_1 _inst_2 Z) (prod.{?l_2 ?l_3} B F) (@topological_fiber_bundle_core.local_triv&#x27;.{?l_1 ?l_2 ?l_3} ι B F _inst_1 _inst_2 Z i))) (@has_mem.mem.{?l_2 ?l_2} B (set.{?l_2} B) (@set.has_mem.{?l_2} B) (@prod.fst.{?l_2 ?l_3} B F p) (@topological_fiber_bundle_core.base_set.{?l_1 ?l_2 ?l_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
p : @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z
⊢ iff
    (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_mem.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       p
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)))
    (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_mem.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       p
       (@has_inter.inter.{(max u_2 u_3)}
          (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
          (@set.has_inter.{(max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
          (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.prod.{u_2 u_3} B F (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i)
                (@set.univ.{u_3} F)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>388  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>389  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>390  lemma open_target&#x27; (i : ι) : is_open (Z.local_triv&#x27; i).target :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.target'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 321, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type (max u_2 u_3)} [t : topological_space.{(max u_2 u_3)} α], set.{(max u_2 u_3)} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → set.{(max u_2 u_3)} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' Associate to a trivialization index `i : ι` the corresponding trivialization, i.e., a bijection
between `proj ⁻¹ (base_set i)` and `base_set i × F`. As the fiber above `x` is `F` but read in the
chart with index `index_at x`, the trivialization in the fiber above x is by definition the
coordinate change from i to `index_at x`, so it depends on `x`.
The local trivialization will ultimately be a local homeomorphism. For now, we only introduce the
local equiv version, denoted with a prime. In further developments, avoid this auxiliary version,
and use Z.local_triv instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>391  is_open_prod (Z.is_open_base_set i) (is_open_univ)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_open_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.is_open_base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_open_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 128, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_3} β] {s : set.{u_2} α} {t : set.{u_3} β}, @is_open.{u_2} α _inst_1 s → @is_open.{u_3} β _inst_2 t → @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} α β) (@prod.topological_space.{u_2 u_3} α β _inst_1 _inst_2) (@set.prod.{u_2 u_3} α β s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F] (c : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2) (i : ι), @is_open.{u_2} B _inst_1 (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 c i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_3} [t : topological_space.{u_3} α], @is_open.{u_3} α t (@set.univ.{u_3} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>392  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>393  /-- Local trivialization of a topological bundle created from core, as a local homeomorphism. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>394  def local_triv (i : ι) : local_homeomorph Z.total_space (B × F) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='local_homeomorph'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.total_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u_5) (β : Type u_6) [_inst_5 : topological_space.{u_5} α] [_inst_6 : topological_space.{u_6} β], Type (max u_5 u_6)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_3 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='local homeomorphisms, defined on open subsets of the space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Total space of a topological bundle created from core. It is equal to `B × F`, but as it is
not marked as reducible, typeclass inference will not infer the wrong topology, and will use the
instance `topological_fiber_bundle_core.to_topological_space` with the right topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>395  { open_source := Z.open_source&#x27; i,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.open_source&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 380, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2) (i : ι), @is_open.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>396    open_target := Z.open_target&#x27; i,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.open_target&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 390, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2) (i : ι), @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>397    continuous_to_fun := begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ @continuous_on.{(max u_2 u_3) (max u_2 u_3)}
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>398      rw continuous_on_open_iff (Z.open_source&#x27; i),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='continuous_on_open_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 475, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 380, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type (max u_2 u_3)} [_inst_1 : topological_space.{(max u_2 u_3)} α] [_inst_2 : topological_space.{(max u_2 u_3)} β] {f : α → β} {s : set.{(max u_2 u_3)} α}, @is_open.{(max u_2 u_3)} α _inst_1 s → iff (@continuous_on.{(max u_2 u_3) (max u_2 u_3)} α β _inst_1 _inst_2 f s) (∀ (t : set.{(max u_2 u_3)} β), @is_open.{(max u_2 u_3)} β _inst_2 t → @is_open.{(max u_2 u_3)} α _inst_1 (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} α) (@set.has_inter.{(max u_2 u_3)} α) s (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} α β f t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ @continuous_on.{(max u_2 u_3) (max u_2 u_3)}
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ ∀ (t : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
    @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) t →
    @is_open.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
      (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
      (@has_inter.inter.{(max u_2 u_3)}
         (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
         (@set.has_inter.{(max u_2 u_3)}
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
         (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
            (prod.{u_2 u_3} B F)
            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
         (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
            (prod.{u_2 u_3} B F)
            (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
               (prod.{u_2 u_3} B F)
               (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
                  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                  (prod.{u_2 u_3} B F)
                  (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
            t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>399      assume s s_open,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ ∀ (t : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
    @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) t →
    @is_open.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
      (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
      (@has_inter.inter.{(max u_2 u_3)}
         (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
         (@set.has_inter.{(max u_2 u_3)}
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
         (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
            (prod.{u_2 u_3} B F)
            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
         (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
            (prod.{u_2 u_3} B F)
            (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
               (prod.{u_2 u_3} B F)
               (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
                  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                  (prod.{u_2 u_3} B F)
                  (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
            t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s
⊢ @is_open.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>400      apply topological_space.generate_open.basic,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='topological_space.generate_open.basic'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_2 u_3)} {g : set.{(max u_2 u_3)} (set.{(max u_2 u_3)} α)} (s : set.{(max u_2 u_3)} α), @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (set.{(max u_2 u_3)} α) (set.{(max u_2 u_3)} (set.{(max u_2 u_3)} α)) (@set.has_mem.{(max u_2 u_3)} (set.{(max u_2 u_3)} α)) s g → @topological_space.generate_open.{(max u_2 u_3)} α g s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s
⊢ @is_open.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s
⊢ @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (set.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
    (@set.has_mem.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
          s))
    (@set.Union.{(max u_2 u_3) u_1+1}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       ι
       (λ (i : ι),
          @set.Union.{(max u_2 u_3) (max ((max u_2 u_3)+1) 1)}
            (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
            (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
            (λ (s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
               @set.Union.{(max u_2 u_3) 0}
                 (set.{(max u_2 u_3)}
                    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                 (@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                    s)
                 (λ
                  (s_open :
                    @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                      s),
                    @singleton.{(max u_2 u_3) (max u_2 u_3)}
                      (set.{(max u_2 u_3)}
                         (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                      (set.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@set.has_emptyc.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@set.has_insert.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@has_inter.inter.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                         (@set.has_inter.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                         (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                            (prod.{u_2 u_3} B F)
                            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                         (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                            (prod.{u_2 u_3} B F)
                            (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                               (prod.{u_2 u_3} B F)
                               (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                            s))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>401      simp only [exists_prop, mem_Union, mem_singleton_iff],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='exists_prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_singleton_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 544, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 509, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p q : Prop}, iff (@Exists.{0} p (λ (h : p), q)) (and p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type ?l_1} {ι : Sort ?l_2} {x : β} {s : ι → set.{?l_1} β}, iff (@has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x (@set.Union.{?l_1 ?l_2} β ι s)) (@Exists.{?l_2} ι (λ (i : ι), @has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x (s i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {a b : α}, iff (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@singleton.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_emptyc.{?l_1} α) (@set.has_insert.{?l_1} α) b)) (@eq.{?l_1+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s
⊢ @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (set.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
    (@set.has_mem.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
          s))
    (@set.Union.{(max u_2 u_3) u_1+1}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       ι
       (λ (i : ι),
          @set.Union.{(max u_2 u_3) (max ((max u_2 u_3)+1) 1)}
            (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
            (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
            (λ (s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
               @set.Union.{(max u_2 u_3) 0}
                 (set.{(max u_2 u_3)}
                    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                 (@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                    s)
                 (λ
                  (s_open :
                    @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                      s),
                    @singleton.{(max u_2 u_3) (max u_2 u_3)}
                      (set.{(max u_2 u_3)}
                         (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                      (set.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@set.has_emptyc.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@set.has_insert.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@has_inter.inter.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                         (@set.has_inter.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                         (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                            (prod.{u_2 u_3} B F)
                            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                         (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                            (prod.{u_2 u_3} B F)
                            (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                               (prod.{u_2 u_3} B F)
                               (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                            s))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s
⊢ @Exists.{u_1+1} ι
    (λ (i_1 : ι),
       @Exists.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
         (λ (i_2 : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
            and
              (@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                 i_2)
              (@eq.{(max u_2 u_3)+1}
                 (set.{(max u_2 u_3)}
                    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                 (@has_inter.inter.{(max u_2 u_3)}
                    (set.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@set.has_inter.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                    (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                          (prod.{u_2 u_3} B F)
                          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                       s))
                 (@has_inter.inter.{(max u_2 u_3)}
                    (set.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@set.has_inter.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i_1))
                    (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                          (prod.{u_2 u_3} B F)
                          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i_1))
                       i_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>402      exact ⟨i, s, s_open, rfl⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_2 u_3)} {a : α}, @eq.{(max u_2 u_3)+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s
⊢ @Exists.{u_1+1} ι
    (λ (i_1 : ι),
       @Exists.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
         (λ (i_2 : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
            and
              (@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                 i_2)
              (@eq.{(max u_2 u_3)+1}
                 (set.{(max u_2 u_3)}
                    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                 (@has_inter.inter.{(max u_2 u_3)}
                    (set.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@set.has_inter.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                    (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                          (prod.{u_2 u_3} B F)
                          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                       s))
                 (@has_inter.inter.{(max u_2 u_3)}
                    (set.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@set.has_inter.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i_1))
                    (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                          (prod.{u_2 u_3} B F)
                          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i_1))
                       i_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>403    end,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s
⊢ @Exists.{u_1+1} ι
    (λ (i_1 : ι),
       @Exists.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
         (λ (i_2 : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
            and
              (@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                 i_2)
              (@eq.{(max u_2 u_3)+1}
                 (set.{(max u_2 u_3)}
                    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                 (@has_inter.inter.{(max u_2 u_3)}
                    (set.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@set.has_inter.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                    (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                          (prod.{u_2 u_3} B F)
                          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                       s))
                 (@has_inter.inter.{(max u_2 u_3)}
                    (set.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@set.has_inter.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i_1))
                    (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                          (prod.{u_2 u_3} B F)
                          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i_1))
                       i_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>404    continuous_inv_fun := begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ @continuous_on.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
    (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>405      apply continuous_on_open_of_generate_from (Z.open_target&#x27; i),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='continuous_on_open_of_generate_from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 520, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 390, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_2 u_3)} [_inst_1 : topological_space.{(max u_2 u_3)} α] {β : Type (max u_2 u_3)} {s : set.{(max u_2 u_3)} α} {T : set.{(max u_2 u_3)} (set.{(max u_2 u_3)} β)} {f : α → β}, @is_open.{(max u_2 u_3)} α _inst_1 s → (∀ (t : set.{(max u_2 u_3)} β), @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (set.{(max u_2 u_3)} β) (set.{(max u_2 u_3)} (set.{(max u_2 u_3)} β)) (@set.has_mem.{(max u_2 u_3)} (set.{(max u_2 u_3)} β)) t T → @is_open.{(max u_2 u_3)} α _inst_1 (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} α) (@set.has_inter.{(max u_2 u_3)} α) s (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} α β f t))) → @continuous_on.{(max u_2 u_3) (max u_2 u_3)} α β _inst_1 (@topological_space.generate_from.{(max u_2 u_3)} β T) f s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ @continuous_on.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
    (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
          (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ ∀ (t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)),
    @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
      (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
      (set.{(max u_2 u_3)}
         (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
      (@set.has_mem.{(max u_2 u_3)}
         (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
      t
      (@set.Union.{(max u_2 u_3) u_1+1}
         (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
         ι
         (λ (i : ι),
            @set.Union.{(max u_2 u_3) (max ((max u_2 u_3)+1) 1)}
              (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
              (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
              (λ (s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
                 @set.Union.{(max u_2 u_3) 0}
                   (set.{(max u_2 u_3)}
                      (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                   (@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                      s)
                   (λ
                    (s_open :
                      @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                        (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                        s),
                      @singleton.{(max u_2 u_3) (max u_2 u_3)}
                        (set.{(max u_2 u_3)}
                           (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                        (set.{(max u_2 u_3)}
                           (set.{(max u_2 u_3)}
                              (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                        (@set.has_emptyc.{(max u_2 u_3)}
                           (set.{(max u_2 u_3)}
                              (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                        (@set.has_insert.{(max u_2 u_3)}
                           (set.{(max u_2 u_3)}
                              (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                        (@has_inter.inter.{(max u_2 u_3)}
                           (set.{(max u_2 u_3)}
                              (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                           (@set.has_inter.{(max u_2 u_3)}
                              (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                           (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                              (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                              (prod.{u_2 u_3} B F)
                              (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                           (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                              (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                              (prod.{u_2 u_3} B F)
                              (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                                 (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                                 (prod.{u_2 u_3} B F)
                                 (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                              s)))))) →
    @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
      (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
         (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
         (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
            (prod.{u_2 u_3} B F)
            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
         (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
            (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
               (prod.{u_2 u_3} B F)
               (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
                  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                  (prod.{u_2 u_3} B F)
                  (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
            t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>406      assume t ht,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι
⊢ ∀ (t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)),
    @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
      (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
      (set.{(max u_2 u_3)}
         (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
      (@set.has_mem.{(max u_2 u_3)}
         (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
      t
      (@set.Union.{(max u_2 u_3) u_1+1}
         (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
         ι
         (λ (i : ι),
            @set.Union.{(max u_2 u_3) (max ((max u_2 u_3)+1) 1)}
              (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
              (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
              (λ (s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
                 @set.Union.{(max u_2 u_3) 0}
                   (set.{(max u_2 u_3)}
                      (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                   (@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                      s)
                   (λ
                    (s_open :
                      @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                        (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                        s),
                      @singleton.{(max u_2 u_3) (max u_2 u_3)}
                        (set.{(max u_2 u_3)}
                           (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                        (set.{(max u_2 u_3)}
                           (set.{(max u_2 u_3)}
                              (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                        (@set.has_emptyc.{(max u_2 u_3)}
                           (set.{(max u_2 u_3)}
                              (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                        (@set.has_insert.{(max u_2 u_3)}
                           (set.{(max u_2 u_3)}
                              (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                        (@has_inter.inter.{(max u_2 u_3)}
                           (set.{(max u_2 u_3)}
                              (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                           (@set.has_inter.{(max u_2 u_3)}
                              (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                           (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                              (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                              (prod.{u_2 u_3} B F)
                              (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                           (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                              (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                              (prod.{u_2 u_3} B F)
                              (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                                 (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                                 (prod.{u_2 u_3} B F)
                                 (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                              s)))))) →
    @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
      (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
         (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
         (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
            (prod.{u_2 u_3} B F)
            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
         (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
            (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
               (prod.{u_2 u_3} B F)
               (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
                  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                  (prod.{u_2 u_3} B F)
                  (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                  (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
                     (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                     (prod.{u_2 u_3} B F)
                     (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
            t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
ht :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (set.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
    (@set.has_mem.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
    t
    (@set.Union.{(max u_2 u_3) u_1+1}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       ι
       (λ (i : ι),
          @set.Union.{(max u_2 u_3) (max ((max u_2 u_3)+1) 1)}
            (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
            (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
            (λ (s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
               @set.Union.{(max u_2 u_3) 0}
                 (set.{(max u_2 u_3)}
                    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                 (@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                    s)
                 (λ
                  (s_open :
                    @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                      s),
                    @singleton.{(max u_2 u_3) (max u_2 u_3)}
                      (set.{(max u_2 u_3)}
                         (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                      (set.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@set.has_emptyc.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@set.has_insert.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@has_inter.inter.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                         (@set.has_inter.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                         (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                            (prod.{u_2 u_3} B F)
                            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                         (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                            (prod.{u_2 u_3} B F)
                            (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                               (prod.{u_2 u_3} B F)
                               (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                            s))))))
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
          t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>407      simp only [exists_prop, mem_Union, mem_singleton_iff] at ht,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='exists_prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_singleton_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 544, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 509, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p q : Prop}, iff (@Exists.{0} p (λ (h : p), q)) (and p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type ?l_1} {ι : Sort ?l_2} {x : β} {s : ι → set.{?l_1} β}, iff (@has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x (@set.Union.{?l_1 ?l_2} β ι s)) (@Exists.{?l_2} ι (λ (i : ι), @has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x (s i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {a b : α}, iff (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@singleton.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_emptyc.{?l_1} α) (@set.has_insert.{?l_1} α) b)) (@eq.{?l_1+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
ht :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (set.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
    (@set.has_mem.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
    t
    (@set.Union.{(max u_2 u_3) u_1+1}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       ι
       (λ (i : ι),
          @set.Union.{(max u_2 u_3) (max ((max u_2 u_3)+1) 1)}
            (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
            (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
            (λ (s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
               @set.Union.{(max u_2 u_3) 0}
                 (set.{(max u_2 u_3)}
                    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                 (@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                    s)
                 (λ
                  (s_open :
                    @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F)
                      (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                      s),
                    @singleton.{(max u_2 u_3) (max u_2 u_3)}
                      (set.{(max u_2 u_3)}
                         (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                      (set.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@set.has_emptyc.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@set.has_insert.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)))
                      (@has_inter.inter.{(max u_2 u_3)}
                         (set.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                         (@set.has_inter.{(max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                         (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                            (prod.{u_2 u_3} B F)
                            (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                         (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                            (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                            (prod.{u_2 u_3} B F)
                            (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                               (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                               (prod.{u_2 u_3} B F)
                               (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                            s))))))
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
          t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
ht :
  @Exists.{u_1+1} ι
    (λ (i : ι),
       @Exists.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
         (λ (i_1 : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
            and
              (@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                 i_1)
              (@eq.{(max u_2 u_3)+1}
                 (set.{(max u_2 u_3)}
                    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                 t
                 (@has_inter.inter.{(max u_2 u_3)}
                    (set.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@set.has_inter.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                    (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                          (prod.{u_2 u_3} B F)
                          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                       i_1)))))
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
          t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>408      obtain ⟨j, s, s_open, ts⟩ : ∃ j s,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
ht :
  @Exists.{u_1+1} ι
    (λ (i : ι),
       @Exists.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
         (λ (i_1 : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
            and
              (@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                 i_1)
              (@eq.{(max u_2 u_3)+1}
                 (set.{(max u_2 u_3)}
                    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                 t
                 (@has_inter.inter.{(max u_2 u_3)}
                    (set.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@set.has_inter.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                    (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                          (prod.{u_2 u_3} B F)
                          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                       i_1)))))
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
          t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>409        is_open s ∧ t = (local_triv&#x27; Z j).source ∩ (local_triv&#x27; Z j).to_fun ⁻¹&#x27; s := ht,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_fiber_bundle_core.local_triv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 321, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u_2 u_3)} [t : topological_space.{(max u_2 u_3)} α], set.{(max u_2 u_3)} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u_2 u_3)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u_2 u_3)} [c : has_inter.{(max u_2 u_3)} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, (α → β) → set.{(max u_2 u_3)} β → set.{(max u_2 u_3)} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u_1+1} ι (λ (i : ι), @Exists.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)) (λ (i_1 : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)), and (@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) i_1) (@eq.{(max u_2 u_3)+1} (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)) t (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)) (@set.has_inter.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)) (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)) (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)) i_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Associate to a trivialization index `i : ι` the corresponding trivialization, i.e., a bijection
between `proj ⁻¹ (base_set i)` and `base_set i × F`. As the fiber above `x` is `F` but read in the
chart with index `index_at x`, the trivialization in the fiber above x is by definition the
coordinate change from i to `index_at x`, so it depends on `x`.
The local trivialization will ultimately be a local homeomorphism. For now, we only introduce the
local equiv version, denoted with a prime. In further developments, avoid this auxiliary version,
and use Z.local_triv instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
ht :
  @Exists.{u_1+1} ι
    (λ (i : ι),
       @Exists.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
         (λ (i_1 : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)),
            and
              (@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                 i_1)
              (@eq.{(max u_2 u_3)+1}
                 (set.{(max u_2 u_3)}
                    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                 t
                 (@has_inter.inter.{(max u_2 u_3)}
                    (set.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@set.has_inter.{(max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
                    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                    (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                       (prod.{u_2 u_3} B F)
                       (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                          (prod.{u_2 u_3} B F)
                          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                       i_1)))))
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
          t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s))
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
          t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>410      rw ts,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max u_2 u_3)+1} (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)) t (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)) (@set.has_inter.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)) (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)) (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s))
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
          t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s))
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
          (@has_inter.inter.{(max u_2 u_3)}
             (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
             (@set.has_inter.{(max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>411      simp only [local_equiv.right_inv, preimage_inter, local_equiv.left_inv],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='local_equiv.right_inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.preimage_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='local_equiv.left_inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 847, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} (c : local_equiv.{?l_1 ?l_2} α β) {x : β}, @has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) x (@local_equiv.target.{?l_1 ?l_2} α β c) → @eq.{?l_2+1} β (@local_equiv.to_fun.{?l_1 ?l_2} α β c (@local_equiv.inv_fun.{?l_1 ?l_2} α β c x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {f : α → β} {s t : set.{?l_2} β}, @eq.{(max (?l_1+1) 1)} (set.{?l_1} α) (@set.preimage.{?l_1 ?l_2} α β f (@has_inter.inter.{?l_2} (set.{?l_2} β) (@set.has_inter.{?l_2} β) s t)) (@has_inter.inter.{?l_1} (set.{?l_1} α) (@set.has_inter.{?l_1} α) (@set.preimage.{?l_1 ?l_2} α β f s) (@set.preimage.{?l_1 ?l_2} α β f t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} (c : local_equiv.{?l_1 ?l_2} α β) {x : α}, @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x (@local_equiv.source.{?l_1 ?l_2} α β c) → @eq.{?l_1+1} α (@local_equiv.inv_fun.{?l_1 ?l_2} α β c (@local_equiv.to_fun.{?l_1 ?l_2} α β c x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s))
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.mk.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.map_target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.left_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_equiv.right_inv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
          (@has_inter.inter.{(max u_2 u_3)}
             (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
             (@set.has_inter.{(max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s))
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>412      let e := Z.local_triv&#x27; i,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 321, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Associate to a trivialization index `i : ι` the corresponding trivialization, i.e., a bijection
between `proj ⁻¹ (base_set i)` and `base_set i × F`. As the fiber above `x` is `F` but read in the
chart with index `index_at x`, the trivialization in the fiber above x is by definition the
coordinate change from i to `index_at x`, so it depends on `x`.
The local trivialization will ultimately be a local homeomorphism. For now, we only introduce the
local equiv version, denoted with a prime. In further developments, avoid this auxiliary version,
and use Z.local_triv instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s))
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>413      let e&#x27; := Z.local_triv&#x27; j,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 321, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Associate to a trivialization index `i : ι` the corresponding trivialization, i.e., a bijection
between `proj ⁻¹ (base_set i)` and `base_set i × F`. As the fiber above `x` is `F` but read in the
chart with index `index_at x`, the trivialization in the fiber above x is by definition the
coordinate change from i to `index_at x`, so it depends on `x`.
The local trivialization will ultimately be a local homeomorphism. For now, we only introduce the
local equiv version, denoted with a prime. In further developments, avoid this auxiliary version,
and use Z.local_triv instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>414      let f := e.symm.trans e&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The inverse of a local equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>415      have : is_open (f.source ∩ f.to_fun ⁻¹&#x27; s),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u_2 u_3)} [t : topological_space.{(max u_2 u_3)} α], set.{(max u_2 u_3)} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → set.{(max u_2 u_3)} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
          s))

ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;,
this :
  @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
          s))
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>416      { rw [local_equiv.eq_on_source_preimage (Z.local_triv&#x27;_trans i j)],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='local_equiv.eq_on_source_preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 361, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type (max u_2 u_3)} {e e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β}, @has_equiv.equiv.{(max u_2 u_3)+1} (local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β) (@setoid_has_equiv.{(max u_2 u_3)+1} (local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β) (@local_equiv.eq_on_source_setoid.{(max u_2 u_3) (max u_2 u_3)} α β)) e e&#x27; → ∀ (s : set.{(max u_2 u_3)} β), @eq.{(max u_2 u_3)+1} (set.{(max u_2 u_3)} α) (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} α) (@set.has_inter.{(max u_2 u_3)} α) (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} α β e) (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} α β (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} α β e) s)) (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} α) (@set.has_inter.{(max u_2 u_3)} α) (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} α β e&#x27;) (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} α β (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} α β e&#x27;) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Preimages are respected by equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The composition of two local trivializations is the trivialization change Z.triv_change i j.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
          s))

ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;,
this :
  @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
          s))
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
             (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j)))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j)))
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>417        exact (continuous_on_open_iff (Z.triv_change i j).open_source).1</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='continuous_on_open_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 475, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type (max u_2 u_3)} [_inst_1 : topological_space.{(max u_2 u_3)} α] [_inst_2 : topological_space.{(max u_2 u_3)} β] {f : α → β} {s : set.{(max u_2 u_3)} α}, @is_open.{(max u_2 u_3)} α _inst_1 s → iff (@continuous_on.{(max u_2 u_3) (max u_2 u_3)} α β _inst_1 _inst_2 f s) (∀ (t : set.{(max u_2 u_3)} β), @is_open.{(max u_2 u_3)} β _inst_2 t → @is_open.{(max u_2 u_3)} α _inst_1 (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} α) (@set.has_inter.{(max u_2 u_3)} α) s (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} α β f t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
             (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j)))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j)))
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>418          ((Z.triv_change i j).continuous_to_fun) _ s_open },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='s_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 279, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Local homeomorphism version of the trivialization change.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
             (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j)))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j)))
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;,
this :
  @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
          s))
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>419      convert this using 1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F)) (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F)) (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f) (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;,
this :
  @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
          s))
⊢ @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;,
this :
  @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
          s))
⊢ @eq.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>420      dsimp [local_equiv.trans_source],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='local_equiv.trans_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 297, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} (e : local_equiv.{?l_1 ?l_2} α β) (e&#x27; : local_equiv.{?l_2 ?l_3} β γ), @eq.{(max (?l_1+1) 1)} (set.{?l_1} α) (@local_equiv.source.{?l_1 ?l_3} α γ (@local_equiv.trans.{?l_1 ?l_2 ?l_3} α β γ e e&#x27;)) (@has_inter.inter.{?l_1} (set.{?l_1} α) (@set.has_inter.{?l_1} α) (@local_equiv.source.{?l_1 ?l_2} α β e) (@set.preimage.{?l_1 ?l_2} α β (@local_equiv.to_fun.{?l_1 ?l_2} α β e) (@local_equiv.source.{?l_2 ?l_3} β γ e&#x27;)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;,
this :
  @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
          s))
⊢ @eq.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;,
this :
  @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
          s))
⊢ @eq.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             e)
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e)
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e&#x27;)))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@function.comp.{(max u_2 u_3)+1 (max u_2 u_3)+1 (max u_2 u_3)+1} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e&#x27;)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e))
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>421      rw [← preimage_comp, inter_assoc]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.preimage_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.inter_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 861, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 370, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β γ : Type (max u_2 u_3)} {f : α → β} {g : β → γ} {s : set.{(max u_2 u_3)} γ}, @eq.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} α) (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} α γ (@function.comp.{(max u_2 u_3)+1 (max u_2 u_3)+1 (max u_2 u_3)+1} α β γ g f) s) (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} α β f (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} β γ g s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_2 u_3)} (a b c : set.{(max u_2 u_3)} α), @eq.{(max u_2 u_3)+1} (set.{(max u_2 u_3)} α) (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} α) (@set.has_inter.{(max u_2 u_3)} α) (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} α) (@set.has_inter.{(max u_2 u_3)} α) a b) c) (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} α) (@set.has_inter.{(max u_2 u_3)} α) a (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} α) (@set.has_inter.{(max u_2 u_3)} α) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;,
this :
  @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
          s))
⊢ @eq.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             e)
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e)
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e&#x27;)))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@function.comp.{(max u_2 u_3)+1 (max u_2 u_3)+1 (max u_2 u_3)+1} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e&#x27;)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e))
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;,
this :
  @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
          s))
⊢ @eq.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
             (@function.comp.{(max u_2 u_3)+1 (max u_2 u_3)+1 (max u_2 u_3)+1} (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)))
             s)))
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             e)
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e)
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e&#x27;)))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@function.comp.{(max u_2 u_3)+1 (max u_2 u_3)+1 (max u_2 u_3)+1} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e&#x27;)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e))
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;,
this :
  @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
          s))
⊢ @eq.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             e)
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e)
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e&#x27;)))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@function.comp.{(max u_2 u_3)+1 (max u_2 u_3)+1 (max u_2 u_3)+1} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e&#x27;)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e))
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>422    end,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
t : set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z),
j : ι,
s : set.{(max u_2 u_3)} (prod.{u_2 u_3} B F),
s_open : @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) s,
ts :
  @eq.{(max u_2 u_3)+1}
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    t
    (@has_inter.inter.{(max u_2 u_3)}
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_inter.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
          s)),
e : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i,
e&#x27; : local_equiv.{(max u_2 u_3) (max u_2 u_3)}
  (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
  (prod.{u_2 u_3} B F) :=
  @topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j,
f : local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) :=
  @local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (prod.{u_2 u_3} B F)
    (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       e)
    e&#x27;,
this :
  @is_open.{(max u_2 u_3)} (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) f)
          s))
⊢ @eq.{(max ((max u_2 u_3)+1) 1)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)))
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@set.preimage.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j))
                s))))
    (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@has_inter.inter.{(max u_2 u_3)} (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@set.has_inter.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
          (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             e)
          (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e)
             (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e&#x27;)))
       (@set.preimage.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)
          (@function.comp.{(max u_2 u_3)+1 (max u_2 u_3)+1 (max u_2 u_3)+1} (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e&#x27;)
             (@local_equiv.inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                e))
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>423    ..Z.local_triv&#x27; i }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 321, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' Associate to a trivialization index `i : ι` the corresponding trivialization, i.e., a bijection
between `proj ⁻¹ (base_set i)` and `base_set i × F`. As the fiber above `x` is `F` but read in the
chart with index `index_at x`, the trivialization in the fiber above x is by definition the
coordinate change from i to `index_at x`, so it depends on `x`.
The local trivialization will ultimately be a local homeomorphism. For now, we only introduce the
local equiv version, denoted with a prime. In further developments, avoid this auxiliary version,
and use Z.local_triv instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>424  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>425  /- We will now state again the basic properties of the local trivializations, but without primes,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>426  i.e., for the local homeomorphism instead of the local equiv. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>427  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>428  @[simp] lemma mem_local_triv_source (i : ι) (p : Z.total_space) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.total_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title=' Total space of a topological bundle created from core. It is equal to `B × F`, but as it is
not marked as reducible, typeclass inference will not infer the wrong topology, and will use the
instance `topological_fiber_bundle_core.to_topological_space` with the right topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>429    p ∈ (Z.local_triv i).source ↔ p.1 ∈ Z.base_set i :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 394, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type (max u_2 u_3)} [c : has_mem.{(max u_2 u_3) (max u_2 u_3)} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → set.{(max u_2 u_3)} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Local trivialization of a topological bundle created from core, as a local homeomorphism.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>430  by refl</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
p : @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z
⊢ iff
    (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_mem.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       p
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
             (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (@prod.fst.{u_2 u_3} B F p)
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>431  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
p : @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z
⊢ iff
    (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       (@set.has_mem.{(max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
       p
       (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
             (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (@prod.fst.{u_2 u_3} B F p)
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>432  @[simp] lemma mem_local_triv_target (i : ι) (p : B × F) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_3 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>433    p ∈ (Z.local_triv i).target ↔ p.1 ∈ Z.base_set i :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.target'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 394, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type (max u_2 u_3)} [c : has_mem.{(max u_2 u_3) (max u_2 u_3)} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → set.{(max u_2 u_3)} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Local trivialization of a topological bundle created from core, as a local homeomorphism.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>434  by { erw [mem_prod], simp }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.mem_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1415, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} {s : set.{u_2} α} {t : set.{u_3} β} {p : prod.{u_2 u_3} α β}, iff (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} α β) (set.{(max u_2 u_3)} (prod.{u_2 u_3} α β)) (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} α β)) p (@set.prod.{u_2 u_3} α β s t)) (and (@has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) (@prod.fst.{u_2 u_3} α β p) s) (@has_mem.mem.{u_3 u_3} β (set.{u_3} β) (@set.has_mem.{u_3} β) (@prod.snd.{u_2 u_3} α β p) t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
p : prod.{u_2 u_3} B F
⊢ iff
    (@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (set.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       (@set.has_mem.{(max u_2 u_3)} (prod.{u_2 u_3} B F))
       p
       (@local_equiv.target.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
             (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (@prod.fst.{u_2 u_3} B F p)
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
p : prod.{u_2 u_3} B F
⊢ iff
    (and
       (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (@prod.fst.{u_2 u_3} B F p)
          (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))
       (@has_mem.mem.{u_3 u_3} F (set.{u_3} F) (@set.has_mem.{u_3} F) (@prod.snd.{u_2 u_3} B F p) (@set.univ.{u_3} F)))
    (@has_mem.mem.{u_2 u_2} B (set.{u_2} B) (@set.has_mem.{u_2} B) (@prod.fst.{u_2 u_3} B F p)
       (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>435  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>436  @[simp] lemma local_triv_fst (i : ι) (p : Z.total_space) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.total_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title=' Total space of a topological bundle created from core. It is equal to `B × F`, but as it is
not marked as reducible, typeclass inference will not infer the wrong topology, and will use the
instance `topological_fiber_bundle_core.to_topological_space` with the right topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>437    ((Z.local_triv i).to_fun p).1 = p.1 := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 394, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_2} {a : α}, @eq.{u_2+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Local trivialization of a topological bundle created from core, as a local homeomorphism.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>438  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>439  @[simp] lemma local_triv_symm_fst (i : ι) (p : B × F) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_3 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>440    ((Z.local_triv i).inv_fun p).1 = p.1 := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 394, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_2} {a : α}, @eq.{u_2+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Local trivialization of a topological bundle created from core, as a local homeomorphism.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>441  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>442  /-- The composition of two local trivializations is the trivialization change Z.triv_change i j. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>443  lemma local_triv_trans (i j : ι) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>444    (Z.local_triv i).symm.trans (Z.local_triv j) ≈ Z.triv_change i j :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_homeomorph.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_homeomorph.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_equiv.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.triv_change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 394, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 85, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 261, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 394, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 326, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 279, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)} [_inst_1 : topological_space.{(max u_2 u_3)} α] [_inst_2 : topological_space.{(max u_2 u_3)} β], @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} α β _inst_1 _inst_2 → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} β α _inst_2 _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β γ : Type (max u_2 u_3)} [_inst_1 : topological_space.{(max u_2 u_3)} α] [_inst_2 : topological_space.{(max u_2 u_3)} β] [_inst_3 : topological_space.{(max u_2 u_3)} γ], @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} α β _inst_1 _inst_2 → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} β γ _inst_2 _inst_3 → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} α γ _inst_1 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u_2 u_3)} [c : has_equiv.{(max u_2 u_3)+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → ι → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Local trivialization of a topological bundle created from core, as a local homeomorphism.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The inverse of a local homeomorphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Composing two local homeomorphisms, by restricting to the maximal domain where their
composition is well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Local trivialization of a topological bundle created from core, as a local homeomorphism.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Local homeomorphism version of the trivialization change.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>445  Z.local_triv&#x27;_trans i j</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv&#x27;_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 361, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2) (i j : ι), @has_equiv.equiv.{(max u_2 u_3)+1} (local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)) (@setoid_has_equiv.{(max u_2 u_3)+1} (local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F)) (@local_equiv.eq_on_source_setoid.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F))) (@local_equiv.trans.{(max u_2 u_3) (max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@local_equiv.symm.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)) (@topological_fiber_bundle_core.local_triv&#x27;.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z j)) (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (prod.{u_2 u_3} B F) (prod.{u_2 u_3} B F) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@topological_fiber_bundle_core.triv_change.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The composition of two local trivializations is the trivialization change Z.triv_change i j.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>446  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>447  /-- Extended version of the local trivialization of a fiber bundle constructed from core,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>448  registering additionally in its type that it is a local bundle trivialization. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>449  def local_triv_ext (i : ι) : bundle_trivialization F Z.proj :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='bundle_trivialization'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 123, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {B : Type u_2} (F : Type u_3) {Z : Type u_4} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_4} Z] [_inst_3 : topological_space.{u_3} F], (Z → B) → Type (max u_2 u_3 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='A structure extending local homeomorphisms, defining a local trivialization of a projection
`proj : Z → B` with fiber `F`, as a local homeomorphism between `Z` and `B × F` defined between two
sets of the form `proj ⁻¹&#x27; base_set` and `base_set × F`, acting trivially on the first coordinate.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The projection from the total space of a topological fiber bundle core, on its base.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>450  { base_set      := Z.base_set i,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → ι → set.{u_2} B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>451    open_base_set := Z.is_open_base_set i,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.is_open_base_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F] (c : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2) (i : ι), @is_open.{u_2} B _inst_1 (@topological_fiber_bundle_core.base_set.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 c i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>452    source_eq     := rfl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>453    target_eq     := rfl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>454    proj_to_fun   := λp hp, by simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β), set.{(max u_2 u_3)} α) (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)) (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)) (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)) (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)) (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))) (@set.has_mem.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)) p (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)) (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)) (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)) (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)) (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2) (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
i : ι,
p : @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z,
hp :
  @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (@(λ {α β : Type (max u_2 u_3)} (c : local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β), set.{(max u_2 u_3)} α)
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
             (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)))))
    (@set.has_mem.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    p
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
             (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
             (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i)))))
⊢ @eq.{u_2+1} B
    (@prod.fst.{u_2 u_3} B F
       (@local_equiv.to_fun.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)}
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (prod.{u_2 u_3} B F)
             (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
             (@local_homeomorph.mk.{(max u_2 u_3) (max u_2 u_3)}
                (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (prod.{u_2 u_3} B F)
                (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                   (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_homeomorph.open_source.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                   (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_homeomorph.open_target.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                   (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_homeomorph.continuous_to_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                   (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))
                (@local_homeomorph.continuous_inv_fun.{(max u_2 u_3) (max u_2 u_3)}
                   (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (prod.{u_2 u_3} B F)
                   (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
                   (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
                   (@topological_fiber_bundle_core.local_triv.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z i))))
          p))
    (@topological_fiber_bundle_core.proj.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>455    ..Z.local_triv i }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 394, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Local trivialization of a topological bundle created from core, as a local homeomorphism.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>456  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>457  /-- A topological fiber bundle constructed from core is indeed a topological fiber bundle. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>458  theorem is_topological_fiber_bundle : is_topological_fiber_bundle F Z.proj :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='is_topological_fiber_bundle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;line&#x27;: 133, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Π {B : Type u_2} (F : Type u_3) {Z : Type u_4} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_4} Z] [_inst_3 : topological_space.{u_3} F], (Z → B) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title=' A topological fiber bundle with fiber F over a base B is a space projecting on B for which the
fibers are all homeomorphic to F, such that the local situation around each point is a direct
product.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The projection from the total space of a topological fiber bundle core, on its base.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>459  λx, ⟨Z.local_triv_ext (Z.index_at (Z.proj x)), by simp [local_triv_ext]⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv_ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.index_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='topological_fiber_bundle_core.local_triv_ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 449, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 449, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → @bundle_trivialization.{u_2 u_3 (max u_2 u_3)} B F (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) _inst_1 (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) _inst_2 (@topological_fiber_bundle_core.proj.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → B → ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type ?l_1} {B : Type ?l_2} {F : Type ?l_3} [_inst_1 : topological_space.{?l_2} B] [_inst_2 : topological_space.{?l_3} F] (Z : @topological_fiber_bundle_core.{?l_1 ?l_2 ?l_3} ι B _inst_1 F _inst_2), ι → @bundle_trivialization.{?l_2 ?l_3 (max ?l_2 ?l_3)} B F (@topological_fiber_bundle_core.total_space.{?l_1 ?l_2 ?l_3} ι B F _inst_1 _inst_2 Z) _inst_1 (@topological_fiber_bundle_core.to_topological_space.{?l_1 ?l_2 ?l_3} ι B F _inst_1 _inst_2 Z) _inst_2 (@topological_fiber_bundle_core.proj.{?l_1 ?l_2 ?l_3} ι B F _inst_1 _inst_2 Z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' Extended version of the local trivialization of a fiber bundle constructed from core,
registering additionally in its type that it is a local bundle trivialization.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The projection from the total space of a topological fiber bundle core, on its base.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Extended version of the local trivialization of a fiber bundle constructed from core,
registering additionally in its type that it is a local bundle trivialization.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
x : @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z
⊢ @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (@set.has_mem.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    x
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@bundle_trivialization.to_local_homeomorph.{u_2 u_3 (max u_2 u_3)} B F
             (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             _inst_1
             (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             _inst_2
             (@topological_fiber_bundle_core.proj.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
             (@topological_fiber_bundle_core.local_triv_ext.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z
                (@topological_fiber_bundle_core.index_at.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 Z
                   (@topological_fiber_bundle_core.proj.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z x))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>460  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>461  /-- The projection on the base of a topological bundle created from core is continuous -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>462  lemma continuous_proj : continuous Z.proj :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 644, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A function between topological spaces is continuous if the preimage
 of every open set is open.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The projection from the total space of a topological fiber bundle core, on its base.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>463  Z.is_topological_fiber_bundle.continuous_proj</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.is_topological_fiber_bundle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_topological_fiber_bundle.continuous_proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 458, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 173, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), @is_topological_fiber_bundle.{u_2 u_3 (max u_2 u_3)} B F (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) _inst_1 (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) _inst_2 (@topological_fiber_bundle_core.proj.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {B : Type u_2} {F : Type u_3} {Z : Type (max u_2 u_3)} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{(max u_2 u_3)} Z] [_inst_3 : topological_space.{u_3} F] {proj : Z → B}, @is_topological_fiber_bundle.{u_2 u_3 (max u_2 u_3)} B F Z _inst_1 _inst_2 _inst_3 proj → @continuous.{(max u_2 u_3) u_2} Z B _inst_2 _inst_1 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A topological fiber bundle constructed from core is indeed a topological fiber bundle.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The projection from a topological fiber bundle to its base is continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>464  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>465  /-- The projection on the base of a topological bundle created from core is an open map -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>466  lemma is_open_map_proj : is_open_map Z.proj :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='is_open_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/maps.lean&#x27;, &#x27;line&#x27;: 197, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title=' A map `f : α → β` is said to be an *open map*, if the image of any open `U : set α`
is open in `β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The projection from the total space of a topological fiber bundle core, on its base.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>467  Z.is_topological_fiber_bundle.is_open_map_proj</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.is_topological_fiber_bundle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_topological_fiber_bundle.is_open_map_proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 458, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 183, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), @is_topological_fiber_bundle.{u_2 u_3 (max u_2 u_3)} B F (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) _inst_1 (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) _inst_2 (@topological_fiber_bundle_core.proj.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {B : Type u_2} {F : Type u_3} {Z : Type (max u_2 u_3)} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{(max u_2 u_3)} Z] [_inst_3 : topological_space.{u_3} F] {proj : Z → B}, @is_topological_fiber_bundle.{u_2 u_3 (max u_2 u_3)} B F Z _inst_1 _inst_2 _inst_3 proj → @is_open_map.{(max u_2 u_3) u_2} Z B _inst_2 _inst_1 proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A topological fiber bundle constructed from core is indeed a topological fiber bundle.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The projection from a topological fiber bundle to its base is an open map.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>468  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>469  /-- Preferred local trivialization of a fiber bundle constructed from core, at a given point, as</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>470  a local homeomorphism -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>471  def local_triv_at (p : Z.total_space) : local_homeomorph Z.total_space (B × F) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.total_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='local_homeomorph'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.total_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u_5) (β : Type u_6) [_inst_5 : topological_space.{u_5} α] [_inst_6 : topological_space.{u_6} β], Type (max u_5 u_6)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_3 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title=' Total space of a topological bundle created from core. It is equal to `B × F`, but as it is
not marked as reducible, typeclass inference will not infer the wrong topology, and will use the
instance `topological_fiber_bundle_core.to_topological_space` with the right topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='local homeomorphisms, defined on open subsets of the space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Total space of a topological bundle created from core. It is equal to `B × F`, but as it is
not marked as reducible, typeclass inference will not infer the wrong topology, and will use the
instance `topological_fiber_bundle_core.to_topological_space` with the right topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>472    Z.local_triv (Z.index_at (Z.proj p))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.index_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 394, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → B → ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Local trivialization of a topological bundle created from core, as a local homeomorphism.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The projection from the total space of a topological fiber bundle core, on its base.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>473  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>474  @[simp] lemma mem_local_triv_at_source (p : Z.total_space) : p ∈ (Z.local_triv_at p).source :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.total_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 471, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type (max u_2 u_3)} [c : has_mem.{(max u_2 u_3) (max u_2 u_3)} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → set.{(max u_2 u_3)} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title=' Total space of a topological bundle created from core. It is equal to `B × F`, but as it is
not marked as reducible, typeclass inference will not infer the wrong topology, and will use the
instance `topological_fiber_bundle_core.to_topological_space` with the right topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title=' Preferred local trivialization of a fiber bundle constructed from core, at a given point, as
a local homeomorphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>475  by simp [local_triv_at]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='topological_fiber_bundle_core.local_triv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 471, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type ?l_1} {B : Type ?l_2} {F : Type ?l_3} [_inst_1 : topological_space.{?l_2} B] [_inst_2 : topological_space.{?l_3} F] (Z : @topological_fiber_bundle_core.{?l_1 ?l_2 ?l_3} ι B _inst_1 F _inst_2), @topological_fiber_bundle_core.total_space.{?l_1 ?l_2 ?l_3} ι B F _inst_1 _inst_2 Z → @local_homeomorph.{(max ?l_2 ?l_3) (max ?l_2 ?l_3)} (@topological_fiber_bundle_core.total_space.{?l_1 ?l_2 ?l_3} ι B F _inst_1 _inst_2 Z) (prod.{?l_2 ?l_3} B F) (@topological_fiber_bundle_core.to_topological_space.{?l_1 ?l_2 ?l_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{?l_2 ?l_3} B F _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Preferred local trivialization of a fiber bundle constructed from core, at a given point, as
a local homeomorphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
p : @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z
⊢ @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (@set.has_mem.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    p
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@topological_fiber_bundle_core.local_triv_at.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>476  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
B : Type u_2,
F : Type u_3,
_inst_1 : topological_space.{u_2} B,
_inst_2 : topological_space.{u_3} F,
Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2,
p : @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z
⊢ @has_mem.mem.{(max u_2 u_3) (max u_2 u_3)}
    (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
    (set.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    (@set.has_mem.{(max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z))
    p
    (@local_equiv.source.{(max u_2 u_3) (max u_2 u_3)}
       (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
       (prod.{u_2 u_3} B F)
       (@local_homeomorph.to_local_equiv.{(max u_2 u_3) (max u_2 u_3)}
          (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (prod.{u_2 u_3} B F)
          (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)
          (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)
          (@topological_fiber_bundle_core.local_triv_at.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>477  @[simp] lemma local_triv_at_fst (p q : Z.total_space) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.total_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title=' Total space of a topological bundle created from core. It is equal to `B × F`, but as it is
not marked as reducible, typeclass inference will not infer the wrong topology, and will use the
instance `topological_fiber_bundle_core.to_topological_space` with the right topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>478    ((Z.local_triv_at p).to_fun q).1 = q.1 := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 471, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_2} {a : α}, @eq.{u_2+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' Preferred local trivialization of a fiber bundle constructed from core, at a given point, as
a local homeomorphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>479  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>480  @[simp] lemma local_triv_at_symm_fst (p : Z.total_space) (q : B × F) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.total_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_3 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title=' Total space of a topological bundle created from core. It is equal to `B × F`, but as it is
not marked as reducible, typeclass inference will not infer the wrong topology, and will use the
instance `topological_fiber_bundle_core.to_topological_space` with the right topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>481    ((Z.local_triv_at p).inv_fun q).1 = q.1 := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 471, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (max u_2 u_3)}, local_equiv.{(max u_2 u_3) (max u_2 u_3)} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_3} B F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, prod.{u_2 u_3} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_2} {a : α}, @eq.{u_2+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' Preferred local trivialization of a fiber bundle constructed from core, at a given point, as
a local homeomorphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>482  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>483  /-- Preferred local trivialization of a fiber bundle constructed from core, at a given point, as</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>484  a bundle trivialization -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>485  def local_triv_at_ext (p : Z.total_space) : bundle_trivialization F Z.proj :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.total_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='bundle_trivialization'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 123, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {B : Type u_2} (F : Type u_3) {Z : Type u_4} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_4} Z] [_inst_3 : topological_space.{u_3} F], (Z → B) → Type (max u_2 u_3 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title=' Total space of a topological bundle created from core. It is equal to `B × F`, but as it is
not marked as reducible, typeclass inference will not infer the wrong topology, and will use the
instance `topological_fiber_bundle_core.to_topological_space` with the right topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='A structure extending local homeomorphisms, defining a local trivialization of a projection
`proj : Z → B` with fiber `F`, as a local homeomorphism between `Z` and `B × F` defined between two
sets of the form `proj ⁻¹&#x27; base_set` and `base_set × F`, acting trivially on the first coordinate.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The projection from the total space of a topological fiber bundle core, on its base.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>486    Z.local_triv_ext (Z.index_at (Z.proj p))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv_ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.index_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.proj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 449, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 236, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), ι → @bundle_trivialization.{u_2 u_3 (max u_2 u_3)} B F (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) _inst_1 (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) _inst_2 (@topological_fiber_bundle_core.proj.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} [_inst_1 : topological_space.{u_2} B] {F : Type u_3} [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → B → ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z → B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' Extended version of the local trivialization of a fiber bundle constructed from core,
registering additionally in its type that it is a local bundle trivialization.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The projection from the total space of a topological fiber bundle core, on its base.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>487  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>488  @[simp] lemma local_triv_at_ext_to_local_homeomorph (p : Z.total_space) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.total_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                          </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F], @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2 → Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title=' Total space of a topological bundle created from core. It is equal to `B × F`, but as it is
not marked as reducible, typeclass inference will not infer the wrong topology, and will use the
instance `topological_fiber_bundle_core.to_topological_space` with the right topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>489    (Z.local_triv_at_ext p).to_local_homeomorph = Z.local_triv_at p := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv_at_ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='bundle_trivialization.to_local_homeomorph'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_fiber_bundle_core.local_triv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 485, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 123, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 471, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z → @bundle_trivialization.{u_2 u_3 (max u_2 u_3)} B F (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) _inst_1 (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) _inst_2 (@topological_fiber_bundle_core.proj.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {B : Type u_2} {F : Type u_3} {Z : Type (max u_2 u_3)} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{(max u_2 u_3)} Z] [_inst_3 : topological_space.{u_3} F] {proj : Z → B}, @bundle_trivialization.{u_2 u_3 (max u_2 u_3)} B F Z _inst_1 _inst_2 _inst_3 proj → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} Z (prod.{u_2 u_3} B F) _inst_2 (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u_2 u_3)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {ι : Type u_1} {B : Type u_2} {F : Type u_3} [_inst_1 : topological_space.{u_2} B] [_inst_2 : topological_space.{u_3} F] (Z : @topological_fiber_bundle_core.{u_1 u_2 u_3} ι B _inst_1 F _inst_2), @topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z → @local_homeomorph.{(max u_2 u_3) (max u_2 u_3)} (@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (prod.{u_2 u_3} B F) (@topological_fiber_bundle_core.to_topological_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z) (@prod.topological_space.{u_2 u_3} B F _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@topological_fiber_bundle_core.total_space.{u_1 u_2 u_3} ι B F _inst_1 _inst_2 Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type (max u_2 u_3)} {a : α}, @eq.{(max u_2 u_3)+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' Preferred local trivialization of a fiber bundle constructed from core, at a given point, as
a bundle trivialization'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title=' Preferred local trivialization of a fiber bundle constructed from core, at a given point, as
a local homeomorphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>490  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>491  end topological_fiber_bundle_core</code></pre>
</body>