<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2017 Johannes Hölzl. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Johannes Hölzl, Mario Carneiro</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  Separation properties of topological spaces.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  import topology.subset_properties</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  open set filter lattice</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  open_locale topological_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  local attribute [instance] classical.prop_decidable -- TODO: use &quot;open_locale classical&quot;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='classical.prop_decidable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π (a : Prop), decidable a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  universes u v</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  variables {α : Type u} {β : Type v} [topological_space α]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  section separation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  /-- A T₀ space, also known as a Kolmogorov space, is a topological space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21    where for every pair `x ≠ y`, there is an open set containing one but not the other. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  class t0_space (α : Type u) [topological_space α] : Prop :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  (t0 : ∀ x y, x ≠ y → ∃ U:set α, is_open U ∧ (xor (x ∈ U) (y ∈ U)))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xor'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 219, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  theorem exists_open_singleton_of_fintype [t0_space α]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='t0_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;line&#x27;: 22, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='A T₀ space, also known as a Kolmogorov space, is a topological space
 where for every pair `x ≠ y`, there is an open set containing one but not the other.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26    [f : fintype α] [decidable_eq α] [ha : nonempty α] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 790, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_4 → Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Sort u → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`fintype α` means that `α` is finite, i.e. there are only
 finitely many distinct elements of type `α`. The evidence of this
 is a finset `elems` (a list up to permutation without duplicates),
 together with a proof that everything of type `α` is in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27    ∃ x:α, is_open ({x}:set α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  have H : ∀ (T : finset α), T ≠ ∅ → ∃ x ∈ T, ∃ u, is_open u ∧ {x} = {y | y ∈ T} ∩ u :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='finset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 17, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : has_emptyc.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`finset α` is the type of finite sets of elements of `α`. It is implemented
 as a multiset (a list up to permutation) which has no duplicate elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α
⊢ ∀ (T : finset.{u} α),
    @ne.{u+1} (finset.{u} α) T (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y T))
                           u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30    intro T,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α
⊢ ∀ (T : finset.{u} α),
    @ne.{u+1} (finset.{u} α) T (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y T))
                           u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α
⊢ @ne.{u+1} (finset.{u} α) T (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
  @Exists.{u+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T)
         (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y T))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31    apply finset.case_strong_induction_on T,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='finset.case_strong_induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 1279, &#x27;column&#x27;: 28}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] {p : finset.{u} α → Prop} (s : finset.{u} α), p (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) → (∀ (a : α) (s : finset.{u} α), not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s) → (∀ (t : finset.{u} α), @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t s → p t) → p (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), _inst_1 a b)) a s)) → p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α
⊢ @ne.{u+1} (finset.{u} α) T (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
  @Exists.{u+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T)
         (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y T))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α
⊢ @ne.{u+1} (finset.{u} α) (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
  @Exists.{u+1} α
    (λ (x : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x
            (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x
              (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))))
                         u)))))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α
⊢ ∀ (a : α) (s : finset.{u} α),
    not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s) →
    (∀ (t : finset.{u} α),
       @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t s →
       @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
       @Exists.{u+1} α
         (λ (x : α),
            @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
              (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
                 @Exists.{(max (u+1) 1)} (set.{u} α)
                   (λ (u : set.{u} α),
                      and (@is_open.{u} α _inst_1 u)
                        (@eq.{u+1} (set.{u} α)
                           (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                           (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                              (@set_of.{u} α
                                 (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                              u)))))) →
    @ne.{u+1} (finset.{u} α)
      (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) a
         s)
      (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0}
           (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 a
                 s))
           (λ
            (H :
              @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x
                (@insert.{u u} α (finset.{u} α)
                   (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                   a
                   s)),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α),
                                 @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                   (@insert.{u u} α (finset.{u} α)
                                      (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                      a
                                      s)))
                           u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32    { intro h, exact (h rfl).elim },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u+1} (finset.{u} α) (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α
⊢ @ne.{u+1} (finset.{u} α) (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
  @Exists.{u+1} α
    (λ (x : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x
            (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x
              (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))))
                         u)))))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α
⊢ ∀ (a : α) (s : finset.{u} α),
    not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s) →
    (∀ (t : finset.{u} α),
       @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t s →
       @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
       @Exists.{u+1} α
         (λ (x : α),
            @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
              (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
                 @Exists.{(max (u+1) 1)} (set.{u} α)
                   (λ (u : set.{u} α),
                      and (@is_open.{u} α _inst_1 u)
                        (@eq.{u+1} (set.{u} α)
                           (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                           (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                              (@set_of.{u} α
                                 (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                              u)))))) →
    @ne.{u+1} (finset.{u} α)
      (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) a
         s)
      (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0}
           (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 a
                 s))
           (λ
            (H :
              @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x
                (@insert.{u u} α (finset.{u} α)
                   (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                   a
                   s)),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α),
                                 @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                   (@insert.{u u} α (finset.{u} α)
                                      (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                      a
                                      s)))
                           u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α
⊢ @ne.{u+1} (finset.{u} α) (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
  @Exists.{u+1} α
    (λ (x : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x
            (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x
              (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
h :
  @ne.{u+1} (finset.{u} α) (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))
⊢ @Exists.{u+1} α
    (λ (x : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x
            (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x
              (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α
⊢ ∀ (a : α) (s : finset.{u} α),
    not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s) →
    (∀ (t : finset.{u} α),
       @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t s →
       @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
       @Exists.{u+1} α
         (λ (x : α),
            @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
              (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
                 @Exists.{(max (u+1) 1)} (set.{u} α)
                   (λ (u : set.{u} α),
                      and (@is_open.{u} α _inst_1 u)
                        (@eq.{u+1} (set.{u} α)
                           (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                           (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                              (@set_of.{u} α
                                 (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                              u)))))) →
    @ne.{u+1} (finset.{u} α)
      (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) a
         s)
      (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0}
           (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 a
                 s))
           (λ
            (H :
              @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x
                (@insert.{u u} α (finset.{u} α)
                   (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                   a
                   s)),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α),
                                 @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                   (@insert.{u u} α (finset.{u} α)
                                      (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                      a
                                      s)))
                           u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33    { intros x S hxS ih h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α
⊢ ∀ (a : α) (s : finset.{u} α),
    not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s) →
    (∀ (t : finset.{u} α),
       @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t s →
       @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
       @Exists.{u+1} α
         (λ (x : α),
            @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
              (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
                 @Exists.{(max (u+1) 1)} (set.{u} α)
                   (λ (u : set.{u} α),
                      and (@is_open.{u} α _inst_1 u)
                        (@eq.{u+1} (set.{u} α)
                           (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                           (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                              (@set_of.{u} α
                                 (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                              u)))))) →
    @ne.{u+1} (finset.{u} α)
      (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) a
         s)
      (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0}
           (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 a
                 s))
           (λ
            (H :
              @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x
                (@insert.{u u} α (finset.{u} α)
                   (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                   a
                   s)),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α),
                                 @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                   (@insert.{u u} α (finset.{u} α)
                                      (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                      a
                                      s)))
                           u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34      by_cases hs : S = ∅,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) [c : has_emptyc.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : @eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)))
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35      { existsi [x, finset.mem_insert_self x S, univ, is_open_univ],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_insert_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 222, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] (a : α) (s : finset.{u} α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), _inst_1 a b)) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [t : topological_space.{u} α], @is_open.{u} α t (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : @eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)))
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : @eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : @eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))
⊢ @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@set.univ.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36        rw [hs, inter_univ], refl },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.inter_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 396, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (a : set.{u} α), @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) a (@set.univ.{u} α)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : @eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))
⊢ @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@set.univ.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : @eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))
⊢ @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)))))
       (@set.univ.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : @eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))
⊢ @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)))
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37      { rcases ih S (finset.subset.refl S) hs with ⟨y, hy, V, hv1, hv2⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='finset.subset.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (t : finset.{u} α), @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S → @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) → @Exists.{u+1} α (λ (x : α), @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t) (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), and (@is_open.{u} α _inst_1 u) (@eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t)) u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} (s : finset.{u} α), @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) s s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)))
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38        by_cases hxV : x ∈ V,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V)
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39        { cases t0_space.t0 x y (λ hxy, hxS $ by rwa hxy) with U hu,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='t0_space.t0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hxS'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 22, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_2 : topological_space.{u} α] [c : @t0_space.{u} α _inst_2] (x y : α), @ne.{u+1} α x y → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (U : set.{u} α), and (@is_open.{u} α _inst_2 U) (xor (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V)
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
hxy : @eq.{u+1} α x y
⊢ @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu :
  and (@is_open.{u} α _inst_1 U)
    (xor (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U)
       (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U))
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40          rcases hu with ⟨hu1, ⟨hu2, hu3⟩ | ⟨hu2, hu3⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@is_open.{u} α _inst_1 U) (xor (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu :
  and (@is_open.{u} α _inst_1 U)
    (xor (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U)
       (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U))
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U)
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U)
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41          { existsi [x, finset.mem_insert_self x S, U ∩ V, is_open_inter hu1 hv1],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_insert_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hu1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hv1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 222, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] (a : α) (s : finset.{u} α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), _inst_1 a b)) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s₁ s₂ : set.{u} α} [t : topological_space.{u} α], @is_open.{u} α t s₁ → @is_open.{u} α t s₂ → @is_open.{u} α t (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u} α _inst_1 U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u} α _inst_1 V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U)
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U)
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U)
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U)
⊢ @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42            apply set.ext,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='set.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : set.{u} α}, (∀ (x : α), iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x a) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x b)) → @eq.{(max (u+1) 1)} (set.{u} α) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U)
⊢ @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U)
⊢ ∀ (x_1 : α),
    iff
      (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1
         (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))
      (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1
         (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
            (@set_of.{u} α
               (λ (y : α),
                  @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                    (@insert.{u u} α (finset.{u} α)
                       (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                       x
                       S)))
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43            intro z,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U)
⊢ ∀ (x_1 : α),
    iff
      (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1
         (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))
      (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1
         (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
            (@set_of.{u} α
               (λ (y : α),
                  @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                    (@insert.{u u} α (finset.{u} α)
                       (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                       x
                       S)))
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α
⊢ iff
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
       (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@set_of.{u} α
             (λ (y : α),
                @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                  (@insert.{u u} α (finset.{u} α)
                     (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                     x
                     S)))
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44            split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α
⊢ iff
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
       (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@set_of.{u} α
             (λ (y : α),
                @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                  (@insert.{u u} α (finset.{u} α)
                     (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                     x
                     S)))
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45            { intro hzx,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hzx :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46              rw set.mem_singleton_iff at hzx,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set.mem_singleton_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 509, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : α}, iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) b)) (@eq.{u+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hzx :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hzx : @eq.{u+1} α z x
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47              rw hzx,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hzx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hzx : @eq.{u+1} α z x
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hzx : @eq.{u+1} α z x
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48              exact ⟨finset.mem_insert_self x S, ⟨hu2, hxV⟩⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='finset.mem_insert_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hu2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hxV'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 222, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] (a : α) (s : finset.{u} α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), _inst_1 a b)) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hzx : @eq.{u+1} α z x
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49            { intro hz,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50              rw set.mem_singleton_iff,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set.mem_singleton_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 509, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : α}, iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) b)) (@eq.{u+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51              rcases hz with ⟨hz1, hz2, hz3⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='hz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S))) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52              cases finset.mem_insert.1 hz1 with hz4 hz4,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='finset.mem_insert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hz1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 220, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] {a b : α} {s : finset.{u} α}, iff (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), _inst_1 a b)) b s)) (or (@eq.{u+1} α a b) (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @eq.{u+1} α z x
⊢ @eq.{u+1} α z x

case or.inr
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53              { exact hz4 },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='hz4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @eq.{u+1} α z x
⊢ @eq.{u+1} α z x

case or.inr
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @eq.{u+1} α z x
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54              { have h1 : z ∈ {y : α | y ∈ S} ∩ V,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55                { exact ⟨hz4, hz3⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='hz4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hz3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56                rw ← hv2 at h1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='hv2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S)) V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57                rw set.mem_singleton_iff at h1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='set.mem_singleton_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 509, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : α}, iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) b)) (@eq.{u+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S,
h1 : @eq.{u+1} α z y
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58                rw h1 at hz2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='h1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z U,
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S,
h1 : @eq.{u+1} α z y
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S,
h1 : @eq.{u+1} α z y,
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59                exact (hu3 hz2).elim } } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='hu3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hz2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz3 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz4 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S,
h1 : @eq.{u+1} α z y,
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U
⊢ @eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U)
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60          { existsi [y, finset.mem_insert_of_mem hy, U ∩ V, is_open_inter hu1 hv1],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_insert_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hu1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hv1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] {a b : α} {s : finset.{u} α}, @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s → @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), _inst_1 a b)) b s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s₁ s₂ : set.{u} α} [t : topological_space.{u} α], @is_open.{u} α t s₁ → @is_open.{u} α t s₂ → @is_open.{u} α t (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s₁ s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u} α _inst_1 U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u} α _inst_1 V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U)
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U)
⊢ @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61            apply set.ext,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='set.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : set.{u} α}, (∀ (x : α), iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x a) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x b)) → @eq.{(max (u+1) 1)} (set.{u} α) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U)
⊢ @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U)
⊢ ∀ (x_1 : α),
    iff
      (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1
         (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y))
      (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1
         (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
            (@set_of.{u} α
               (λ (y : α),
                  @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                    (@insert.{u u} α (finset.{u} α)
                       (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                       x
                       S)))
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62            intro z,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U)
⊢ ∀ (x_1 : α),
    iff
      (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1
         (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y))
      (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1
         (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
            (@set_of.{u} α
               (λ (y : α),
                  @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                    (@insert.{u u} α (finset.{u} α)
                       (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                       x
                       S)))
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α
⊢ iff
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
       (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y))
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@set_of.{u} α
             (λ (y : α),
                @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                  (@insert.{u u} α (finset.{u} α)
                     (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                     x
                     S)))
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63            split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α
⊢ iff
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
       (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y))
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@set_of.{u} α
             (λ (y : α),
                @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                  (@insert.{u u} α (finset.{u} α)
                     (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                     x
                     S)))
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64            { intro hz,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65              rw set.mem_singleton_iff at hz,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set.mem_singleton_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 509, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : α}, iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) b)) (@eq.{u+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz : @eq.{u+1} α z y
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66              rw hz,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz : @eq.{u+1} α z y
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz : @eq.{u+1} α z y
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67              refine ⟨finset.mem_insert_of_mem hy, hu2, _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='finset.mem_insert_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hu2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] {a b : α} {s : finset.{u} α}, @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s → @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), _inst_1 a b)) b s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz : @eq.{u+1} α z y
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz : @eq.{u+1} α z y
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68              have h1 : y ∈ {y} := set.mem_singleton y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.mem_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 516, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz : @eq.{u+1} α z y
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y V'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz : @eq.{u+1} α z y,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69              rw hv2 at h1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hv2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S)) V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz : @eq.{u+1} α z y,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y V'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz : @eq.{u+1} α z y,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70              exact h1.2 },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='h1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S)) V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz : @eq.{u+1} α z y,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y V'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71            { intro hz,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72              rw set.mem_singleton_iff,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set.mem_singleton_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 509, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : α}, iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) b)) (@eq.{u+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))
⊢ @eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73              cases hz with hz1 hz2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='hz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S))) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V))
⊢ @eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)
⊢ @eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74              cases finset.mem_insert.1 hz1 with hz3 hz3,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='finset.mem_insert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hz1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 220, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] {a b : α} {s : finset.{u} α}, iff (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), _inst_1 a b)) b s)) (or (@eq.{u+1} α a b) (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)
⊢ @eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V),
hz3 : @eq.{u+1} α z x
⊢ @eq.{u+1} α z y

case or.inr
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V),
hz3 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S
⊢ @eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75              { rw hz3 at hz2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='hz3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V),
hz3 : @eq.{u+1} α z x
⊢ @eq.{u+1} α z y

case or.inr
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V),
hz3 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S
⊢ @eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V),
hz3 : @eq.{u+1} α z x
⊢ @eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz3 : @eq.{u+1} α z x,
hz2 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)
⊢ @eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76                exact (hu3 hz2.1).elim },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='hu3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hz2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz3 : @eq.{u+1} α z x,
hz2 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)
⊢ @eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V),
hz3 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S
⊢ @eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77              { have h1 : z ∈ {y : α | y ∈ S} ∩ V := ⟨hz3, hz2.2⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='S'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hz3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hz2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V),
hz3 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S
⊢ @eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V),
hz3 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)
⊢ @eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78                rw ← hv2 at h1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='hv2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S)) V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V),
hz3 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)
⊢ @eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V),
hz3 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
⊢ @eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79                rw set.mem_singleton_iff at h1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='set.mem_singleton_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 509, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : α}, iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) b)) (@eq.{u+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V),
hz3 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
⊢ @eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V),
hz3 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S,
h1 : @eq.{u+1} α z y
⊢ @eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80                exact h1 } } } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='h1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V,
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y U,
hu3 : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x U),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) U V),
hz3 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S,
h1 : @eq.{u+1} α z y
⊢ @eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V)
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81        { existsi [y, finset.mem_insert_of_mem hy, V, hv1],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_insert_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hv1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] {a b : α} {s : finset.{u} α}, @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s → @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), _inst_1 a b)) b s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u} α _inst_1 V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V)
⊢ @Exists.{u+1} α
    (λ (x_1 : α),
       @Exists.{0}
         (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))
         (λ
          (H :
            @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x_1
              (@insert.{u u} α (finset.{u} α)
                 (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                 x
                 S)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x_1)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@insert.{u u} α (finset.{u} α)
                                    (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                                    x
                                    S)))
                         u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V)
⊢ @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82          apply set.ext,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='set.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : set.{u} α}, (∀ (x : α), iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x a) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x b)) → @eq.{(max (u+1) 1)} (set.{u} α) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V)
⊢ @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V)
⊢ ∀ (x_1 : α),
    iff
      (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1
         (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y))
      (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1
         (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
            (@set_of.{u} α
               (λ (y : α),
                  @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                    (@insert.{u u} α (finset.{u} α)
                       (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                       x
                       S)))
            V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83          intro z,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V)
⊢ ∀ (x_1 : α),
    iff
      (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1
         (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y))
      (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x_1
         (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
            (@set_of.{u} α
               (λ (y : α),
                  @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                    (@insert.{u u} α (finset.{u} α)
                       (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                       x
                       S)))
            V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α
⊢ iff
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
       (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y))
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@set_of.{u} α
             (λ (y : α),
                @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                  (@insert.{u u} α (finset.{u} α)
                     (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                     x
                     S)))
          V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84          split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α
⊢ iff
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
       (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y))
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@set_of.{u} α
             (λ (y : α),
                @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                  (@insert.{u u} α (finset.{u} α)
                     (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                     x
                     S)))
          V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V)

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85          { intro hz,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V)

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86            rw set.mem_singleton_iff at hz,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='set.mem_singleton_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 509, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : α}, iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) b)) (@eq.{u+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz : @eq.{u+1} α z y
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87            rw hz,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='hz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz : @eq.{u+1} α z y
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz : @eq.{u+1} α z y
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88            split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz : @eq.{u+1} α z y
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz : @eq.{u+1} α z y
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S)))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz : @eq.{u+1} α z y
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89            { exact finset.mem_insert_of_mem hy },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='finset.mem_insert_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] {a b : α} {s : finset.{u} α}, @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s → @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), _inst_1 a b)) b s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz : @eq.{u+1} α z y
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S)))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz : @eq.{u+1} α z y
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y V'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz : @eq.{u+1} α z y
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz : @eq.{u+1} α z y
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90            { have h1 : y ∈ {y} := set.mem_singleton y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.mem_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 516, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz : @eq.{u+1} α z y
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y V'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz : @eq.{u+1} α z y,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91              rw hv2 at h1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hv2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S)) V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz : @eq.{u+1} α z y,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y V'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz : @eq.{u+1} α z y,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92              exact h1.2 } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='h1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S)) V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz : @eq.{u+1} α z y,
h1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y V'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93          { intro hz,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94            rw hv2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='hv2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S)) V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95            cases hz with hz1 hz2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='hz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S))) V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α),
             @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
               (@insert.{u u} α (finset.{u} α)
                  (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
                  x
                  S)))
       V)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96            cases finset.mem_insert.1 hz1 with hz3 hz3,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='finset.mem_insert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hz1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 220, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] {a b : α} {s : finset.{u} α}, iff (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), _inst_1 a b)) b s)) (or (@eq.{u+1} α a b) (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz3 : @eq.{u+1} α z x
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)

case or.inr
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz3 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97            { rw hz3 at hz2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hz3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α z x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz3 : @eq.{u+1} α z x
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)

case or.inr
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz3 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz3 : @eq.{u+1} α z x
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz3 : @eq.{u+1} α z x,
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98              exact (hxV hz2).elim },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='hxV'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hz2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz3 : @eq.{u+1} α z x,
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz3 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99            { exact ⟨hz3, hz2⟩ } } } } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='hz3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hz2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
T : finset.{u} α,
x : α,
S : finset.{u} α,
hxS : not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x S),
ih :
  ∀ (t : finset.{u} α),
    @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) t S →
    @ne.{u+1} (finset.{u} α) t (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x t),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y t))
                           u))))),
h :
  @ne.{u+1} (finset.{u} α)
    (@insert.{u u} α (finset.{u} α) (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b)) x S)
    (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)),
hs : not (@eq.{u+1} (finset.{u} α) S (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))),
y : α,
hy : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S,
V : set.{u} α,
hv1 : @is_open.{u} α _inst_1 V,
hv2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V),
hxV : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x V),
z : α,
hz1 :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@set_of.{u} α
       (λ (y : α),
          @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
            (@insert.{u u} α (finset.{u} α)
               (@finset.has_insert.{u} α (λ (a b : α), (λ (a b : α), _inst_3 a b) a b))
               x
               S))),
hz2 : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z V,
hz3 : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) z S
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y S))
       V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
H :
  ∀ (T : finset.{u} α),
    @ne.{u+1} (finset.{u} α) T (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y T))
                           u)))))
⊢ @Exists.{u+1} α
    (λ (x : α),
       @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102    apply nonempty.elim ha, intro x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nonempty.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 793, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {p : Prop}, nonempty.{u+1} α → (α → p) → p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nonempty.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
H :
  ∀ (T : finset.{u} α),
    @ne.{u+1} (finset.{u} α) T (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y T))
                           u)))))
⊢ @Exists.{u+1} α
    (λ (x : α),
       @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
H :
  ∀ (T : finset.{u} α),
    @ne.{u+1} (finset.{u} α) T (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y T))
                           u)))))
⊢ α →
  @Exists.{u+1} α
    (λ (x : α),
       @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
H :
  ∀ (T : finset.{u} α),
    @ne.{u+1} (finset.{u} α) T (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y T))
                           u))))),
x : α
⊢ @Exists.{u+1} α
    (λ (x : α),
       @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103    specialize H finset.univ (finset.ne_empty_of_mem $ finset.mem_univ x),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.ne_empty_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 143, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (T : finset.{u} α), @ne.{u+1} (finset.{u} α) T (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) → @Exists.{u+1} α (λ (x : α), @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T) (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), and (@is_open.{u} α _inst_1 u) (@eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y T)) u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {a : α} {s : finset.{u} α}, @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s → @ne.{u+1} (finset.{u} α) s (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α] (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
H :
  ∀ (T : finset.{u} α),
    @ne.{u+1} (finset.{u} α) T (@has_emptyc.emptyc.{u} (finset.{u} α) (@finset.has_emptyc.{u} α)) →
    @Exists.{u+1} α
      (λ (x : α),
         @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T)
           (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x T),
              @Exists.{(max (u+1) 1)} (set.{u} α)
                (λ (u : set.{u} α),
                   and (@is_open.{u} α _inst_1 u)
                     (@eq.{u+1} (set.{u} α)
                        (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                           (@set_of.{u} α
                              (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y T))
                           u))))),
x : α
⊢ @Exists.{u+1} α
    (λ (x : α),
       @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x : α,
H :
  @Exists.{u+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α f))
         (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α f)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@finset.univ.{u} α f)))
                         u)))))
⊢ @Exists.{u+1} α
    (λ (x : α),
       @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104    rcases H with ⟨y, hyf, U, hu1, hu2⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u+1} α (λ (x : α), @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α f)) (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α f)), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), and (@is_open.{u} α _inst_1 u) (@eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f))) u)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x : α,
H :
  @Exists.{u+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α f))
         (λ (H : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α f)),
            @Exists.{(max (u+1) 1)} (set.{u} α)
              (λ (u : set.{u} α),
                 and (@is_open.{u} α _inst_1 u)
                   (@eq.{u+1} (set.{u} α)
                      (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                      (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
                         (@set_of.{u} α
                            (λ (y : α),
                               @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y
                                 (@finset.univ.{u} α f)))
                         u)))))
⊢ @Exists.{u+1} α
    (λ (x : α),
       @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U)
⊢ @Exists.{u+1} α
    (λ (x : α),
       @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105    existsi y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U)
⊢ @Exists.{u+1} α
    (λ (x : α),
       @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U)
⊢ @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106    have h1 : {y : α | y ∈ finset.univ} = (univ : set α),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U)
⊢ @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='5 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U)
⊢ @eq.{(max (u+1) 1)} (set.{u} α)
    (@set_of.{u} α
       (λ (y : α), @has_mem.mem.{u ?l_1} α (finset.{?l_1} ?m_2[y]) ?m_3[y] y (@finset.univ.{?l_1} ?m_2[y] ?m_4[y])))
    (@set.univ.{u} α)

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U),
h1 :
  @eq.{(max (u+1) 1)} (set.{u} α)
    (@set_of.{u} α
       (λ (y : α), @has_mem.mem.{u ?l_1} α (finset.{?l_1} ?m_2[y]) ?m_3[y] y (@finset.univ.{?l_1} ?m_2[y] ?m_4[y])))
    (@set.univ.{u} α)
⊢ @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U),
y : α
⊢ Type ?l_1

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U),
y : α
⊢ has_mem.{u ?l_1} α (finset.{?l_1} ?m_2)

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U),
y : α
⊢ fintype.{?l_1} ?m_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107    { exact set.eq_univ_of_forall (λ x : α,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.eq_univ_of_forall'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 251, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, (∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s) → @eq.{(max (u+1) 1)} (set.{u} α) s (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='5 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U)
⊢ @eq.{(max (u+1) 1)} (set.{u} α)
    (@set_of.{u} α
       (λ (y : α), @has_mem.mem.{u ?l_1} α (finset.{?l_1} ?m_2[y]) ?m_3[y] y (@finset.univ.{?l_1} ?m_2[y] ?m_4[y])))
    (@set.univ.{u} α)

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U),
h1 :
  @eq.{(max (u+1) 1)} (set.{u} α)
    (@set_of.{u} α
       (λ (y : α), @has_mem.mem.{u ?l_1} α (finset.{?l_1} ?m_2[y]) ?m_3[y] y (@finset.univ.{?l_1} ?m_2[y] ?m_4[y])))
    (@set.univ.{u} α)
⊢ @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U),
y : α
⊢ Type ?l_1

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U),
y : α
⊢ has_mem.{u ?l_1} α (finset.{?l_1} ?m_2)

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U),
y : α
⊢ fintype.{?l_1} ?m_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U)
⊢ @eq.{(max (u+1) 1)} (set.{u} α)
    (@set_of.{u} α
       (λ (y : α), @has_mem.mem.{u ?l_1} α (finset.{?l_1} ?m_2[y]) ?m_3[y] y (@finset.univ.{?l_1} ?m_2[y] ?m_4[y])))
    (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108        by rw mem_set_of_eq; exact finset.mem_univ x) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='set.mem_set_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α} {p : α → Prop}, @eq.{1} Prop (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set_of.{u} α (λ (a : α), p a))) (p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α] (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U)
⊢ @eq.{(max (u+1) 1)} (set.{u} α)
    (@set_of.{u} α
       (λ (y : α), @has_mem.mem.{u ?l_1} α (finset.{?l_1} ?m_2[y]) ?m_3[y] y (@finset.univ.{?l_1} ?m_2[y] ?m_4[y])))
    (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U),
x : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set_of.{u} α
       (λ (y : α), @has_mem.mem.{u ?l_1} α (finset.{?l_1} ?m_2[y]) ?m_3[y] y (@finset.univ.{?l_1} ?m_2[y] ?m_4[y])))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U)
⊢ @eq.{(max (u+1) 1)} (set.{u} α)
    (@set_of.{u} α
       (λ (y : α), @has_mem.mem.{u ?l_1} α (finset.{?l_1} ?m_2[y]) ?m_3[y] y (@finset.univ.{?l_1} ?m_2[y] ?m_4[y])))
    (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U),
h1 :
  @eq.{(max (u+1) 1)} (set.{u} α)
    (@set_of.{u} α
       (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
    (@set.univ.{u} α)
⊢ @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109    rw h1 at hu2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u+1) 1)} (set.{u} α) (@set_of.{u} α (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f))) (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@set_of.{u} α
          (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
       U),
h1 :
  @eq.{(max (u+1) 1)} (set.{u} α)
    (@set_of.{u} α
       (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
    (@set.univ.{u} α)
⊢ @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
h1 :
  @eq.{(max (u+1) 1)} (set.{u} α)
    (@set_of.{u} α
       (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
    (@set.univ.{u} α),
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set.univ.{u} α) U)
⊢ @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110    rw set.univ_inter at hu2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.univ_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 399, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (a : set.{u} α), @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set.univ.{u} α) a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
h1 :
  @eq.{(max (u+1) 1)} (set.{u} α)
    (@set_of.{u} α
       (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
    (@set.univ.{u} α),
hu2 :
  @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@set.univ.{u} α) U)
⊢ @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
h1 :
  @eq.{(max (u+1) 1)} (set.{u} α)
    (@set_of.{u} α
       (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
    (@set.univ.{u} α),
hu2 : @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) U
⊢ @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111    rw hu2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hu2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
h1 :
  @eq.{(max (u+1) 1)} (set.{u} α)
    (@set_of.{u} α
       (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
    (@set.univ.{u} α),
hu2 : @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) U
⊢ @is_open.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
h1 :
  @eq.{(max (u+1) 1)} (set.{u} α)
    (@set_of.{u} α
       (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
    (@set.univ.{u} α),
hu2 : @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) U
⊢ @is_open.{u} α _inst_1 U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112    exact hu1</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hu1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u} α _inst_1 U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t0_space.{u} α _inst_1,
f : fintype.{u} α,
_inst_3 : decidable_eq.{u+1} α,
ha : nonempty.{u+1} α,
x y : α,
hyf : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f),
U : set.{u} α,
hu1 : @is_open.{u} α _inst_1 U,
h1 :
  @eq.{(max (u+1) 1)} (set.{u} α)
    (@set_of.{u} α
       (λ (y : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) y (@finset.univ.{u} α f)))
    (@set.univ.{u} α),
hu2 : @eq.{u+1} (set.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) U
⊢ @is_open.{u} α _inst_1 U'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  /-- A T₁ space, also known as a Fréchet space, is a topological space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116    where every singleton set is closed. Equivalently, for every pair</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117    `x ≠ y`, there is an open set containing `x` and not `y`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  class t1_space (α : Type u) [topological_space α] : Prop :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='topological_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  (t1 : ∀x, is_closed ({x} : set α))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A set is closed if its complement is open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  lemma is_closed_singleton [t1_space α] {x : α} : is_closed ({x} : set α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='t1_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A T₁ space, also known as a Fréchet space, is a topological space
 where every singleton set is closed. Equivalently, for every pair
 `x ≠ y`, there is an open set containing `x` and not `y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='A set is closed if its complement is open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  t1_space.t1 x</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='t1_space.t1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_2 : topological_space.{u} α] [c : @t1_space.{u} α _inst_2] (x : α), @is_closed.{u} α _inst_2 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  @[priority 100] -- see Note [lower instance priority]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  instance t1_space.t0_space [t1_space α] : t0_space α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='t1_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t0_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 22, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='A T₁ space, also known as a Fréchet space, is a topological space
 where every singleton set is closed. Equivalently, for every pair
 `x ≠ y`, there is an open set containing `x` and not `y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A T₀ space, also known as a Kolmogorov space, is a topological space
 where for every pair `x ≠ y`, there is an open set containing one but not the other.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  ⟨λ x y h, ⟨-{x}, is_open_compl_iff.2 is_closed_singleton,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_open_compl_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_closed_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 143, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} α}, iff (@is_open.{u} α _inst_1 (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)) (@is_closed.{u} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : @t1_space.{u} α _inst_1] {x : α}, @is_closed.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127    or.inr ⟨λ hyx, or.cases_on hyx h.symm id, λ hx, hx $ or.inl rfl⟩⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hyx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or.cases_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hyx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ne.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='or.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, b → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b C : Prop}, or a b → (a → C) → (b → C) → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : α}, @ne.{u+1} α a b → @ne.{u+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {a b : Prop}, a → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  lemma compl_singleton_mem_nhds [t1_space α] {x y : α} (h : y ≠ x) : - {x} ∈ 𝓝 y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='t1_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='A T₁ space, also known as a Fréchet space, is a topological space
 where every singleton set is closed. Equivalently, for every pair
 `x ≠ y`, there is an open set containing `x` and not `y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  mem_nhds_sets is_closed_singleton $ by rwa [mem_compl_eq, mem_singleton_iff]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='mem_nhds_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_closed_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='set.mem_compl_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_singleton_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 596, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 509, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α} {s : set.{u} α}, @is_open.{u} α _inst_1 s → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : @t1_space.{u} α _inst_1] {x : α}, @is_closed.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (s : set.{u} α) (x : α), @eq.{1} Prop (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)) (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : α}, iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) b)) (@eq.{u+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t1_space.{u} α _inst_1,
x y : α,
h : @ne.{u+1} α y x
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t1_space.{u} α _inst_1,
x y : α,
h : @ne.{u+1} α y x
⊢ not
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
       (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t1_space.{u} α _inst_1,
x y : α,
h : @ne.{u+1} α y x
⊢ not (@eq.{u+1} α y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t1_space.{u} α _inst_1,
x y : α,
h : @ne.{u+1} α y x
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t1_space.{u} α _inst_1,
x y : α,
h : @ne.{u+1} α y x
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  @[simp] lemma closure_singleton [t1_space α] {a : α} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='t1_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A T₁ space, also known as a Fréchet space, is a topological space
 where every singleton set is closed. Equivalently, for every pair
 `x ≠ y`, there is an open set containing `x` and not `y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133    closure ({a} : set α) = {a} :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  closure_eq_of_is_closed is_closed_singleton</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='closure_eq_of_is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_closed_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 256, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} α}, @is_closed.{u} α _inst_1 s → @eq.{(max (u+1) 1)} (set.{u} α) (@closure.{u} α _inst_1 s) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : @t1_space.{u} α _inst_1] {x : α}, @is_closed.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  /-- A T₂ space, also known as a Hausdorff space, is one in which for every</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137    `x ≠ y` there exists disjoint open sets around `x` and `y`. This is</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138    the most widely used of the separation axioms. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  class t2_space (α : Type u) [topological_space α] : Prop :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  (t2 : ∀x y, x ≠ y → ∃u v : set α, is_open u ∧ is_open v ∧ x ∈ u ∧ y ∈ v ∧ u ∩ v = ∅)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : has_emptyc.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  lemma t2_separation [t2_space α] {x y : α} (h : x ≠ y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143    ∃u v : set α, is_open u ∧ is_open v ∧ x ∈ u ∧ y ∈ v ∧ u ∩ v = ∅ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : has_emptyc.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  t2_space.t2 x y h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='t2_space.t2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_2 : topological_space.{u} α] [c : @t2_space.{u} α _inst_2] (x y : α), @ne.{u+1} α x y → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α _inst_2 u) (and (@is_open.{u} α _inst_2 v) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x u) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y v) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146  @[priority 100] -- see Note [lower instance priority]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147  instance t2_space.t1_space [t2_space α] : t1_space α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t1_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A T₁ space, also known as a Fréchet space, is a topological space
 where every singleton set is closed. Equivalently, for every pair
 `x ≠ y`, there is an open set containing `x` and not `y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  ⟨λ x, is_open_iff_forall_mem_open.2 $ λ y hxy,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open_iff_forall_mem_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 241, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α} [_inst_1 : topological_space.{u} α], iff (@is_open.{u} α _inst_1 s) (∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s → @Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s) (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s), and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  let ⟨u, v, hu, hv, hyu, hxv, huv⟩ := t2_separation (mt mem_singleton_of_eq hxy) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='hyu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hxv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='huv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='t2_separation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.mem_singleton_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;line&#x27;: 142, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α _inst_1 u) (and (@is_open.{u} α _inst_1 v) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y u) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x v) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))))) → @Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))) (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))), and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@is_open.{u} α _inst_1 u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : @t2_space.{u} α _inst_1] {x y : α}, @ne.{u+1} α x y → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α _inst_1 u) (and (@is_open.{u} α _inst_1 v) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x u) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y v) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, (a → b) → not b → not a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {x y : α}, @eq.{u+1} α x y → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  ⟨u, λ z hz1 hz2, ((ext_iff _ _).1 huv x).1 ⟨mem_singleton_iff.1 hz2 ▸ hz1, hxv⟩, hu, hyu⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hz1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hz2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.ext_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.mem_singleton_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hz2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hz1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 509, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} (s t : set.{u} α), iff (@eq.{(max (u+1) 1)} (set.{u} α) s t) (∀ (x : α), iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {a b : α}, iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) b)) (@eq.{u+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  lemma eq_of_nhds_ne_bot [ht : t2_space α] {x y : α} (h : 𝓝 x ⊓ 𝓝 y ≠ ⊥) : x = y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : lattice.has_inf.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : lattice.has_bot.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  classical.by_contradiction $ assume : x ≠ y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='classical.by_contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 160, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : Prop}, (not p → false) → p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  let ⟨u, v, hu, hv, hx, hy, huv⟩ := t2_space.t2 x y this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='huv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='t2_space.t2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α _inst_1 u) (and (@is_open.{u} α _inst_1 v) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x u) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y v) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))))) → false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u} α _inst_1 u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u} α _inst_1 v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} [_inst_2 : topological_space.{u} α] [c : @t2_space.{u} α _inst_2] (x y : α), @ne.{u+1} α x y → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α _inst_2 u) (and (@is_open.{u} α _inst_2 v) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x u) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y v) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  have u ∩ v ∈ 𝓝 x ⊓ 𝓝 y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : lattice.has_inf.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156    from inter_mem_inf_sets (mem_nhds_sets hu hx) (mem_nhds_sets hv hy),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter.inter_mem_inf_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mem_nhds_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='mem_nhds_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u} {f g : filter.{u} α} {s t : set.{u} α}, @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t g → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) f g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α} {s : set.{u} α}, @is_open.{u} α _inst_1 s → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α} {s : set.{u} α}, @is_open.{u} α _inst_1 s → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  h $ empty_in_sets_eq_bot.mp $ huv ▸ this</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.empty_in_sets_eq_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {f : filter.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) f) (@eq.{u+1} (filter.{u} α) f (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  lemma t2_iff_nhds : t2_space α ↔ ∀ {x y : α}, 𝓝 x ⊓ 𝓝 y ≠ ⊥ → x = y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : lattice.has_inf.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : lattice.has_bot.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  ⟨assume h, by exactI λ x y, eq_of_nhds_ne_bot,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='eq_of_nhds_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@t2_space.{u} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [ht : @t2_space.{u} α _inst_1] {x y : α}, @ne.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))) → @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
h : @t2_space.{u} α _inst_1
⊢ ∀ {x y : α},
    @ne.{u+1} (filter.{u} α)
      (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x)
         (@nhds.{u} α _inst_1 y))
      (@lattice.has_bot.bot.{u} (filter.{u} α)
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                  (@filter.lattice.complete_lattice.{u} α))))) →
    @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161   assume h, ⟨assume x y xy,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='xy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {x y : α}, @ne.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))) → @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162     have 𝓝 x ⊓ 𝓝 y = ⊥ := classical.by_contradiction (mt h xy),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='classical.by_contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='xy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 160, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : lattice.has_inf.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : lattice.has_bot.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {p : Prop}, (not p → false) → p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, (a → b) → not b → not a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {x y : α}, @ne.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))) → @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163     let ⟨u&#x27;, hu&#x27;, v&#x27;, hv&#x27;, u&#x27;v&#x27;⟩ := empty_in_sets_eq_bot.mpr this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='hu&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='hv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='u&#x27;v&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='filter.empty_in_sets_eq_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y)) → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α _inst_1 u) (and (@is_open.{u} α _inst_1 v) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x u) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y v) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) u&#x27; (@nhds.{u} α _inst_1 x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) v&#x27; (@nhds.{u} α _inst_1 y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u&#x27; v&#x27;) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {f : filter.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) f) (@eq.{u+1} (filter.{u} α) f (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164         ⟨u, uu&#x27;, uo, hu⟩ := mem_nhds_sets_iff.mp hu&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uu&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mem_nhds_sets_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 421, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) u u&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u} α _inst_1 u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α} {s : set.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a)) (@Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s) (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s), and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165         ⟨v, vv&#x27;, vo, hv⟩ := mem_nhds_sets_iff.mp hv&#x27; in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vv&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mem_nhds_sets_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 421, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) v v&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u} α _inst_1 v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α} {s : set.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a)) (@Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s) (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s), and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166     ⟨u, v, uo, vo, hu, hv, disjoint.eq_bot $ disjoint_mono uu&#x27; vv&#x27; u&#x27;v&#x27;⟩⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='disjoint.eq_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='disjoint_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 760, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 775, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.semilattice_inf_bot.{u} α] {a b : α}, @disjoint.{u} α _inst_1 a b → @eq.{u+1} α (@lattice.has_inf.inf.{u} α (@lattice.semilattice_inf.to_has_inf.{u} α (@lattice.semilattice_inf_bot.to_semilattice_inf.{u} α _inst_1)) a b) (@lattice.has_bot.bot.{u} α (@lattice.order_bot.to_has_bot.{u} α (@lattice.semilattice_inf_bot.to_order_bot.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.semilattice_inf_bot.{u} α] {a b c d : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.semilattice_inf_bot.to_order_bot.{u} α _inst_1)))) a b → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.semilattice_inf_bot.to_order_bot.{u} α _inst_1)))) c d → @disjoint.{u} α _inst_1 b d → @disjoint.{u} α _inst_1 a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  lemma t2_iff_ultrafilter :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169    t2_space α ↔ ∀ f {x y : α}, is_ultrafilter f → f ≤ 𝓝 x → f ≤ 𝓝 y → x = y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.is_ultrafilter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1919, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, filter.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_le.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_le.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An ultrafilter is a minimal (maximal in the set order) proper filter.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  t2_iff_nhds.trans</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='t2_iff_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 159, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 248, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α], iff (@t2_space.{u} α _inst_1) (∀ {x y : α}, @ne.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))) → @eq.{u+1} α x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b c : Prop}, iff a b → iff b c → iff a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171    ⟨assume h f x y u fx fy, h $ ne_bot_of_le_ne_bot u.1 (le_inf fx fy),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.ne_bot_of_le_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='and.left'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.le_inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {x y : α}, @ne.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))) → @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@filter.is_ultrafilter.{u} α f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@nhds.{u} α _inst_1 x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@nhds.{u} α _inst_1 y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {x y : α}, @ne.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))) → @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.order_bot.{u} α] {a b : α}, @ne.{u+1} α b (@lattice.has_bot.bot.{u} α (@lattice.order_bot.to_has_bot.{u} α _inst_1)) → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α _inst_1))) b a → @ne.{u+1} α a (@lattice.has_bot.bot.{u} α (@lattice.order_bot.to_has_bot.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@filter.is_ultrafilter.{u} α f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, and a b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.semilattice_inf.{u} α] {a b c : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.semilattice_inf.to_partial_order.{u} α _inst_1))) a b → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.semilattice_inf.to_partial_order.{u} α _inst_1))) a c → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.semilattice_inf.to_partial_order.{u} α _inst_1))) a (@lattice.has_inf.inf.{u} α (@lattice.semilattice_inf.to_has_inf.{u} α _inst_1) b c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@nhds.{u} α _inst_1 x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@nhds.{u} α _inst_1 y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172     assume h x y xy,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='xy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ (f : filter.{u} α) {x y : α}, @filter.is_ultrafilter.{u} α f → @has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@nhds.{u} α _inst_1 x) → @has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@nhds.{u} α _inst_1 y) → @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173       let ⟨f, hf, uf⟩ := exists_ultrafilter xy in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='filter.exists_ultrafilter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='xy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1991, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@Exists.{u+1} (filter.{u} α) (λ (u : filter.{u} α), and (@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) u (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y))) (@filter.is_ultrafilter.{u} α u)) → @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@filter.is_ultrafilter.{u} α f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {f : filter.{u} α}, @ne.{u+1} (filter.{u} α) f (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))) → @Exists.{u+1} (filter.{u} α) (λ (u : filter.{u} α), and (@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) u f) (@filter.is_ultrafilter.{u} α u))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The ultrafilter lemma: Any proper filter is contained in an ultrafilter.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174       h f uf (le_trans hf lattice.inf_le_left) (le_trans hf lattice.inf_le_right)⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lattice.inf_le_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lattice.inf_le_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 176, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ (f : filter.{u} α) {x y : α}, @filter.is_ultrafilter.{u} α f → @has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@nhds.{u} α _inst_1 x) → @has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@nhds.{u} α _inst_1 y) → @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] {a b c : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) a b → @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) b c → @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.semilattice_inf.{u} α] {a b : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.semilattice_inf.to_partial_order.{u} α _inst_1))) (@lattice.has_inf.inf.{u} α (@lattice.semilattice_inf.to_has_inf.{u} α _inst_1) a b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] {a b c : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) a b → @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) b c → @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.semilattice_inf.{u} α] {a b : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.semilattice_inf.to_partial_order.{u} α _inst_1))) (@lattice.has_inf.inf.{u} α (@lattice.semilattice_inf.to_has_inf.{u} α _inst_1) a b) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176  @[simp] lemma nhds_eq_nhds_iff {a b : α} [t2_space α] : 𝓝 a = 𝓝 b ↔ a = b :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177  ⟨assume h, eq_of_nhds_ne_bot $ by rw [h, inf_idem]; exact nhds_ne_bot, assume h, h ▸ rfl⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq_of_nhds_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.inf_idem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nhds_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 219, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 482, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@eq.{u+1} (filter.{u} α) (@nhds.{u} α _inst_1 a) (@nhds.{u} α _inst_1 b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [ht : @t2_space.{u} α _inst_1] {x y : α}, @ne.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))) → @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (filter.{u} α) (@nhds.{u} α _inst_1 a) (@nhds.{u} α _inst_1 b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.semilattice_inf.{u} α] {a : α}, @eq.{u+1} α (@lattice.has_inf.inf.{u} α (@lattice.semilattice_inf.to_has_inf.{u} α _inst_1) a a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α}, @ne.{u+1} (filter.{u} α) (@nhds.{u} α _inst_1 a) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@eq.{u+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{u+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
a b : α,
_inst_2 : @t2_space.{u} α _inst_1,
h : @eq.{u+1} (filter.{u} α) (@nhds.{u} α _inst_1 a) (@nhds.{u} α _inst_1 b)
⊢ @ne.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
       (@nhds.{u} α _inst_1 b))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
a b : α,
_inst_2 : @t2_space.{u} α _inst_1,
h : @eq.{u+1} (filter.{u} α) (@nhds.{u} α _inst_1 a) (@nhds.{u} α _inst_1 b)
⊢ @ne.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 b)
       (@nhds.{u} α _inst_1 b))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
a b : α,
_inst_2 : @t2_space.{u} α _inst_1,
h : @eq.{u+1} (filter.{u} α) (@nhds.{u} α _inst_1 a) (@nhds.{u} α _inst_1 b)
⊢ @ne.{u+1} (filter.{u} α) (@nhds.{u} α _inst_1 b)
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
a b : α,
_inst_2 : @t2_space.{u} α _inst_1,
h : @eq.{u+1} (filter.{u} α) (@nhds.{u} α _inst_1 a) (@nhds.{u} α _inst_1 b)
⊢ @ne.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
       (@nhds.{u} α _inst_1 b))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179  @[simp] lemma nhds_le_nhds_iff {a b : α} [t2_space α] : 𝓝 a ≤ 𝓝 b ↔ a = b :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_le.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180  ⟨assume h, eq_of_nhds_ne_bot $ by rw [inf_of_le_left h]; exact nhds_ne_bot, assume h, h ▸ le_refl _⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq_of_nhds_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='lattice.inf_of_le_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nhds_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 482, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) (@nhds.{u} α _inst_1 a) (@nhds.{u} α _inst_1 b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [ht : @t2_space.{u} α _inst_1] {x y : α}, @ne.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))) → @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.semilattice_inf.{u} α] {a b : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.semilattice_inf.to_partial_order.{u} α _inst_1))) a b → @eq.{u+1} α (@lattice.has_inf.inf.{u} α (@lattice.semilattice_inf.to_has_inf.{u} α _inst_1) a b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) (@nhds.{u} α _inst_1 a) (@nhds.{u} α _inst_1 b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α}, @ne.{u+1} (filter.{u} α) (@nhds.{u} α _inst_1 a) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@eq.{u+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{u+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
a b : α,
_inst_2 : @t2_space.{u} α _inst_1,
h :
  @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
    (@nhds.{u} α _inst_1 a)
    (@nhds.{u} α _inst_1 b)
⊢ @ne.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
       (@nhds.{u} α _inst_1 b))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
a b : α,
_inst_2 : @t2_space.{u} α _inst_1,
h :
  @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
    (@nhds.{u} α _inst_1 a)
    (@nhds.{u} α _inst_1 b)
⊢ @ne.{u+1} (filter.{u} α) (@nhds.{u} α _inst_1 a)
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
a b : α,
_inst_2 : @t2_space.{u} α _inst_1,
h :
  @has_le.le.{u} (filter.{u} α)
    (@preorder.to_has_le.{u} (filter.{u} α)
       (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))
    (@nhds.{u} α _inst_1 a)
    (@nhds.{u} α _inst_1 b)
⊢ @ne.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
       (@nhds.{u} α _inst_1 b))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182  lemma tendsto_nhds_unique [t2_space α] {f : β → α} {l : filter β} {a b : α}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183    (hl : l ≠ ⊥) (ha : tendsto f l (𝓝 a)) (hb : tendsto f l (𝓝 b)) : a = b :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='filter.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type v) [c : lattice.has_bot.{v} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184  eq_of_nhds_ne_bot $ ne_bot_of_le_ne_bot (map_ne_bot hl) $ le_inf ha hb</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='eq_of_nhds_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.ne_bot_of_le_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.map_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lattice.le_inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1070, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [ht : @t2_space.{u} α _inst_1] {x y : α}, @ne.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))) → @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.order_bot.{u} α] {a b : α}, @ne.{u+1} α b (@lattice.has_bot.bot.{u} α (@lattice.order_bot.to_has_bot.{u} α _inst_1)) → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α _inst_1))) b a → @ne.{u+1} α a (@lattice.has_bot.bot.{u} α (@lattice.order_bot.to_has_bot.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type v} {β : Type u} {f : filter.{v} α} {m : α → β}, @ne.{v+1} (filter.{v} α) f (@lattice.has_bot.bot.{v} (filter.{v} α) (@lattice.order_bot.to_has_bot.{v} (filter.{v} α) (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} α) (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} α) (@filter.lattice.complete_lattice.{v} α))))) → @ne.{u+1} (filter.{u} β) (@filter.map.{v u} α β m f) (@lattice.has_bot.bot.{u} (filter.{u} β) (@lattice.order_bot.to_has_bot.{u} (filter.{u} β) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} β) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} β) (@filter.lattice.complete_lattice.{u} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{v+1} (filter.{v} β) l (@lattice.has_bot.bot.{v} (filter.{v} β) (@lattice.order_bot.to_has_bot.{v} (filter.{v} β) (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β) (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.semilattice_inf.{u} α] {a b c : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.semilattice_inf.to_partial_order.{u} α _inst_1))) a b → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.semilattice_inf.to_partial_order.{u} α _inst_1))) a c → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.semilattice_inf.to_partial_order.{u} α _inst_1))) a (@lattice.has_inf.inf.{u} α (@lattice.semilattice_inf.to_has_inf.{u} α _inst_1) b c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@filter.tendsto.{v u} β α f l (@nhds.{u} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@filter.tendsto.{v u} β α f l (@nhds.{u} α _inst_1 b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  section lim</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187  variables [inhabited α] [t2_space α] {f : filter α}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189  lemma lim_eq {a : α} (hf : f ≠ ⊥) (h : f ≤ 𝓝 a) : lim f = a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 585, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : lattice.has_bot.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_le.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : inhabited.{u+1} α], filter.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='If `f` is a filter, then `lim f` is a limit of the filter, if it exists.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190  eq_of_nhds_ne_bot $ ne_bot_of_le_ne_bot hf $ le_inf (lim_spec ⟨_, h⟩) h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='eq_of_nhds_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.ne_bot_of_le_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.le_inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lim_spec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 587, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [ht : @t2_space.{u} α _inst_1] {x y : α}, @ne.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))) → @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.order_bot.{u} α] {a b : α}, @ne.{u+1} α b (@lattice.has_bot.bot.{u} α (@lattice.order_bot.to_has_bot.{u} α _inst_1)) → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α _inst_1))) b a → @ne.{u+1} α a (@lattice.has_bot.bot.{u} α (@lattice.order_bot.to_has_bot.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u+1} (filter.{u} α) f (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.semilattice_inf.{u} α] {a b c : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.semilattice_inf.to_partial_order.{u} α _inst_1))) a b → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.semilattice_inf.to_partial_order.{u} α _inst_1))) a c → @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.semilattice_inf.to_partial_order.{u} α _inst_1))) a (@lattice.has_inf.inf.{u} α (@lattice.semilattice_inf.to_has_inf.{u} α _inst_1) b c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : inhabited.{u+1} α] {f : filter.{u} α}, @Exists.{u+1} α (λ (a : α), @has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@nhds.{u} α _inst_1 a)) → @has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@nhds.{u} α _inst_1 (@lim.{u} α _inst_1 _inst_2 f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@nhds.{u} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@nhds.{u} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  @[simp] lemma lim_nhds_eq {a : α} : lim (𝓝 a) = a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 585, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : inhabited.{u+1} α], filter.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='If `f` is a filter, then `lim f` is a limit of the filter, if it exists.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193  lim_eq nhds_ne_bot (le_refl _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lim_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 189, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 482, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : inhabited.{u+1} α] [_inst_3 : @t2_space.{u} α _inst_1] {f : filter.{u} α} {a : α}, @ne.{u+1} (filter.{u} α) f (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))) → @has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@nhds.{u} α _inst_1 a) → @eq.{u+1} α (@lim.{u} α _inst_1 _inst_2 f) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α}, @ne.{u+1} (filter.{u} α) (@nhds.{u} α _inst_1 a) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195  @[simp] lemma lim_nhds_eq_of_closure {a : α} {s : set α} (h : a ∈ closure s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196    lim (𝓝 a ⊓ principal s) = a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 585, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : inhabited.{u+1} α], filter.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : lattice.has_inf.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If `f` is a filter, then `lim f` is a limit of the filter, if it exists.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  lim_eq begin rw [closure_eq_nhds] at h, exact h end inf_le_left</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lim_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='closure_eq_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='lattice.inf_le_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 189, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 499, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : inhabited.{u+1} α] [_inst_3 : @t2_space.{u} α _inst_1] {f : filter.{u} α} {a : α}, @ne.{u+1} (filter.{u} α) f (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))) → @has_le.le.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α))) f (@nhds.{u} α _inst_1 a) → @eq.{u+1} α (@lim.{u} α _inst_1 _inst_2 f) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} α}, @eq.{(max (u+1) 1)} (set.{u} α) (@closure.{u} α _inst_1 s) (@set_of.{u} α (λ (a : α), @ne.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a) (@filter.principal.{u} α s)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set_of.{u} α (λ (a : α), @ne.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a) (@filter.principal.{u} α s)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.semilattice_inf.{u} α] {a b : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.semilattice_inf.to_partial_order.{u} α _inst_1))) (@lattice.has_inf.inf.{u} α (@lattice.semilattice_inf.to_has_inf.{u} α _inst_1) a b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : inhabited.{u+1} α,
_inst_3 : @t2_space.{u} α _inst_1,
a : α,
s : set.{u} α,
h : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@closure.{u} α _inst_1 s)
⊢ @ne.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
       (@filter.principal.{u} α s))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : inhabited.{u+1} α,
_inst_3 : @t2_space.{u} α _inst_1,
a : α,
s : set.{u} α,
h :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@set_of.{u} α
       (λ (a : α),
          @ne.{u+1} (filter.{u} α)
            (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
               (@filter.principal.{u} α s))
            (@lattice.has_bot.bot.{u} (filter.{u} α)
               (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
                  (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                     (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                        (@filter.lattice.complete_lattice.{u} α)))))))
⊢ @ne.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
       (@filter.principal.{u} α s))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : inhabited.{u+1} α,
_inst_3 : @t2_space.{u} α _inst_1,
a : α,
s : set.{u} α,
h : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@closure.{u} α _inst_1 s)
⊢ @ne.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
       (@filter.principal.{u} α s))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : inhabited.{u+1} α,
_inst_3 : @t2_space.{u} α _inst_1,
a : α,
s : set.{u} α,
h :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@set_of.{u} α
       (λ (a : α),
          @ne.{u+1} (filter.{u} α)
            (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
               (@filter.principal.{u} α s))
            (@lattice.has_bot.bot.{u} (filter.{u} α)
               (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
                  (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                     (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                        (@filter.lattice.complete_lattice.{u} α)))))))
⊢ @ne.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
       (@filter.principal.{u} α s))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  end lim</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200  @[priority 100] -- see Note [lower instance priority]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201  instance t2_space_discrete {α : Type*} [topological_space α] [discrete_topology α] : t2_space α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='discrete_topology'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 194, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [t : topological_space.{u_1} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A topological space is discrete if every set is open, that is,
 its topology equals the discrete topology `⊥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202  { t2 := assume x y hxy, ⟨{x}, {y}, is_open_discrete _, is_open_discrete _, mem_insert _ _, mem_insert _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_open_discrete'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_open_discrete'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.mem_insert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.mem_insert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 197, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 197, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 448, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 448, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α γ : Type u_1} [_inst_1 : has_emptyc.{u_1} γ] [_inst_2 : has_insert.{u_1 u_1} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α γ : Type u_1} [_inst_1 : has_emptyc.{u_1} γ] [_inst_2 : has_insert.{u_1 u_1} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : @discrete_topology.{u} α _inst_1] (s : set.{u} α), @is_open.{u} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : @discrete_topology.{u} α _inst_1] (s : set.{u} α), @is_open.{u} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} (x : α) (s : set.{u} α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@insert.{u u} α (set.{u} α) (@set.has_insert.{u} α) x s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u} (x : α) (s : set.{u} α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@insert.{u u} α (set.{u} α) (@set.has_insert.{u} α) x s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203    eq_empty_iff_forall_not_mem.2 $ by intros z hz;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.eq_empty_iff_forall_not_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 197, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, iff (@eq.{(max (u+1) 1)} (set.{u} α) s (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))) (∀ (x : α), not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='lime'><a title='α : Type ?l_1,
_inst_2 : topological_space.{?l_1} α,
_inst_3 : @discrete_topology.{?l_1} α _inst_2,
x y : α,
hxy : @ne.{?l_1+1} α x y
⊢ ∀ (x_1 : α),
    not
      (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x_1
         (@set.inter.{?l_1} α
            (@singleton.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_emptyc.{?l_1} α) (@set.has_insert.{?l_1} α) x)
            (@singleton.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_emptyc.{?l_1} α) (@set.has_insert.{?l_1} α) y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204      cases eq_of_mem_singleton hz.1; cases eq_of_mem_singleton hz.2; cc⟩ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.eq_of_mem_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.eq_of_mem_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 518, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 518, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1300, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {x y : α}, @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) y) → @eq.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z (@set.inter.{u_1} α (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) x) (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {x y : α}, @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) y) → @eq.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@set.inter.{u_1} α (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) x) (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Tries to prove the main goal using congruence closure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type ?l_1,
_inst_2 : topological_space.{?l_1} α,
_inst_3 : @discrete_topology.{?l_1} α _inst_2,
x y : α,
hxy : @ne.{?l_1+1} α x y
⊢ ∀ (x_1 : α),
    not
      (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x_1
         (@set.inter.{?l_1} α
            (@singleton.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_emptyc.{?l_1} α) (@set.has_insert.{?l_1} α) x)
            (@singleton.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_emptyc.{?l_1} α) (@set.has_insert.{?l_1} α) y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206  private lemma separated_by_f {α : Type*} {β : Type*}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207    [tα : topological_space α] [tβ : topological_space β] [t2_space β]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_2) [_inst_2 : topological_space.{u_2} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208    (f : α → β) (hf : tα ≤ tβ.induced f) {x y : α} (h : f x ≠ f y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='tα'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='tβ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='topological_space.induced'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 236, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='topological_space.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_le.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='topological_space.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → topological_space.{u_2} β → topological_space.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='Given `f : α → β` and a topology on `β`, the induced topology on `α` is the collection of
 sets that are preimages of some open set in `β`. This is the coarsest topology that
 makes `f` continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209    ∃u v : set α, is_open u ∧ is_open v ∧ x ∈ u ∧ y ∈ v ∧ u ∩ v = ∅ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_inter.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [c : has_emptyc.{u_1} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210  let ⟨u, v, uo, vo, xu, yv, uv⟩ := t2_separation h in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='yv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='t2_separation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;line&#x27;: 142, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max (u_2+1) 1)} (set.{u_2} β) (λ (u : set.{u_2} β), @Exists.{(max (u_2+1) 1)} (set.{u_2} β) (λ (v : set.{u_2} β), and (@is_open.{u_2} β tβ u) (and (@is_open.{u_2} β tβ v) (and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f x) u) (and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f y) v) (@eq.{u_2+1} (set.{u_2} β) (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) u v) (@has_emptyc.emptyc.{u_2} (set.{u_2} β) (@set.has_emptyc.{u_2} β)))))))) → @Exists.{(max (u_1+1) 1)} (set.{u_1} α) (λ (u : set.{u_1} α), @Exists.{(max (u_1+1) 1)} (set.{u_1} α) (λ (v : set.{u_1} α), and (@is_open.{u_1} α tα u) (and (@is_open.{u_1} α tα v) (and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x u) (and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y v) (@eq.{u_1+1} (set.{u_1} α) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) u v) (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u_2} β tβ u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u_2} β tβ v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f x) u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f y) v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] [_inst_2 : @t2_space.{u_2} α _inst_1] {x y : α}, @ne.{u_2+1} α x y → @Exists.{(max (u_2+1) 1)} (set.{u_2} α) (λ (u : set.{u_2} α), @Exists.{(max (u_2+1) 1)} (set.{u_2} α) (λ (v : set.{u_2} α), and (@is_open.{u_2} α _inst_1 u) (and (@is_open.{u_2} α _inst_1 v) (and (@has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) x u) (and (@has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) y v) (@eq.{u_2+1} (set.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) u v) (@has_emptyc.emptyc.{u_2} (set.{u_2} α) (@set.has_emptyc.{u_2} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u_2+1} β (f x) (f y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211  ⟨f ⁻¹&#x27; u, f ⁻¹&#x27; v, hf _ ⟨u, uo, rfl⟩, hf _ ⟨v, vo, rfl⟩, xu, yv,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → set.{u_2} β → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → set.{u_2} β → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_le.le.{u_1} (topological_space.{u_1} α) (@preorder.to_has_le.{u_1} (topological_space.{u_1} α) (@partial_order.to_preorder.{u_1} (topological_space.{u_1} α) (@topological_space.partial_order.{u_1} α))) tα (@topological_space.induced.{u_1 u_2} α β f tβ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{(max (u_1+1) 1)} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_le.le.{u_1} (topological_space.{u_1} α) (@preorder.to_has_le.{u_1} (topological_space.{u_1} α) (@partial_order.to_preorder.{u_1} (topological_space.{u_1} α) (@topological_space.partial_order.{u_1} α))) tα (@topological_space.induced.{u_1 u_2} α β f tβ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{(max (u_1+1) 1)} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212    by rw [←preimage_inter, uv, preimage_empty]⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.preimage_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.preimage_empty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 847, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 836, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s t : set.{u_2} β}, @eq.{(max (u_1+1) 1)} (set.{u_1} α) (@set.preimage.{u_1 u_2} α β f (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) s t)) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) (@set.preimage.{u_1 u_2} α β f s) (@set.preimage.{u_1 u_2} α β f t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_2+1} (set.{u_2} β) (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) u v) (@has_emptyc.emptyc.{u_2} (set.{u_2} β) (@set.has_emptyc.{u_2} β))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {f : α → β}, @eq.{(max (u_1+1) 1)} (set.{u_1} α) (@set.preimage.{u_1 u_2} α β f (@has_emptyc.emptyc.{u_2} (set.{u_2} β) (@set.has_emptyc.{u_2} β))) (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
tα : topological_space.{u_1} α,
tβ : topological_space.{u_2} β,
_inst_2 : @t2_space.{u_2} β tβ,
f : α → β,
hf :
  @has_le.le.{u_1} (topological_space.{u_1} α)
    (@preorder.to_has_le.{u_1} (topological_space.{u_1} α)
       (@partial_order.to_preorder.{u_1} (topological_space.{u_1} α) (@topological_space.partial_order.{u_1} α)))
    tα
    (@topological_space.induced.{u_1 u_2} α β f tβ),
x y : α,
h : @ne.{u_2+1} β (f x) (f y),
_let_match :
  @Exists.{(max (u_2+1) 1)} (set.{u_2} β)
    (λ (u : set.{u_2} β),
       @Exists.{(max (u_2+1) 1)} (set.{u_2} β)
         (λ (v : set.{u_2} β),
            and (@is_open.{u_2} β tβ u)
              (and (@is_open.{u_2} β tβ v)
                 (and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f x) u)
                    (and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f y) v)
                       (@eq.{u_2+1} (set.{u_2} β) (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) u v)
                          (@has_emptyc.emptyc.{u_2} (set.{u_2} β) (@set.has_emptyc.{u_2} β)))))))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} α)
    (λ (u : set.{u_1} α),
       @Exists.{(max (u_1+1) 1)} (set.{u_1} α)
         (λ (v : set.{u_1} α),
            and (@is_open.{u_1} α tα u)
              (and (@is_open.{u_1} α tα v)
                 (and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x u)
                    (and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y v)
                       (@eq.{u_1+1} (set.{u_1} α) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) u v)
                          (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α)))))))),
u v : set.{u_2} β,
uo : @is_open.{u_2} β tβ u,
vo : @is_open.{u_2} β tβ v,
xu : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f x) u,
yv : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f y) v,
uv :
  @eq.{u_2+1} (set.{u_2} β) (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) u v)
    (@has_emptyc.emptyc.{u_2} (set.{u_2} β) (@set.has_emptyc.{u_2} β))
⊢ @eq.{u_1+1} (set.{u_1} α)
    (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) (@set.preimage.{u_1 u_2} α β f u)
       (@set.preimage.{u_1 u_2} α β f v))
    (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
tα : topological_space.{u_1} α,
tβ : topological_space.{u_2} β,
_inst_2 : @t2_space.{u_2} β tβ,
f : α → β,
hf :
  @has_le.le.{u_1} (topological_space.{u_1} α)
    (@preorder.to_has_le.{u_1} (topological_space.{u_1} α)
       (@partial_order.to_preorder.{u_1} (topological_space.{u_1} α) (@topological_space.partial_order.{u_1} α)))
    tα
    (@topological_space.induced.{u_1 u_2} α β f tβ),
x y : α,
h : @ne.{u_2+1} β (f x) (f y),
_let_match :
  @Exists.{(max (u_2+1) 1)} (set.{u_2} β)
    (λ (u : set.{u_2} β),
       @Exists.{(max (u_2+1) 1)} (set.{u_2} β)
         (λ (v : set.{u_2} β),
            and (@is_open.{u_2} β tβ u)
              (and (@is_open.{u_2} β tβ v)
                 (and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f x) u)
                    (and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f y) v)
                       (@eq.{u_2+1} (set.{u_2} β) (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) u v)
                          (@has_emptyc.emptyc.{u_2} (set.{u_2} β) (@set.has_emptyc.{u_2} β)))))))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} α)
    (λ (u : set.{u_1} α),
       @Exists.{(max (u_1+1) 1)} (set.{u_1} α)
         (λ (v : set.{u_1} α),
            and (@is_open.{u_1} α tα u)
              (and (@is_open.{u_1} α tα v)
                 (and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x u)
                    (and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y v)
                       (@eq.{u_1+1} (set.{u_1} α) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) u v)
                          (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α)))))))),
u v : set.{u_2} β,
uo : @is_open.{u_2} β tβ u,
vo : @is_open.{u_2} β tβ v,
xu : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f x) u,
yv : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f y) v,
uv :
  @eq.{u_2+1} (set.{u_2} β) (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) u v)
    (@has_emptyc.emptyc.{u_2} (set.{u_2} β) (@set.has_emptyc.{u_2} β))
⊢ @eq.{u_1+1} (set.{u_1} α)
    (@set.preimage.{u_1 u_2} α β f (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) u v))
    (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
tα : topological_space.{u_1} α,
tβ : topological_space.{u_2} β,
_inst_2 : @t2_space.{u_2} β tβ,
f : α → β,
hf :
  @has_le.le.{u_1} (topological_space.{u_1} α)
    (@preorder.to_has_le.{u_1} (topological_space.{u_1} α)
       (@partial_order.to_preorder.{u_1} (topological_space.{u_1} α) (@topological_space.partial_order.{u_1} α)))
    tα
    (@topological_space.induced.{u_1 u_2} α β f tβ),
x y : α,
h : @ne.{u_2+1} β (f x) (f y),
_let_match :
  @Exists.{(max (u_2+1) 1)} (set.{u_2} β)
    (λ (u : set.{u_2} β),
       @Exists.{(max (u_2+1) 1)} (set.{u_2} β)
         (λ (v : set.{u_2} β),
            and (@is_open.{u_2} β tβ u)
              (and (@is_open.{u_2} β tβ v)
                 (and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f x) u)
                    (and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f y) v)
                       (@eq.{u_2+1} (set.{u_2} β) (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) u v)
                          (@has_emptyc.emptyc.{u_2} (set.{u_2} β) (@set.has_emptyc.{u_2} β)))))))) →
  @Exists.{(max (u_1+1) 1)} (set.{u_1} α)
    (λ (u : set.{u_1} α),
       @Exists.{(max (u_1+1) 1)} (set.{u_1} α)
         (λ (v : set.{u_1} α),
            and (@is_open.{u_1} α tα u)
              (and (@is_open.{u_1} α tα v)
                 (and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x u)
                    (and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y v)
                       (@eq.{u_1+1} (set.{u_1} α) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) u v)
                          (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α)))))))),
u v : set.{u_2} β,
uo : @is_open.{u_2} β tβ u,
vo : @is_open.{u_2} β tβ v,
xu : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f x) u,
yv : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f y) v,
uv :
  @eq.{u_2+1} (set.{u_2} β) (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) u v)
    (@has_emptyc.emptyc.{u_2} (set.{u_2} β) (@set.has_emptyc.{u_2} β))
⊢ @eq.{u_1+1} (set.{u_1} α)
    (@set.preimage.{u_1 u_2} α β f (@has_emptyc.emptyc.{u_2} (set.{u_2} β) (@set.has_emptyc.{u_2} β)))
    (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214  instance {α : Type*} {p : α → Prop} [t : topological_space α] [t2_space α] : t2_space (subtype p) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_2 : topological_space.{u_1} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, (α → Prop) → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215  ⟨assume x y h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@subtype.{u_1+1} α p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{u_1+1} α p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u_1+1} (@subtype.{u_1+1} α p) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216    separated_by_f subtype.val (le_refl _) (mt subtype.eq h)⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_private.2771443467.separated_by_f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype.eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 206, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/subtype/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [tα : topological_space.{u_1} α] [tβ : topological_space.{u_2} β] [_inst_2 : @t2_space.{u_2} β tβ] (f : α → β), @has_le.le.{u_1} (topological_space.{u_1} α) (@preorder.to_has_le.{u_1} (topological_space.{u_1} α) (@partial_order.to_preorder.{u_1} (topological_space.{u_1} α) (@topological_space.partial_order.{u_1} α))) tα (@topological_space.induced.{u_1 u_2} α β f tβ) → ∀ {x y : α}, @ne.{u_2+1} β (f x) (f y) → @Exists.{(max (u_1+1) 1)} (set.{u_1} α) (λ (u : set.{u_1} α), @Exists.{(max (u_1+1) 1)} (set.{u_1} α) (λ (v : set.{u_1} α), and (@is_open.{u_1} α tα u) (and (@is_open.{u_1} α tα v) (and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x u) (and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y v) (@eq.{u_1+1} (set.{u_1} α) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) u v) (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u} {p : α → Prop}, @subtype.{u} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] (a : α), @has_le.le.{u} α (@preorder.to_has_le.{u} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {a b : Prop}, (a → b) → not b → not a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} {a1 a2 : @subtype.{u+1} α (λ (x : α), p x)}, @eq.{u+1} α (@subtype.val.{u+1} α (λ (x : α), p x) a1) (@subtype.val.{u+1} α (λ (x : α), p x) a2) → @eq.{(max 1 (u+1))} (@subtype.{u+1} α (λ (x : α), p x)) a1 a2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u_1+1} (@subtype.{u_1+1} α p) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218  instance {α : Type*} {β : Type*} [t₁ : topological_space α] [t2_space α]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_2 : topological_space.{u_1} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219    [t₂ : topological_space β] [t2_space β] : t2_space (α × β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_2) [_inst_2 : topological_space.{u_2} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2 → Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220  ⟨assume ⟨x₁,x₂⟩ ⟨y₁,y₂⟩ h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='prod.{u_1 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='prod.{u_1 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@ne.{(max u_1 u_2)+1} (prod.{u_1 u_2} α β) (@prod.mk.{u_1 u_2} α β x₁ x₂) (@prod.mk.{u_1 u_2} α β y₁ y₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221    or.elim (not_and_distrib.mp (mt prod.ext_iff.mpr h))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not_and_distrib'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.ext_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 202, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 355, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/prod.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b c : Prop}, or a b → (a → c) → (b → c) → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop} [_inst_1 : decidable a], iff (not (and a b)) (or (not a) (not b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, (a → b) → not b → not a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {p q : prod.{u_1 u_2} α β}, iff (@eq.{(max (u_1+1) (u_2+1))} (prod.{u_1 u_2} α β) p q) (and (@eq.{u_1+1} α (@prod.fst.{u_1 u_2} α β p) (@prod.fst.{u_1 u_2} α β q)) (@eq.{u_2+1} β (@prod.snd.{u_1 u_2} α β p) (@prod.snd.{u_1 u_2} α β q)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{(max u_1 u_2)+1} (prod.{u_1 u_2} α β) (@prod.mk.{u_1 u_2} α β x₁ x₂) (@prod.mk.{u_1 u_2} α β y₁ y₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222      (λ h₁, separated_by_f prod.fst inf_le_left h₁)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_private.2771443467.separated_by_f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.inf_le_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 206, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='not (@eq.{u_1+1} α (@prod.fst.{u_1 u_2} α β (@prod.mk.{u_1 u_2} α β x₁ x₂)) (@prod.fst.{u_1 u_2} α β (@prod.mk.{u_1 u_2} α β y₁ y₂)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [tα : topological_space.{u_1} α] [tβ : topological_space.{u_2} β] [_inst_2 : @t2_space.{u_2} β tβ] (f : α → β), @has_le.le.{u_1} (topological_space.{u_1} α) (@preorder.to_has_le.{u_1} (topological_space.{u_1} α) (@partial_order.to_preorder.{u_1} (topological_space.{u_1} α) (@topological_space.partial_order.{u_1} α))) tα (@topological_space.induced.{u_1 u_2} α β f tβ) → ∀ {x y : α}, @ne.{u_2+1} β (f x) (f y) → @Exists.{(max (u_1+1) 1)} (set.{u_1} α) (λ (u : set.{u_1} α), @Exists.{(max (u_1+1) 1)} (set.{u_1} α) (λ (v : set.{u_1} α), and (@is_open.{u_1} α tα u) (and (@is_open.{u_1} α tα v) (and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x u) (and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y v) (@eq.{u_1+1} (set.{u_1} α) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) u v) (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, prod.{u v} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.semilattice_inf.{u} α] {a b : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.semilattice_inf.to_partial_order.{u} α _inst_1))) (@lattice.has_inf.inf.{u} α (@lattice.semilattice_inf.to_has_inf.{u} α _inst_1) a b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@eq.{u_1+1} α (@prod.fst.{u_1 u_2} α β (@prod.mk.{u_1 u_2} α β x₁ x₂)) (@prod.fst.{u_1 u_2} α β (@prod.mk.{u_1 u_2} α β y₁ y₂)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223      (λ h₂, separated_by_f prod.snd inf_le_right h₂)⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_private.2771443467.separated_by_f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.inf_le_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 206, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 176, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='not (@eq.{u_2+1} β (@prod.snd.{u_1 u_2} α β (@prod.mk.{u_1 u_2} α β x₁ x₂)) (@prod.snd.{u_1 u_2} α β (@prod.mk.{u_1 u_2} α β y₁ y₂)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [tα : topological_space.{u_1} α] [tβ : topological_space.{u_2} β] [_inst_2 : @t2_space.{u_2} β tβ] (f : α → β), @has_le.le.{u_1} (topological_space.{u_1} α) (@preorder.to_has_le.{u_1} (topological_space.{u_1} α) (@partial_order.to_preorder.{u_1} (topological_space.{u_1} α) (@topological_space.partial_order.{u_1} α))) tα (@topological_space.induced.{u_1 u_2} α β f tβ) → ∀ {x y : α}, @ne.{u_2+1} β (f x) (f y) → @Exists.{(max (u_1+1) 1)} (set.{u_1} α) (λ (u : set.{u_1} α), @Exists.{(max (u_1+1) 1)} (set.{u_1} α) (λ (v : set.{u_1} α), and (@is_open.{u_1} α tα u) (and (@is_open.{u_1} α tα v) (and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x u) (and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y v) (@eq.{u_1+1} (set.{u_1} α) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) u v) (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, prod.{u v} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.semilattice_inf.{u} α] {a b : α}, @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.semilattice_inf.to_partial_order.{u} α _inst_1))) (@lattice.has_inf.inf.{u} α (@lattice.semilattice_inf.to_has_inf.{u} α _inst_1) a b) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@eq.{u_2+1} β (@prod.snd.{u_1 u_2} α β (@prod.mk.{u_1 u_2} α β x₁ x₂)) (@prod.snd.{u_1 u_2} α β (@prod.mk.{u_1 u_2} α β y₁ y₂)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225  instance Pi.t2_space {α : Type*} {β : α → Type v} [t₂ : Πa, topological_space (β a)] [Πa, t2_space (β a)] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226    t2_space (Πa, β a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  ⟨assume x y h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (a : α), β a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (a : α), β a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{(max u_1 v)+1} (Π (a : α), β a) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228    let ⟨i, hi⟩ := not_forall.mp (mt funext h) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='not_forall'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 453, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/funext.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{u_1+1} α (λ (x_1 : α), not (@eq.{v+1} (β x_1) (x x_1) (y x_1))) → @Exists.{(max ((max u_1 v)+1) 1)} (set.{(max u_1 v)} (Π (a : α), β a)) (λ (u : set.{(max u_1 v)} (Π (a : α), β a)), @Exists.{(max ((max u_1 v)+1) 1)} (set.{(max u_1 v)} (Π (a : α), β a)) (λ (v : set.{(max u_1 v)} (Π (a : α), β a)), and (@is_open.{(max u_1 v)} (Π (a : α), β a) (@Pi.topological_space.{u_1 v} α (λ (a : α), β a) (λ (a : α), t₂ a)) u) (and (@is_open.{(max u_1 v)} (Π (a : α), β a) (@Pi.topological_space.{u_1 v} α (λ (a : α), β a) (λ (a : α), t₂ a)) v) (and (@has_mem.mem.{(max u_1 v) (max u_1 v)} (Π (a : α), β a) (set.{(max u_1 v)} (Π (a : α), β a)) (@set.has_mem.{(max u_1 v)} (Π (a : α), β a)) x u) (and (@has_mem.mem.{(max u_1 v) (max u_1 v)} (Π (a : α), β a) (set.{(max u_1 v)} (Π (a : α), β a)) (@set.has_mem.{(max u_1 v)} (Π (a : α), β a)) y v) (@eq.{(max u_1 v)+1} (set.{(max u_1 v)} (Π (a : α), β a)) (@has_inter.inter.{(max u_1 v)} (set.{(max u_1 v)} (Π (a : α), β a)) (@set.has_inter.{(max u_1 v)} (Π (a : α), β a)) u v) (@has_emptyc.emptyc.{(max u_1 v)} (set.{(max u_1 v)} (Π (a : α), β a)) (@set.has_emptyc.{(max u_1 v)} (Π (a : α), β a)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='not (@eq.{v+1} (β i) (x i) (y i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} [_inst_1 : decidable (@Exists.{u_1+1} α (λ (x : α), not (p x)))] [_inst_2 : Π (x : α), decidable (p x)], iff (not (∀ (x : α), p x)) (@Exists.{u_1+1} α (λ (x : α), not (p x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, (a → b) → not b → not a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Sort u} {β : α → Sort v} {f₁ f₂ : Π (x : α), β x}, (∀ (x : α), @eq.{v} (β x) (f₁ x) (f₂ x)) → @eq.{(imax u v)} (Π (x : α), β x) f₁ f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{(max u_1 v)+1} (Π (a : α), β a) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229    separated_by_f (λz, z i) (infi_le _ i) hi⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_private.2771443467.separated_by_f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='lattice.infi_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 206, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 282, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [tα : topological_space.{u_1} α] [tβ : topological_space.{u_2} β] [_inst_2 : @t2_space.{u_2} β tβ] (f : α → β), @has_le.le.{u_1} (topological_space.{u_1} α) (@preorder.to_has_le.{u_1} (topological_space.{u_1} α) (@partial_order.to_preorder.{u_1} (topological_space.{u_1} α) (@topological_space.partial_order.{u_1} α))) tα (@topological_space.induced.{u_1 u_2} α β f tβ) → ∀ {x y : α}, @ne.{u_2+1} β (f x) (f y) → @Exists.{(max (u_1+1) 1)} (set.{u_1} α) (λ (u : set.{u_1} α), @Exists.{(max (u_1+1) 1)} (set.{u_1} α) (λ (v : set.{u_1} α), and (@is_open.{u_1} α tα u) (and (@is_open.{u_1} α tα v) (and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x u) (and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y v) (@eq.{u_1+1} (set.{u_1} α) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) u v) (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (a : α), β a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (a : α), β a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {ι : Sort w} [_inst_1 : lattice.complete_lattice.{u} α] (s : ι → α) (i : ι), @has_le.le.{u} α (@preorder.to_has_le.{u} α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1))))) (@lattice.infi.{u w} α ι (@lattice.complete_lattice.to_has_Inf.{u} α _inst_1) s) (s i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231  lemma is_closed_diagonal [t2_space α] : is_closed {p:α×α | p.1 = p.2} :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_fun_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (_a : prod.{u u} α α), @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a (@has_inter.inter.{u} (set.{u} (prod.{u u} α α)) (@set.has_inter.{u} (prod.{u u} α α)) (@set.prod.{u u} α α t₁ t₂) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))) → @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a (@has_emptyc.emptyc.{u} (set.{u} (prod.{u u} α α)) (@set.has_emptyc.{u} (prod.{u u} α α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A set is closed if its complement is open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232  is_closed_iff_nhds.mpr $ assume ⟨a₁, a₂⟩ h, eq_of_nhds_ne_bot $ assume : 𝓝 a₁ ⊓ 𝓝 a₂ = ⊥, h $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_closed_iff_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq_of_nhds_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 525, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} α}, iff (@is_closed.{u} α _inst_1 s) (∀ (a : α), @ne.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a) (@filter.principal.{u} α s)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))) → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='prod.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@ne.{u+1} (filter.{u} (prod.{u u} α α)) (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α)) (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) (@prod.mk.{u u} α α a₁ a₂)) (@filter.principal.{u} (prod.{u u} α α) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))))) (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α)) (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α)) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.complete_lattice.{u} (prod.{u u} α α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [ht : @t2_space.{u} α _inst_1] {x y : α}, @ne.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@nhds.{u} α _inst_1 y)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))) → @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [c : lattice.has_inf.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : lattice.has_bot.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@ne.{u+1} (filter.{u} (prod.{u u} α α)) (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α)) (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) (@prod.mk.{u u} α α a₁ a₂)) (@filter.principal.{u} (prod.{u u} α α) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))))) (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α)) (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α)) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.complete_lattice.{u} (prod.{u u} α α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                         </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233    let ⟨t₁, ht₁, t₂, ht₂, (h&#x27; : t₁ ∩ t₂ ⊆ ∅)⟩ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{u+1} (set.{u} α) (λ (t₁ : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)) (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)), @Exists.{u+1} (set.{u} α) (λ (t₂ : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)) (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) → @eq.{u+1} (filter.{u} (prod.{u u} α α)) (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α)) (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) (@prod.mk.{u u} α α a₁ a₂)) (@filter.principal.{u} (prod.{u u} α α) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))))) (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α)) (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α)) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.complete_lattice.{u} (prod.{u u} α α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : has_emptyc.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234      by rw [←empty_in_sets_eq_bot, mem_inf_sets] at this; exact this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='filter.empty_in_sets_eq_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.mem_inf_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 277, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {f : filter.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) f) (@eq.{u+1} (filter.{u} α) f (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {f g : filter.{u} α} {s : set.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) f g)) (@Exists.{u+1} (set.{u} α) (λ (t₁ : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ f) (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ f), @Exists.{u+1} (set.{u} α) (λ (t₂ : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ g) (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ g), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) s)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u+1} (set.{u} α) (λ (t₁ : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)) (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)), @Exists.{u+1} (set.{u} α) (λ (t₂ : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)) (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))
⊢ ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
⊢ ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))))))
⊢ ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))
⊢ ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ : set.{u} α,
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁),
t₂ : set.{u} α,
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂),
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
⊢ @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236      change t₁ ∈ 𝓝 a₁ at ht₁,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='t₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ : set.{u} α,
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁),
t₂ : set.{u} α,
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂),
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
⊢ @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ t₂ : set.{u} α,
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂),
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)
⊢ @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237      change t₂ ∈ 𝓝 a₂ at ht₂,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='t₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ t₂ : set.{u} α,
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂),
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)
⊢ @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ t₂ : set.{u} α,
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁),
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)
⊢ @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238      rw [nhds_prod_eq, ←empty_in_sets_eq_bot],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nhds_prod_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.empty_in_sets_eq_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 132, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β] {a : α} {b : β}, @eq.{u+1} (filter.{u} (prod.{u u} α β)) (@nhds.{u} (prod.{u u} α β) (@prod.topological_space.{u u} α β _inst_1 _inst_2) (@prod.mk.{u u} α β a b)) (@filter.prod.{u u} α β (@nhds.{u} α _inst_1 a) (@nhds.{u} β _inst_2 b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {f : filter.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) f) (@eq.{u+1} (filter.{u} α) f (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ t₂ : set.{u} α,
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁),
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)
⊢ @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ t₂ : set.{u} α,
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁),
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)
⊢ @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@filter.prod.{u u} α α (@nhds.{u} α _inst_1 a₁) (@nhds.{u} α _inst_1 a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ t₂ : set.{u} α,
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁),
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)
⊢ @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@has_emptyc.emptyc.{u} (set.{u} (prod.{u u} α α)) (@set.has_emptyc.{u} (prod.{u u} α α)))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@filter.prod.{u u} α α (@nhds.{u} α _inst_1 a₁) (@nhds.{u} α _inst_1 a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239      apply filter.sets_of_superset,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter.sets_of_superset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (c : filter.{u} α) {x y : set.{u} α}, @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) x (@filter.sets.{u} α c) → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) x y → @has_mem.mem.{u u} (set.{u} α) (set.{u} (set.{u} α)) (@set.has_mem.{u} (set.{u} α)) y (@filter.sets.{u} α c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ t₂ : set.{u} α,
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁),
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)
⊢ @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@has_emptyc.emptyc.{u} (set.{u} (prod.{u u} α α)) (@set.has_emptyc.{u} (prod.{u u} α α)))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@filter.prod.{u u} α α (@nhds.{u} α _inst_1 a₁) (@nhds.{u} α _inst_1 a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ t₂ : set.{u} α,
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁),
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)
⊢ @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (set.{u} (set.{u} (prod.{u u} α α)))
    (@set.has_mem.{u} (set.{u} (prod.{u u} α α)))
    ?m_1
    (@filter.sets.{u} (prod.{u u} α α)
       (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
          (@filter.prod.{u u} α α (@nhds.{u} α _inst_1 a₁) (@nhds.{u} α _inst_1 a₂))
          (@filter.principal.{u} (prod.{u u} α α)
             (@set_of.{u} (prod.{u u} α α)
                (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))))))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ t₂ : set.{u} α,
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁),
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)
⊢ @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) ?m_1
    (@has_emptyc.emptyc.{u} (set.{u} (prod.{u u} α α)) (@set.has_emptyc.{u} (prod.{u u} α α)))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ t₂ : set.{u} α,
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁),
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)
⊢ set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240      apply inter_mem_inf_sets (prod_mem_prod ht₁ ht₂) (mem_principal_sets.mpr (subset.refl _)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter.inter_mem_inf_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.prod_mem_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.mem_principal_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1527, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 194, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {f g : filter.{u} α} {s t : set.{u} α}, @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t g → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) f g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u} {s : set.{u} α} {t : set.{u} β} {f : filter.{u} α} {g : filter.{u} β}, @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f → @has_mem.mem.{u u} (set.{u} β) (filter.{u} β) (@filter.has_mem.{u} β) t g → @has_mem.mem.{u u} (set.{u} (prod.{u u} α β)) (filter.{u} (prod.{u u} α β)) (@filter.has_mem.{u} (prod.{u u} α β)) (@set.prod.{u u} α β s t) (@filter.prod.{u u} α β f g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@filter.principal.{u} α t)) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} (a : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ t₂ : set.{u} α,
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁),
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)
⊢ @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (set.{u} (set.{u} (prod.{u u} α α)))
    (@set.has_mem.{u} (set.{u} (prod.{u u} α α)))
    ?m_1
    (@filter.sets.{u} (prod.{u u} α α)
       (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
          (@filter.prod.{u u} α α (@nhds.{u} α _inst_1 a₁) (@nhds.{u} α _inst_1 a₂))
          (@filter.principal.{u} (prod.{u u} α α)
             (@set_of.{u} (prod.{u u} α α)
                (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))))))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ t₂ : set.{u} α,
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁),
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)
⊢ @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) ?m_1
    (@has_emptyc.emptyc.{u} (set.{u} (prod.{u u} α α)) (@set.has_emptyc.{u} (prod.{u u} α α)))

α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ t₂ : set.{u} α,
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁),
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)
⊢ set.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ t₂ : set.{u} α,
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁),
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)
⊢ @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
    (@has_inter.inter.{u} (set.{u} (prod.{u u} α α)) (@set.has_inter.{u} (prod.{u u} α α))
       (@set.prod.{u u} α α t₁ t₂)
       (@set_of.{u} (prod.{u u} α α)
          (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))))
    (@has_emptyc.emptyc.{u} (set.{u} (prod.{u u} α α)) (@set.has_emptyc.{u} (prod.{u u} α α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241      exact assume ⟨x₁, x₂⟩ ⟨⟨hx₁, hx₂⟩, (heq : x₁ = x₂)⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hx₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hx₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='heq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.fst.{u u} α α (@prod.mk.{u u} α α x₁ x₂)) t₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@prod.snd.{u u} α α (@prod.mk.{u u} α α x₁ x₂)) t₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α x₁ x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ t₂ : set.{u} α,
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁),
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)
⊢ @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
    (@has_inter.inter.{u} (set.{u} (prod.{u u} α α)) (@set.has_inter.{u} (prod.{u u} α α))
       (@set.prod.{u u} α α t₁ t₂)
       (@set_of.{u} (prod.{u u} α α)
          (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))))
    (@has_emptyc.emptyc.{u} (set.{u} (prod.{u u} α α)) (@set.has_emptyc.{u} (prod.{u u} α α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242        show false, from @h&#x27; x₁ ⟨hx₁, heq.symm ▸ hx₂⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 138, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {a b : α}, @eq.{u+1} α a b → @eq.{u+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ t₂ : set.{u} α,
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁),
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)
⊢ @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
    (@has_inter.inter.{u} (set.{u} (prod.{u u} α α)) (@set.has_inter.{u} (prod.{u u} α α))
       (@set.prod.{u u} α α t₁ t₂)
       (@set_of.{u} (prod.{u u} α α)
          (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))))
    (@has_emptyc.emptyc.{u} (set.{u} (prod.{u u} α α)) (@set.has_emptyc.{u} (prod.{u u} α α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243    end</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @t2_space.{u} α _inst_1,
_x : prod.{u u} α α,
_fun_match :
  ∀ (_a : prod.{u u} α α),
    @ne.{u+1} (filter.{u} (prod.{u u} α α))
      (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
         (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) _a)
         (@filter.principal.{u} (prod.{u u} α α)
            (@set_of.{u} (prod.{u u} α α)
               (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
      (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
         (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
            (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
               (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                  (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))) →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) _a
      (@set_of.{u} (prod.{u u} α α)
         (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))),
a₁ a₂ : α,
h :
  @ne.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
this :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a₁)
       (@nhds.{u} α _inst_1 a₂))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α))))),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t₁ : set.{u} α),
       @Exists.{0}
         (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁))
         (λ
          (H :
            @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁)),
            @Exists.{u+1} (set.{u} α)
              (λ (t₂ : set.{u} α),
                 @Exists.{0}
                   (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                      (@nhds.{u} α _inst_1 a₂))
                   (λ
                    (H :
                      @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂
                        (@nhds.{u} α _inst_1 a₂)),
                      @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                        (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
                        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))) →
  @eq.{u+1} (filter.{u} (prod.{u u} α α))
    (@lattice.has_inf.inf.{u} (filter.{u} (prod.{u u} α α)) (@filter.lattice.has_inf.{u} (prod.{u u} α α))
       (@nhds.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1)
          (@prod.mk.{u u} α α a₁ a₂))
       (@filter.principal.{u} (prod.{u u} α α)
          (@set_of.{u} (prod.{u u} α α)
             (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))))
    (@lattice.has_bot.bot.{u} (filter.{u} (prod.{u u} α α))
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} (prod.{u u} α α))
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} (prod.{u u} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} (prod.{u u} α α))
                (@filter.lattice.complete_lattice.{u} (prod.{u u} α α)))))),
t₁ t₂ : set.{u} α,
h&#x27; :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
ht₁ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ (@nhds.{u} α _inst_1 a₁),
ht₂ : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ (@nhds.{u} α _inst_1 a₂)
⊢ @has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α))
    (@has_inter.inter.{u} (set.{u} (prod.{u u} α α)) (@set.has_inter.{u} (prod.{u u} α α))
       (@set.prod.{u u} α α t₁ t₂)
       (@set_of.{u} (prod.{u u} α α)
          (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))))
    (@has_emptyc.emptyc.{u} (set.{u} (prod.{u u} α α)) (@set.has_emptyc.{u} (prod.{u u} α α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245  variables [topological_space β]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247  lemma is_closed_eq [t2_space α] {f g : β → α}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248    (hf : continuous f) (hg : continuous g) : is_closed {x:β | f x = g x} :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 644, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 644, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, (α → Prop) → set.{v} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A function between topological spaces is continuous if the preimage
 of every open set is open.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A function between topological spaces is continuous if the preimage
 of every open set is open.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A set is closed if its complement is open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249  continuous_iff_is_closed.mp (hf.prod_mk hg) _ is_closed_diagonal</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='continuous_iff_is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='continuous.prod_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_closed_diagonal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 695, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 231, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {β : Type u} [_inst_1 : topological_space.{v} α] [_inst_2 : topological_space.{u} β] {f : α → β}, iff (@continuous.{v u} α β _inst_1 _inst_2 f) (∀ (s : set.{u} β), @is_closed.{u} β _inst_2 s → @is_closed.{v} α _inst_1 (@set.preimage.{v u} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@continuous.{v u} β α _inst_2 _inst_1 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} {γ : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β] [_inst_3 : topological_space.{v} γ] {f : γ → α} {g : γ → β}, @continuous.{v u} γ α _inst_3 _inst_1 f → @continuous.{v u} γ β _inst_3 _inst_2 g → @continuous.{v u} γ (prod.{u u} α β) _inst_3 (@prod.topological_space.{u u} α β _inst_1 _inst_2) (λ (x : γ), @prod.mk.{u u} α β (f x) (g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@continuous.{v u} β α _inst_2 _inst_1 g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : @t2_space.{u} α _inst_1], @is_closed.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251  lemma diagonal_eq_range_diagonal_map {α : Type*} : {p:α×α | p.1 = p.2} = range (λx, (x,x)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, prod.{u_1 u_1} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, prod.{u_1 u_1} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {ι : Sort x}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                         </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252  ext $ assume p, iff.intro</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff.intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a b : set.{u_1} α}, (∀ (x : α), iff (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x a) (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x b)) → @eq.{(max (u_1+1) 1)} (set.{u_1} α) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, (a → b) → (b → a) → iff a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253    (assume h, ⟨p.1, prod.ext_iff.2 ⟨rfl, h⟩⟩)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.ext_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/prod.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) p (@set_of.{u_1} (prod.{u_1 u_1} α α) (λ (p : prod.{u_1 u_1} α α), @eq.{u_1+1} α (@prod.fst.{u_1 u_1} α α p) (@prod.snd.{u_1 u_1} α α p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, prod.{u_1 u_1} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α β : Type u_1} {p q : prod.{u_1 u_1} α β}, iff (@eq.{u_1+1} (prod.{u_1 u_1} α β) p q) (and (@eq.{u_1+1} α (@prod.fst.{u_1 u_1} α β p) (@prod.fst.{u_1 u_1} α β q)) (@eq.{u_1+1} β (@prod.snd.{u_1 u_1} α β p) (@prod.snd.{u_1 u_1} α β q)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) p (@set_of.{u_1} (prod.{u_1 u_1} α α) (λ (p : prod.{u_1 u_1} α α), @eq.{u_1+1} α (@prod.fst.{u_1 u_1} α α p) (@prod.snd.{u_1 u_1} α α p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254    (assume ⟨x, hx⟩, show p.1 = p.2, by rw ←hx)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) p (@set.range.{u_1 u_1+1} (prod.{u_1 u_1} α α) α (λ (x : α), @prod.mk.{u_1 u_1} α α x x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, prod.{u_1 u_1} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, prod.{u_1 u_1} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (prod.{u_1 u_1} α α) ((λ (x : α), @prod.mk.{u_1 u_1} α α x x) x) p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='lime'><a title='α : Type u_1,
p : prod.{u_1 u_1} α α,
_x :
  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
    p
    (@set.range.{u_1 u_1+1} (prod.{u_1 u_1} α α) α (λ (x : α), @prod.mk.{u_1 u_1} α α x x)),
_fun_match :
  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
    p
    (@set.range.{u_1 u_1+1} (prod.{u_1 u_1} α α) α (λ (x : α), @prod.mk.{u_1 u_1} α α x x)) →
  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
    p
    (@set_of.{u_1} (prod.{u_1 u_1} α α)
       (λ (p : prod.{u_1 u_1} α α), @eq.{u_1+1} α (@prod.fst.{u_1 u_1} α α p) (@prod.snd.{u_1 u_1} α α p))),
x : α,
hx : @eq.{u_1+1} (prod.{u_1 u_1} α α) ((λ (x : α), @prod.mk.{u_1 u_1} α α x x) x) p
⊢ @eq.{u_1+1} α (@prod.fst.{u_1 u_1} α α p) (@prod.snd.{u_1 u_1} α α p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256  lemma prod_subset_compl_diagonal_iff_disjoint {α : Type*} {s t : set α} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257    set.prod s t ⊆ - {p:α×α | p.1 = p.2} ↔ s ∩ t = ∅ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, set.{u_1} α → set.{u_2} β → set.{(max u_1 u_2)} (prod.{u_1 u_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_subset.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_neg.{u_1} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, prod.{u_1 u_1} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, prod.{u_1 u_1} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_inter.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [c : has_emptyc.{u_1} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  by rw [eq_empty_iff_forall_not_mem, subset_compl_comm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.eq_empty_iff_forall_not_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset_compl_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 197, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 657, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {s : set.{u_1} α}, iff (@eq.{(max (u_1+1) 1)} (set.{u_1} α) s (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α))) (∀ (x : α), not (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {s t : set.{u_1} α}, iff (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) s (@has_neg.neg.{u_1} (set.{u_1} α) (@set.has_neg.{u_1} α) t)) (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) t (@has_neg.neg.{u_1} (set.{u_1} α) (@set.has_neg.{u_1} α) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
s t : set.{u_1} α
⊢ iff
    (@has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
       (@set.prod.{u_1 u_1} α α s t)
       (@has_neg.neg.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_neg.{u_1} (prod.{u_1 u_1} α α))
          (@set_of.{u_1} (prod.{u_1 u_1} α α)
             (λ (p : prod.{u_1 u_1} α α),
                @eq.{u_1+1} α (@prod.fst.{u_1 u_1} α α p) (@prod.snd.{u_1 u_1} α α p)))))
    (@eq.{u_1+1} (set.{u_1} α) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) s t)
       (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
s t : set.{u_1} α
⊢ iff
    (@has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
       (@set.prod.{u_1 u_1} α α s t)
       (@has_neg.neg.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_neg.{u_1} (prod.{u_1 u_1} α α))
          (@set_of.{u_1} (prod.{u_1 u_1} α α)
             (λ (p : prod.{u_1 u_1} α α),
                @eq.{u_1+1} α (@prod.fst.{u_1 u_1} α α p) (@prod.snd.{u_1 u_1} α α p)))))
    (∀ (x : α),
       not
         (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
            (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) s t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
s t : set.{u_1} α
⊢ iff
    (@has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
       (@set_of.{u_1} (prod.{u_1 u_1} α α)
          (λ (p : prod.{u_1 u_1} α α), @eq.{u_1+1} α (@prod.fst.{u_1 u_1} α α p) (@prod.snd.{u_1 u_1} α α p)))
       (@has_neg.neg.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_neg.{u_1} (prod.{u_1 u_1} α α))
          (@set.prod.{u_1 u_1} α α s t)))
    (∀ (x : α),
       not
         (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
            (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) s t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259         diagonal_eq_range_diagonal_map, range_subset_iff]; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='diagonal_eq_range_diagonal_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.range_subset_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 251, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1224, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1}, @eq.{(max (u_1+1) 1)} (set.{u_1} (prod.{u_1 u_1} α α)) (@set_of.{u_1} (prod.{u_1 u_1} α α) (λ (p : prod.{u_1 u_1} α α), @eq.{u_1+1} α (@prod.fst.{u_1 u_1} α α p) (@prod.snd.{u_1 u_1} α α p))) (@set.range.{u_1 u_1+1} (prod.{u_1 u_1} α α) α (λ (x : α), @prod.mk.{u_1 u_1} α α x x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α ι : Type u_1} {f : ι → α} {s : set.{u_1} α}, iff (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (@set.range.{u_1 u_1+1} α ι f) s) (∀ (y : ι), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (f y) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
s t : set.{u_1} α
⊢ iff
    (@has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
       (@set_of.{u_1} (prod.{u_1 u_1} α α)
          (λ (p : prod.{u_1 u_1} α α), @eq.{u_1+1} α (@prod.fst.{u_1 u_1} α α p) (@prod.snd.{u_1 u_1} α α p)))
       (@has_neg.neg.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_neg.{u_1} (prod.{u_1 u_1} α α))
          (@set.prod.{u_1 u_1} α α s t)))
    (∀ (x : α),
       not
         (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
            (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) s t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
s t : set.{u_1} α
⊢ iff
    (@has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
       (@set.range.{u_1 u_1+1} (prod.{u_1 u_1} α α) α (λ (x : α), @prod.mk.{u_1 u_1} α α x x))
       (@has_neg.neg.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_neg.{u_1} (prod.{u_1 u_1} α α))
          (@set.prod.{u_1 u_1} α α s t)))
    (∀ (x : α),
       not
         (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
            (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) s t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
s t : set.{u_1} α
⊢ iff
    (∀ (y : α),
       @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
         (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
         (@prod.mk.{u_1 u_1} α α y y)
         (@has_neg.neg.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_neg.{u_1} (prod.{u_1 u_1} α α))
            (@set.prod.{u_1 u_1} α α s t)))
    (∀ (x : α),
       not
         (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
            (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) s t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
s t : set.{u_1} α
⊢ iff
    (@has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
       (@set.prod.{u_1 u_1} α α s t)
       (@has_neg.neg.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_neg.{u_1} (prod.{u_1 u_1} α α))
          (@set_of.{u_1} (prod.{u_1 u_1} α α)
             (λ (p : prod.{u_1 u_1} α α),
                @eq.{u_1+1} α (@prod.fst.{u_1 u_1} α α p) (@prod.snd.{u_1 u_1} α α p)))))
    (@eq.{u_1+1} (set.{u_1} α) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) s t)
       (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
s t : set.{u_1} α
⊢ iff
    (@has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
       (@set.prod.{u_1 u_1} α α s t)
       (@has_neg.neg.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_neg.{u_1} (prod.{u_1 u_1} α α))
          (@set_of.{u_1} (prod.{u_1 u_1} α α)
             (λ (p : prod.{u_1 u_1} α α),
                @eq.{u_1+1} α (@prod.fst.{u_1 u_1} α α p) (@prod.snd.{u_1 u_1} α α p)))))
    (@eq.{u_1+1} (set.{u_1} α) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) s t)
       (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261  lemma compact_compact_separated [t2_space α] {s t : set α}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262    (hs : compact s) (ht : compact t) (hst : s ∩ t = ∅) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='compact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='compact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : has_emptyc.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A set `s` is compact if for every filter `f` that contains `s`,
   every set of `f` also meets every neighborhood of some `a ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A set `s` is compact if for every filter `f` that contains `s`,
   every set of `f` also meets every neighborhood of some `a ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263    ∃u v : set α, is_open u ∧ is_open v ∧ s ⊆ u ∧ t ⊆ v ∧ u ∩ v = ∅ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : has_emptyc.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264  by simp only [prod_subset_compl_diagonal_iff_disjoint.symm] at ⊢ hst;</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='iff (@eq.{?l_1+1} (set.{?l_1} ?m_2) (@has_inter.inter.{?l_1} (set.{?l_1} ?m_2) (@set.has_inter.{?l_1} ?m_2) ?m_3 ?m_4) (@has_emptyc.emptyc.{?l_1} (set.{?l_1} ?m_2) (@set.has_emptyc.{?l_1} ?m_2))) (@has_subset.subset.{?l_1} (set.{?l_1} (prod.{?l_1 ?l_1} ?m_2 ?m_2)) (@set.has_subset.{?l_1} (prod.{?l_1 ?l_1} ?m_2 ?m_2)) (@set.prod.{?l_1 ?l_1} ?m_2 ?m_2 ?m_3 ?m_4) (@has_neg.neg.{?l_1} (set.{?l_1} (prod.{?l_1 ?l_1} ?m_2 ?m_2)) (@set.has_neg.{?l_1} (prod.{?l_1 ?l_1} ?m_2 ?m_2)) (@set_of.{?l_1} (prod.{?l_1 ?l_1} ?m_2 ?m_2) (λ (p : prod.{?l_1 ?l_1} ?m_2 ?m_2), @eq.{?l_1+1} ?m_2 (@prod.fst.{?l_1 ?l_1} ?m_2 ?m_2 p) (@prod.snd.{?l_1 ?l_1} ?m_2 ?m_2 p)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_3 : @t2_space.{u} α _inst_1,
s t : set.{u} α,
hs : @compact.{u} α _inst_1 s,
ht : @compact.{u} α _inst_1 t,
hst :
  @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
⊢ @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (u : set.{u} α),
       @Exists.{(max (u+1) 1)} (set.{u} α)
         (λ (v : set.{u} α),
            and (@is_open.{u} α _inst_1 u)
              (and (@is_open.{u} α _inst_1 v)
                 (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u)
                    (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t v)
                       (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v)
                          (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265     exact generalized_tube_lemma hs ht is_closed_diagonal hst</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='generalized_tube_lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_closed_diagonal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 231, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β] {s : set.{u} α}, @compact.{u} α _inst_1 s → ∀ {t : set.{u} β}, @compact.{u} β _inst_2 t → ∀ {n : set.{u} (prod.{u u} α β)}, @is_open.{u} (prod.{u u} α β) (@prod.topological_space.{u u} α β _inst_1 _inst_2) n → @has_subset.subset.{u} (set.{u} (prod.{u u} α β)) (@set.has_subset.{u} (prod.{u u} α β)) (@set.prod.{u u} α β s t) n → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} β) (λ (v : set.{u} β), and (@is_open.{u} α _inst_1 u) (and (@is_open.{u} β _inst_2 v) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u) (and (@has_subset.subset.{u} (set.{u} β) (@set.has_subset.{u} β) t v) (@has_subset.subset.{u} (set.{u} (prod.{u u} α β)) (@set.has_subset.{u} (prod.{u u} α β)) (@set.prod.{u u} α β u v) n))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@compact.{u} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@compact.{u} α _inst_1 t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : @t2_space.{u} α _inst_1], @is_closed.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α _inst_1 _inst_1) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) (@set.prod.{u u} α α s t) (@has_neg.neg.{u} (set.{u} (prod.{u u} α α)) (@set.has_neg.{u} (prod.{u u} α α)) (@set_of.{u} (prod.{u u} α α) (λ (p : prod.{u u} α α), @eq.{u+1} α (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_3 : @t2_space.{u} α _inst_1,
s t : set.{u} α,
hs : @compact.{u} α _inst_1 s,
ht : @compact.{u} α _inst_1 t,
hst :
  @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
⊢ @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (u : set.{u} α),
       @Exists.{(max (u+1) 1)} (set.{u} α)
         (λ (v : set.{u} α),
            and (@is_open.{u} α _inst_1 u)
              (and (@is_open.{u} α _inst_1 v)
                 (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u)
                    (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t v)
                       (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v)
                          (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_3 : @t2_space.{u} α _inst_1,
s t : set.{u} α,
hs : @compact.{u} α _inst_1 s,
ht : @compact.{u} α _inst_1 t,
hst :
  @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))
⊢ @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (u : set.{u} α),
       @Exists.{(max (u+1) 1)} (set.{u} α)
         (λ (v : set.{u} α),
            and (@is_open.{u} α _inst_1 u)
              (and (@is_open.{u} α _inst_1 v)
                 (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u)
                    (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t v)
                       (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v)
                          (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267  lemma closed_of_compact [t2_space α] (s : set α) (hs : compact s) : is_closed s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='compact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='A set `s` is compact if for every filter `f` that contains `s`,
   every set of `f` also meets every neighborhood of some `a ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A set is closed if its complement is open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  is_open_compl_iff.mpr $ is_open_iff_forall_mem_open.mpr $ assume x hx,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_open_compl_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_open_iff_forall_mem_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 143, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 241, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} α}, iff (@is_open.{u} α _inst_1 (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)) (@is_closed.{u} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α} [_inst_1 : topological_space.{u} α], iff (@is_open.{u} α _inst_1 s) (∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s → @Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s) (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s), and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269    let ⟨u, v, uo, vo, su, xv, uv⟩ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='vo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='su'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='uv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α _inst_1 u) (and (@is_open.{u} α _inst_1 v) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x) v) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))))) → @Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)) (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)), and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@is_open.{u} α _inst_1 v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270      compact_compact_separated hs (compact_singleton : compact {x})</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='compact_compact_separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='compact_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='compact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 179, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_3 : @t2_space.{u} α _inst_1] {s t : set.{u} α}, @compact.{u} α _inst_1 s → @compact.{u} α _inst_1 t → @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α _inst_1 u) (and (@is_open.{u} α _inst_1 v) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t v) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@compact.{u} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α}, @compact.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='orange'><a title='A set `s` is compact if for every filter `f` that contains `s`,
   every set of `f` also meets every neighborhood of some `a ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271        (by rwa [inter_comm, ←subset_compl_iff_disjoint, singleton_subset_iff]) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set.inter_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.subset_compl_iff_disjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.singleton_subset_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 367, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 660, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 535, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (a b : set.{u} α), @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) a b) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α}, iff (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) t)) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α} {s : set.{u} α}, iff (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) a) s) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_3 : @t2_space.{u} α _inst_1,
s : set.{u} α,
hs : @compact.{u} α _inst_1 s,
x : α,
hx : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
⊢ @eq.{u+1} (set.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s
       (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_3 : @t2_space.{u} α _inst_1,
s : set.{u} α,
hs : @compact.{u} α _inst_1 s,
x : α,
hx : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
⊢ @eq.{u+1} (set.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
       s)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_3 : @t2_space.{u} α _inst_1,
s : set.{u} α,
hs : @compact.{u} α _inst_1 s,
x : α,
hx : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
⊢ @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_3 : @t2_space.{u} α _inst_1,
s : set.{u} α,
hs : @compact.{u} α _inst_1 s,
x : α,
hx : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272    have v ⊆ -s, from</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273      subset_compl_comm.mp (subset.trans su (subset_compl_iff_disjoint.mpr uv)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.subset_compl_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.subset_compl_iff_disjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 657, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 660, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α}, iff (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) t)) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {a b c : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a b → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b c → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α}, iff (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) t)) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274  ⟨v, this, vo, by simpa using xv⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='xv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) v (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x) v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_3 : @t2_space.{u} α _inst_1,
s : set.{u} α,
hs : @compact.{u} α _inst_1 s,
x : α,
hx : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (u : set.{u} α),
       @Exists.{(max (u+1) 1)} (set.{u} α)
         (λ (v : set.{u} α),
            and (@is_open.{u} α _inst_1 u)
              (and (@is_open.{u} α _inst_1 v)
                 (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u)
                    (and
                       (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
                          (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
                          v)
                       (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v)
                          (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))))) →
  @Exists.{u+1} (set.{u} α)
    (λ (t : set.{u} α),
       @Exists.{0}
         (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t
            (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
         (λ
          (H :
            @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t
              (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)),
            and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t))),
u v : set.{u} α,
uo : @is_open.{u} α _inst_1 u,
vo : @is_open.{u} α _inst_1 v,
su : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u,
xv :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)
    v,
uv :
  @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v)
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
this :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) v (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276  lemma locally_compact_of_compact_nhds [t2_space α] (h : ∀ x : α, ∃ s, s ∈ 𝓝 x ∧ compact s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='compact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A set `s` is compact if for every filter `f` that contains `s`,
   every set of `f` also meets every neighborhood of some `a ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277    locally_compact_space α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='locally_compact_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 406, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_3 : topological_space.{u_1} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' There are various definitions of &quot;locally compact space&quot; in the literature, which agree for
Hausdorff spaces but not in general. This one is the precise condition on X needed for the
evaluation `map C(X, Y) × X → Y` to be continuous for all `Y` when `C(X, Y)` is given the
compact-open topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278  ⟨assume x n hn,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) n (@nhds.{u} α _inst_1 x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279    let ⟨u, un, uo, xu⟩ := mem_nhds_sets_iff.mp hn in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='un'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='mem_nhds_sets_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 421, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t n) (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t n), and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t))) → @Exists.{u+1} (set.{u} α) (λ (s : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x)) (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x)), and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s n) (@compact.{u} α _inst_1 s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) u n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u} α _inst_1 u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α} {s : set.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a)) (@Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s) (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s), and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) n (@nhds.{u} α _inst_1 x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280    let ⟨k, kx, kc⟩ := h x in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='kx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='kc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{u+1} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x)) (@compact.{u} α _inst_1 s)) → @Exists.{u+1} (set.{u} α) (λ (s : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x)) (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x)), and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s n) (@compact.{u} α _inst_1 s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) k (@nhds.{u} α _inst_1 x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@compact.{u} α _inst_1 k'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ (x : α), @Exists.{u+1} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x)) (@compact.{u} α _inst_1 s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281    -- K is compact but not necessarily contained in N.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282    -- K \ U is again compact and doesn&#x27;t contain x, so</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283    -- we may find open sets V, W separating x from K \ U.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284    -- Then K \ W is a compact neighborhood of x contained in U.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285    let ⟨v, w, vo, wo, xv, kuw, vw⟩ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='wo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='kuw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} α) (λ (u_1 : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α _inst_1 u_1) (and (@is_open.{u} α _inst_1 v) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x) u_1) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) k u) v) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u_1 v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))))))) → @Exists.{u+1} (set.{u} α) (λ (s : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x)) (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x)), and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s n) (@compact.{u} α _inst_1 s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u} α _inst_1 v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u} α _inst_1 w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x) v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) k u) w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) v w) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286      compact_compact_separated compact_singleton (compact_diff kc uo)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='compact_compact_separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='compact_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='compact_diff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 179, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_3 : @t2_space.{u} α _inst_1] {s t : set.{u} α}, @compact.{u} α _inst_1 s → @compact.{u} α _inst_1 t → @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α _inst_1 u) (and (@is_open.{u} α _inst_1 v) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t v) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α}, @compact.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s t : set.{u} α}, @compact.{u} α _inst_1 s → @is_open.{u} α _inst_1 t → @compact.{u} α _inst_1 (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287        (by rw [singleton_inter_eq_empty]; exact λ h, h.2 xu) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='set.singleton_inter_eq_empty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='xu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 547, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α} {s : set.{u} α}, iff (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) a) s) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))) (not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_3 : @t2_space.{u} α _inst_1,
h :
  ∀ (x : α),
    @Exists.{u+1} (set.{u} α)
      (λ (s : set.{u} α),
         and (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x))
           (@compact.{u} α _inst_1 s)),
x : α,
n : set.{u} α,
hn : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) n (@nhds.{u} α _inst_1 x),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t : set.{u} α),
       @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t n)
         (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t n),
            and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t))) →
  @Exists.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x))
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x)),
            and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s n) (@compact.{u} α _inst_1 s))),
u : set.{u} α,
un : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) u n,
uo : @is_open.{u} α _inst_1 u,
xu : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x u,
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x))
         (@compact.{u} α _inst_1 s)) →
  @Exists.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x))
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x)),
            and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s n) (@compact.{u} α _inst_1 s))),
k : set.{u} α,
kx : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) k (@nhds.{u} α _inst_1 x),
kc : @compact.{u} α _inst_1 k
⊢ @eq.{u+1} (set.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) ?m_1)
       (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) k u))
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_3 : @t2_space.{u} α _inst_1,
h :
  ∀ (x : α),
    @Exists.{u+1} (set.{u} α)
      (λ (s : set.{u} α),
         and (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x))
           (@compact.{u} α _inst_1 s)),
x : α,
n : set.{u} α,
hn : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) n (@nhds.{u} α _inst_1 x),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t : set.{u} α),
       @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t n)
         (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t n),
            and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t))) →
  @Exists.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x))
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x)),
            and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s n) (@compact.{u} α _inst_1 s))),
u : set.{u} α,
un : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) u n,
uo : @is_open.{u} α _inst_1 u,
xu : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x u,
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x))
         (@compact.{u} α _inst_1 s)) →
  @Exists.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x))
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x)),
            and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s n) (@compact.{u} α _inst_1 s))),
k : set.{u} α,
kx : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) k (@nhds.{u} α _inst_1 x),
kc : @compact.{u} α _inst_1 k
⊢ not
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) ?m_1
       (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) k u))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_3 : @t2_space.{u} α _inst_1,
h :
  ∀ (x : α),
    @Exists.{u+1} (set.{u} α)
      (λ (s : set.{u} α),
         and (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x))
           (@compact.{u} α _inst_1 s)),
x : α,
n : set.{u} α,
hn : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) n (@nhds.{u} α _inst_1 x),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t : set.{u} α),
       @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t n)
         (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t n),
            and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t))) →
  @Exists.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x))
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x)),
            and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s n) (@compact.{u} α _inst_1 s))),
u : set.{u} α,
un : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) u n,
uo : @is_open.{u} α _inst_1 u,
xu : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x u,
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       and (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x))
         (@compact.{u} α _inst_1 s)) →
  @Exists.{u+1} (set.{u} α)
    (λ (s : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x))
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x)),
            and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s n) (@compact.{u} α _inst_1 s))),
k : set.{u} α,
kx : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) k (@nhds.{u} α _inst_1 x),
kc : @compact.{u} α _inst_1 k
⊢ @eq.{u+1} (set.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) ?m_1)
       (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) k u))
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288    have wn : -w ∈ 𝓝 x, from</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289     mem_nhds_sets_iff.mpr</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mem_nhds_sets_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 421, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α} {s : set.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a)) (@Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s) (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s), and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290       ⟨v, subset_compl_iff_disjoint.mpr vw, vo, singleton_subset_iff.mp xv⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set.subset_compl_iff_disjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set.singleton_subset_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 660, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 535, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α}, iff (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) t)) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u} {a : α} {s : set.{u} α}, iff (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) a) s) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291    ⟨k - w,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292     filter.inter_mem_sets kx wn,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.inter_mem_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='wn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {f : filter.{u} α} {s t : set.{u} α}, @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t f → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) w) (@nhds.{u} α _inst_1 x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293     subset.trans (diff_subset_comm.mp kuw) un,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.subset.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.diff_subset_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 770, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {a b c : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a b → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b c → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {s t u : set.{u} α}, iff (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) s t) u) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) s u) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294     compact_diff kc wo⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='compact_diff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s t : set.{u} α}, @compact.{u} α _inst_1 s → @is_open.{u} α _inst_1 t → @compact.{u} α _inst_1 (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296  @[priority 100] -- see Note [lower instance priority]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>297  instance locally_compact_of_compact [t2_space α] [compact_space α] : locally_compact_space α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='compact_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='locally_compact_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 406, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u_1) [_inst_3 : topological_space.{u_1} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' Type class for compact spaces. Separation is sometimes included in the definition, especially
in the French literature, but we do not include it here.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' There are various definitions of &quot;locally compact space&quot; in the literature, which agree for
Hausdorff spaces but not in general. This one is the precise condition on X needed for the
evaluation `map C(X, Y) × X → Y` to be continuous for all `Y` when `C(X, Y)` is given the
compact-open topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>298  locally_compact_of_compact_nhds (assume x, ⟨univ, mem_nhds_sets is_open_univ trivial, compact_univ⟩)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='locally_compact_of_compact_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mem_nhds_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='trivial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='compact_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 276, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 282, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_3 : @t2_space.{u} α _inst_1], (∀ (x : α), @Exists.{u+1} (set.{u} α) (λ (s : set.{u} α), and (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 x)) (@compact.{u} α _inst_1 s))) → @locally_compact_space.{u} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α} {s : set.{u} α}, @is_open.{u} α _inst_1 s → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [t : topological_space.{u} α], @is_open.{u} α t (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [h : @compact_space.{u} α _inst_1], @compact.{u} α _inst_1 (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>299  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>300  end separation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>301  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>302  section regularity</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>303  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>304  section prio</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>305  set_option default_priority 100 -- see Note [default priority]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='default priority for attributes'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>306  /-- A T₃ space, also known as a regular space (although this condition sometimes</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>307    omits T₂), is one in which for every closed `C` and `x ∉ C`, there exist</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>308    disjoint open sets containing `x` and `C` respectively. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>309  class regular_space (α : Type u) [topological_space α] extends t1_space α : Prop :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='t1_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='A T₁ space, also known as a Fréchet space, is a topological space
 where every singleton set is closed. Equivalently, for every pair
 `x ≠ y`, there is an open set containing `x` and not `y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>310  (regular : ∀{s:set α} {a}, is_closed s → a ∉ s → ∃t, is_open t ∧ s ⊆ t ∧ 𝓝 a ⊓ principal t = ⊥)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='regular'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='∀ {s : set.{u} α} {a : α}, @is_closed.{u} α _inst_2 s → not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (t : set.{u} α), and (@is_open.{u} α _inst_2 t) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t) (@eq.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_2 a) (@filter.principal.{u} α t)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : lattice.has_inf.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : lattice.has_bot.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A set is closed if its complement is open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>311  end prio</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>312  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>313  lemma nhds_is_closed [regular_space α] {a : α} {s : set α} (h : s ∈ 𝓝 a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='regular_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 309, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='A T₃ space, also known as a regular space (although this condition sometimes
 omits T₂), is one in which for every closed `C` and `x ∉ C`, there exist
 disjoint open sets containing `x` and `C` respectively.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>314    ∃t∈(𝓝 a), t ⊆ s ∧ is_closed t :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='A set is closed if its complement is open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>315  let ⟨s&#x27;, h₁, h₂, h₃⟩ := mem_nhds_sets_iff.mp h in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mem_nhds_sets_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 421, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s) (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s), and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t))) → @Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t (@nhds.{u} α _inst_1 a)) (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t (@nhds.{u} α _inst_1 a)), and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s) (@is_closed.{u} α _inst_1 t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s&#x27; s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u} α _inst_1 s&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α} {s : set.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a)) (@Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s) (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s), and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>316  have ∃t, is_open t ∧ -s&#x27; ⊆ t ∧ 𝓝 a ⊓ principal t = ⊥,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : lattice.has_inf.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : lattice.has_bot.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>317    from regular_space.regular (is_closed_compl_iff.mpr h₂) (not_not_intro h₃),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='regular_space.regular'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_closed_compl_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='not_not_intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 309, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u} [_inst_2 : topological_space.{u} α] [c : @regular_space.{u} α _inst_2] {s : set.{u} α} {a : α}, @is_closed.{u} α _inst_2 s → not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (t : set.{u} α), and (@is_open.{u} α _inst_2 t) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t) (@eq.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_2 a) (@filter.principal.{u} α t)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} α}, iff (@is_closed.{u} α _inst_1 (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)) (@is_open.{u} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {a : Prop}, a → not (not a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>318  let ⟨t, ht₁, ht₂, ht₃⟩ := this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} α) (λ (t : set.{u} α), and (@is_open.{u} α _inst_1 t) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s&#x27;) t) (@eq.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a) (@filter.principal.{u} α t)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)))))))) → @Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t (@nhds.{u} α _inst_1 a)) (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t (@nhds.{u} α _inst_1 a)), and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s) (@is_closed.{u} α _inst_1 t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u} α _inst_1 t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s&#x27;) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} α) (λ (t : set.{u} α), and (@is_open.{u} α _inst_1 t) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s&#x27;) t) (@eq.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a) (@filter.principal.{u} α t)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>319  ⟨-t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>320    mem_sets_of_eq_bot $ by rwa [lattice.neg_neg],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.mem_sets_of_eq_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='lattice.neg_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 406, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/boolean_algebra.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {f : filter.{u} α} {s : set.{u} α}, @eq.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) f (@filter.principal.{u} α (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))) → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {x : α} [_inst_1 : lattice.boolean_algebra.{u} α], @eq.{u+1} α (@has_neg.neg.{u} α (@lattice.boolean_algebra.to_has_neg.{u} α _inst_1) (@has_neg.neg.{u} α (@lattice.boolean_algebra.to_has_neg.{u} α _inst_1) x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @regular_space.{u} α _inst_1,
a : α,
s : set.{u} α,
h : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t : set.{u} α),
       @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s)
         (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s),
            and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t))) →
  @Exists.{u+1} (set.{u} α)
    (λ (t : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t (@nhds.{u} α _inst_1 a))
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t (@nhds.{u} α _inst_1 a)),
            and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s) (@is_closed.{u} α _inst_1 t))),
s&#x27; : set.{u} α,
h₁ : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s&#x27; s,
h₂ : @is_open.{u} α _inst_1 s&#x27;,
h₃ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s&#x27;,
this :
  @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (t : set.{u} α),
       and (@is_open.{u} α _inst_1 t)
         (and
            (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
               (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s&#x27;)
               t)
            (@eq.{u+1} (filter.{u} α)
               (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
                  (@filter.principal.{u} α t))
               (@lattice.has_bot.bot.{u} (filter.{u} α)
                  (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
                     (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                        (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                           (@filter.lattice.complete_lattice.{u} α)))))))),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (t : set.{u} α),
       and (@is_open.{u} α _inst_1 t)
         (and
            (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
               (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s&#x27;)
               t)
            (@eq.{u+1} (filter.{u} α)
               (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
                  (@filter.principal.{u} α t))
               (@lattice.has_bot.bot.{u} (filter.{u} α)
                  (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
                     (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                        (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                           (@filter.lattice.complete_lattice.{u} α)))))))) →
  @Exists.{u+1} (set.{u} α)
    (λ (t : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t (@nhds.{u} α _inst_1 a))
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t (@nhds.{u} α _inst_1 a)),
            and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s) (@is_closed.{u} α _inst_1 t))),
t : set.{u} α,
ht₁ : @is_open.{u} α _inst_1 t,
ht₂ :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s&#x27;)
    t,
ht₃ :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
       (@filter.principal.{u} α t))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))
⊢ @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
       (@filter.principal.{u} α
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
             (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) t))))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @regular_space.{u} α _inst_1,
a : α,
s : set.{u} α,
h : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a),
_let_match :
  @Exists.{u+1} (set.{u} α)
    (λ (t : set.{u} α),
       @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s)
         (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s),
            and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t))) →
  @Exists.{u+1} (set.{u} α)
    (λ (t : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t (@nhds.{u} α _inst_1 a))
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t (@nhds.{u} α _inst_1 a)),
            and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s) (@is_closed.{u} α _inst_1 t))),
s&#x27; : set.{u} α,
h₁ : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s&#x27; s,
h₂ : @is_open.{u} α _inst_1 s&#x27;,
h₃ : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s&#x27;,
this :
  @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (t : set.{u} α),
       and (@is_open.{u} α _inst_1 t)
         (and
            (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
               (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s&#x27;)
               t)
            (@eq.{u+1} (filter.{u} α)
               (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
                  (@filter.principal.{u} α t))
               (@lattice.has_bot.bot.{u} (filter.{u} α)
                  (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
                     (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                        (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                           (@filter.lattice.complete_lattice.{u} α)))))))),
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (t : set.{u} α),
       and (@is_open.{u} α _inst_1 t)
         (and
            (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
               (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s&#x27;)
               t)
            (@eq.{u+1} (filter.{u} α)
               (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
                  (@filter.principal.{u} α t))
               (@lattice.has_bot.bot.{u} (filter.{u} α)
                  (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
                     (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
                        (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                           (@filter.lattice.complete_lattice.{u} α)))))))) →
  @Exists.{u+1} (set.{u} α)
    (λ (t : set.{u} α),
       @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t (@nhds.{u} α _inst_1 a))
         (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t (@nhds.{u} α _inst_1 a)),
            and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s) (@is_closed.{u} α _inst_1 t))),
t : set.{u} α,
ht₁ : @is_open.{u} α _inst_1 t,
ht₂ :
  @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s&#x27;)
    t,
ht₃ :
  @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
       (@filter.principal.{u} α t))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))
⊢ @eq.{u+1} (filter.{u} α)
    (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 a)
       (@filter.principal.{u} α t))
    (@lattice.has_bot.bot.{u} (filter.{u} α)
       (@lattice.order_bot.to_has_bot.{u} (filter.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α)
                (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>321    subset.trans (compl_subset_comm.1 ht₂) h₁,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.compl_subset_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 646, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {a b c : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a b → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b c → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α}, iff (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s) t) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) t) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>322    is_closed_compl_iff.mpr ht₁⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_closed_compl_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {s : set.{u} α}, iff (@is_closed.{u} α _inst_1 (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)) (@is_open.{u} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>323  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>324  variable (α)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>325  @[priority 100] -- see Note [lower instance priority]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>326  instance regular_space.t2_space [regular_space α] : t2_space α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='regular_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;line&#x27;: 309, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='A T₃ space, also known as a regular space (although this condition sometimes
 omits T₂), is one in which for every closed `C` and `x ∉ C`, there exist
 disjoint open sets containing `x` and `C` respectively.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>327  ⟨λ x y hxy,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>328  let ⟨s, hs, hys, hxs⟩ := regular_space.regular is_closed_singleton</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hys'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hxs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='regular_space.regular'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_closed_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 309, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} α) (λ (t : set.{u} α), and (@is_open.{u} α _inst_1 t) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) t) (@eq.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@filter.principal.{u} α t)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)))))))) → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α _inst_1 u) (and (@is_open.{u} α _inst_1 v) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x u) (and (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y v) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@filter.principal.{u} α s)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} [_inst_2 : topological_space.{u} α] [c : @regular_space.{u} α _inst_2] {s : set.{u} α} {a : α}, @is_closed.{u} α _inst_2 s → not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (t : set.{u} α), and (@is_open.{u} α _inst_2 t) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t) (@eq.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_2 a) (@filter.principal.{u} α t)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : @t1_space.{u} α _inst_1] {x : α}, @is_closed.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>329      (mt mem_singleton_iff.1 hxy),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.mem_singleton_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 509, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {a b : Prop}, (a → b) → not b → not a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {a b : α}, iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) b)) (@eq.{u+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@ne.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>330    ⟨t, hxt, u, hsu, htu⟩ := empty_in_sets_eq_bot.2 hxs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='hxt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hsu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='htu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='filter.empty_in_sets_eq_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t (@nhds.{u} α _inst_1 x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) u (@filter.principal.{u} α s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t u) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {f : filter.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) f) (@eq.{u+1} (filter.{u} α) f (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>331    ⟨v, hvt, hv, hxv⟩ := mem_nhds_sets_iff.1 hxt in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hvt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hxv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mem_nhds_sets_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 421, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) v t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u} α _inst_1 v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α} {s : set.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a)) (@Exists.{u+1} (set.{u} α) (λ (t : set.{u} α), @Exists.{0} (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s) (λ (H : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s), and (@is_open.{u} α _inst_1 t) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>332  ⟨v, s, hv, hs, hxv, singleton_subset_iff.1 hys,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='set.singleton_subset_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 535, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='∀ {α : Type u} {a : α} {s : set.{u} α}, iff (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) a) s) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>333  eq_empty_of_subset_empty $ λ z ⟨hzv, hzs⟩, htu ⟨hvt hzv, hsu hzs⟩⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.eq_empty_of_subset_empty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='hzv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hzs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) → @eq.{(max (u+1) 1)} (set.{u} α) s (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) v s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>334  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>335  end regularity</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>336  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>337  section normality</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>338  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>339  section prio</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>340  set_option default_priority 100 -- see Note [default priority]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='default priority for attributes'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>341  /-- A T₄ space, also known as a normal space (although this condition sometimes</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>342    omits T₂), is one in which for every pair of disjoint closed sets `C` and `D`,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>343    there exist disjoint open sets containing `C` and `D` respectively. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>344  class normal_space (α : Type u) [topological_space α] extends t1_space α : Prop :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='t1_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='A T₁ space, also known as a Fréchet space, is a topological space
 where every singleton set is closed. Equivalently, for every pair
 `x ≠ y`, there is an open set containing `x` and not `y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>345  (normal : ∀ s t : set α, is_closed s → is_closed t → disjoint s t →</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='normal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='disjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 758, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='∀ (s t : set.{u} α), @is_closed.{u} α _inst_2 s → @is_closed.{u} α _inst_2 t → @disjoint.{u} (set.{u} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))) s t → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α _inst_2 u) (and (@is_open.{u} α _inst_2 v) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t v) (@disjoint.{u} (set.{u} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))) u v))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : lattice.semilattice_inf_bot.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A set is closed if its complement is open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A set is closed if its complement is open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Two elements of a lattice are disjoint if their inf is the bottom element.
 (This generalizes disjoint sets, viewed as members of the subset lattice.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>346    ∃ u v, is_open u ∧ is_open v ∧ s ⊆ u ∧ t ⊆ v ∧ disjoint u v)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='disjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 758, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : lattice.semilattice_inf_bot.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='Two elements of a lattice are disjoint if their inf is the bottom element.
 (This generalizes disjoint sets, viewed as members of the subset lattice.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>347  end prio</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>348  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>349  theorem normal_separation [normal_space α] (s t : set α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='normal_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 344, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A T₄ space, also known as a normal space (although this condition sometimes
 omits T₂), is one in which for every pair of disjoint closed sets `C` and `D`,
 there exist disjoint open sets containing `C` and `D` respectively.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>350    (H1 : is_closed s) (H2 : is_closed t) (H3 : disjoint s t) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='disjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 758, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : lattice.semilattice_inf_bot.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A set is closed if its complement is open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A set is closed if its complement is open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Two elements of a lattice are disjoint if their inf is the bottom element.
 (This generalizes disjoint sets, viewed as members of the subset lattice.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>351    ∃ u v, is_open u ∧ is_open v ∧ s ⊆ u ∧ t ⊆ v ∧ disjoint u v :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='disjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 758, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : lattice.semilattice_inf_bot.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='Two elements of a lattice are disjoint if their inf is the bottom element.
 (This generalizes disjoint sets, viewed as members of the subset lattice.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>352  normal_space.normal s t H1 H2 H3</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='normal_space.normal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 344, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_2 : topological_space.{u} α] [c : @normal_space.{u} α _inst_2] (s t : set.{u} α), @is_closed.{u} α _inst_2 s → @is_closed.{u} α _inst_2 t → @disjoint.{u} (set.{u} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))) s t → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α _inst_2 u) (and (@is_open.{u} α _inst_2 v) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t v) (@disjoint.{u} (set.{u} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))) u v))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_closed.{u} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_closed.{u} α _inst_1 t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@disjoint.{u} (set.{u} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))) s t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>353  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>354  @[priority 100] -- see Note [lower instance priority]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>355  instance normal_space.regular_space [normal_space α] : regular_space α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='normal_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='regular_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;line&#x27;: 344, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 309, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='A T₄ space, also known as a normal space (although this condition sometimes
 omits T₂), is one in which for every pair of disjoint closed sets `C` and `D`,
 there exist disjoint open sets containing `C` and `D` respectively.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A T₃ space, also known as a regular space (although this condition sometimes
 omits T₂), is one in which for every closed `C` and `x ∉ C`, there exist
 disjoint open sets containing `x` and `C` respectively.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>356  { regular := λ s x hs hxs, let ⟨u, v, hu, hv, hsu, hxv, huv⟩ := normal_separation s {x} hs is_closed_singleton</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hxs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hsu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hxv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='huv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='normal_separation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_closed_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                </code><font color='red'><a title='{&#x27;line&#x27;: 349, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_closed.{u} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α _inst_1 u) (and (@is_open.{u} α _inst_1 v) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x) v) (@disjoint.{u} (set.{u} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))) u v)))))) → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (t : set.{u} α), and (@is_open.{u} α _inst_1 t) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t) (@eq.{u+1} (filter.{u} α) (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) (@nhds.{u} α _inst_1 x) (@filter.principal.{u} α t)) (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u} α _inst_1 u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u} α _inst_1 v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x) v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@disjoint.{u} (set.{u} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))) u v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : @normal_space.{u} α _inst_1] (s t : set.{u} α), @is_closed.{u} α _inst_1 s → @is_closed.{u} α _inst_1 t → @disjoint.{u} (set.{u} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))) s t → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α _inst_1 u) (and (@is_open.{u} α _inst_1 v) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t v) (@disjoint.{u} (set.{u} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))) u v))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_closed.{u} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : @t1_space.{u} α _inst_1] {x : α}, @is_closed.{u} α _inst_1 (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>357        (λ _ ⟨hx, hy⟩, hxs $ set.mem_of_eq_of_mem (set.eq_of_mem_singleton hy).symm hx) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hxs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.mem_of_eq_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.eq_of_mem_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 518, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) _x (@lattice.has_inf.inf.{u} (set.{u} α) (@lattice.semilattice_inf.to_has_inf.{u} (set.{u} α) (@lattice.semilattice_inf_bot.to_semilattice_inf.{u} (set.{u} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))))) s (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) _x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) _x (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {x y : α} {s : set.{u} α}, @eq.{u+1} α x y → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {x y : α}, @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) y) → @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {a b : α}, @eq.{u+1} α a b → @eq.{u+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>358      ⟨u, hu, hsu, filter.empty_in_sets_eq_bot.1 $ filter.mem_inf_sets.2</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='filter.empty_in_sets_eq_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='filter.mem_inf_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 277, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {α : Type u} {f : filter.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) f) (@eq.{u+1} (filter.{u} α) f (@lattice.has_bot.bot.{u} (filter.{u} α) (@lattice.order_bot.to_has_bot.{u} (filter.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (filter.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {f g : filter.{u} α} {s : set.{u} α}, iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@lattice.has_inf.inf.{u} (filter.{u} α) (@filter.lattice.has_inf.{u} α) f g)) (@Exists.{u+1} (set.{u} α) (λ (t₁ : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ f) (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₁ f), @Exists.{u+1} (set.{u} α) (λ (t₂ : set.{u} α), @Exists.{0} (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ g) (λ (H : @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) t₂ g), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t₁ t₂) s)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>359        ⟨v, mem_nhds_sets hv (set.singleton_subset_iff.1 hxv), u, filter.mem_principal_self u, set.inter_comm u v ▸ huv⟩⟩ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='mem_nhds_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.singleton_subset_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='filter.mem_principal_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.inter_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 535, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 196, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 367, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] {a : α} {s : set.{u} α}, @is_open.{u} α _inst_1 s → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@nhds.{u} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {a : α} {s : set.{u} α}, iff (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) a) s) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='∀ {α : Type u} (s : set.{u} α), @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@filter.principal.{u} α s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} (a b : set.{u} α), @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) a b) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>360  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>361  -- We can&#x27;t make this an instance because it could cause an instance loop.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>362  lemma normal_of_compact_t2 [compact_space α] [t2_space α] : normal_space α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='compact_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='normal_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 344, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [_inst_2 : topological_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title=' Type class for compact spaces. Separation is sometimes included in the definition, especially
in the French literature, but we do not include it here.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A T₄ space, also known as a normal space (although this condition sometimes
 omits T₂), is one in which for every pair of disjoint closed sets `C` and `D`,
 there exist disjoint open sets containing `C` and `D` respectively.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>363  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @compact_space.{u} α _inst_1,
_inst_3 : @t2_space.{u} α _inst_1
⊢ @normal_space.{u} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>364    refine ⟨assume s t hs ht st, _⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @compact_space.{u} α _inst_1,
_inst_3 : @t2_space.{u} α _inst_1
⊢ @normal_space.{u} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @compact_space.{u} α _inst_1,
_inst_3 : @t2_space.{u} α _inst_1,
s t : set.{u} α,
hs : @is_closed.{u} α _inst_1 s,
ht : @is_closed.{u} α _inst_1 t,
st :
  @disjoint.{u} (set.{u} α)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α)
       (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))
    s
    t
⊢ @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (u : set.{u} α),
       @Exists.{(max (u+1) 1)} (set.{u} α)
         (λ (v : set.{u} α),
            and (@is_open.{u} α _inst_1 u)
              (and (@is_open.{u} α _inst_1 v)
                 (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u)
                    (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t v)
                       (@disjoint.{u} (set.{u} α)
                          (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α)
                             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))
                          u
                          v))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>365    simp only [disjoint_iff],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='disjoint_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 763, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : lattice.semilattice_inf_bot.{?l_1} α] {a b : α}, iff (@disjoint.{?l_1} α _inst_1 a b) (@eq.{?l_1+1} α (@lattice.has_inf.inf.{?l_1} α (@lattice.semilattice_inf.to_has_inf.{?l_1} α (@lattice.semilattice_inf_bot.to_semilattice_inf.{?l_1} α _inst_1)) a b) (@lattice.has_bot.bot.{?l_1} α (@lattice.order_bot.to_has_bot.{?l_1} α (@lattice.semilattice_inf_bot.to_order_bot.{?l_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @compact_space.{u} α _inst_1,
_inst_3 : @t2_space.{u} α _inst_1,
s t : set.{u} α,
hs : @is_closed.{u} α _inst_1 s,
ht : @is_closed.{u} α _inst_1 t,
st :
  @disjoint.{u} (set.{u} α)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α)
       (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))
    s
    t
⊢ @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (u : set.{u} α),
       @Exists.{(max (u+1) 1)} (set.{u} α)
         (λ (v : set.{u} α),
            and (@is_open.{u} α _inst_1 u)
              (and (@is_open.{u} α _inst_1 v)
                 (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u)
                    (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t v)
                       (@disjoint.{u} (set.{u} α)
                          (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α)
                             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))
                          u
                          v))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @compact_space.{u} α _inst_1,
_inst_3 : @t2_space.{u} α _inst_1,
s t : set.{u} α,
hs : @is_closed.{u} α _inst_1 s,
ht : @is_closed.{u} α _inst_1 t,
st :
  @disjoint.{u} (set.{u} α)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α)
       (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))
    s
    t
⊢ @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (u : set.{u} α),
       @Exists.{(max (u+1) 1)} (set.{u} α)
         (λ (v : set.{u} α),
            and (@is_open.{u} α _inst_1 u)
              (and (@is_open.{u} α _inst_1 v)
                 (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u)
                    (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t v)
                       (@eq.{u+1} (set.{u} α)
                          (@lattice.has_inf.inf.{u} (set.{u} α)
                             (@lattice.semilattice_inf.to_has_inf.{u} (set.{u} α)
                                (@lattice.semilattice_inf_bot.to_semilattice_inf.{u} (set.{u} α)
                                   (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α)
                                      (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α)
                                         (@set.lattice_set.{u} α)))))
                             u
                             v)
                          (@lattice.has_bot.bot.{u} (set.{u} α)
                             (@lattice.order_bot.to_has_bot.{u} (set.{u} α)
                                (@lattice.semilattice_inf_bot.to_order_bot.{u} (set.{u} α)
                                   (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α)
                                      (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α)
                                         (@set.lattice_set.{u} α))))))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>366    exact compact_compact_separated hs.compact ht.compact st.eq_bot</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='compact_compact_separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='st'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 284, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 284, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 760, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α] [_inst_3 : @t2_space.{u} α _inst_1] {s t : set.{u} α}, @compact.{u} α _inst_1 s → @compact.{u} α _inst_1 t → @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) → @Exists.{(max (u+1) 1)} (set.{u} α) (λ (u : set.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (v : set.{u} α), and (@is_open.{u} α _inst_1 u) (and (@is_open.{u} α _inst_1 v) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u) (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t v) (@eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) u v) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_closed.{u} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_closed.{u} α _inst_1 t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@disjoint.{u} (set.{u} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))) s t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : topological_space.{u} α,
_inst_2 : @compact_space.{u} α _inst_1,
_inst_3 : @t2_space.{u} α _inst_1,
s t : set.{u} α,
hs : @is_closed.{u} α _inst_1 s,
ht : @is_closed.{u} α _inst_1 t,
st :
  @disjoint.{u} (set.{u} α)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α)
       (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))
    s
    t
⊢ @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (u : set.{u} α),
       @Exists.{(max (u+1) 1)} (set.{u} α)
         (λ (v : set.{u} α),
            and (@is_open.{u} α _inst_1 u)
              (and (@is_open.{u} α _inst_1 v)
                 (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s u)
                    (and (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t v)
                       (@eq.{u+1} (set.{u} α)
                          (@lattice.has_inf.inf.{u} (set.{u} α)
                             (@lattice.semilattice_inf.to_has_inf.{u} (set.{u} α)
                                (@lattice.semilattice_inf_bot.to_semilattice_inf.{u} (set.{u} α)
                                   (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α)
                                      (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α)
                                         (@set.lattice_set.{u} α)))))
                             u
                             v)
                          (@lattice.has_bot.bot.{u} (set.{u} α)
                             (@lattice.order_bot.to_has_bot.{u} (set.{u} α)
                                (@lattice.semilattice_inf_bot.to_order_bot.{u} (set.{u} α)
                                   (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α)
                                      (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α)
                                         (@set.lattice_set.{u} α))))))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>367  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>368  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>369  end normality</code></pre>
</body>